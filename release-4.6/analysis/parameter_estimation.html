<!DOCTYPE html><HTML lang="en"><head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Parameter Estimation · DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="https://docs.juliadiffeq.org/stable/analysis/parameter_estimation/index.html" rel="canonical"/><script data-is-old-version="">document.addEventListener("DOMContentLoaded", function(){
    const div = document.createElement('div');
    div.setAttribute('style', 'position: fixed; bottom: 1em; right: 1em; z-index: 999; background-color: #ffaf9c; color: rgba(0, 0, 0, 0.7); border: 1px solid #d54625; border-radius: 4px; padding: 2em; text-align: center');
    const closer = document.createElement('div');
    closer.setAttribute('style', 'position: absolute; top: 0; right: 5px; padding: 5px; cursor: pointer; width: 12px; height: 12px;')
    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', () => {
        document.body.removeChild(div)
    })
    const href = documenterBaseURL + '/../stable'
    div.innerHTML = 'This is an old version of the documentation. <br> Click <a href="' + href + '">here</a> to go to the newest version.';
    div.appendChild(closer)
    document.body.appendChild(div);
});
</script></head><body><nav class="toc"><a href="../index.html"><img alt="DifferentialEquations.jl logo" class="logo" src="../assets/logo.png"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search.html" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/bvp_example.html">Boundary Value Problems</a></li><li><a class="toctext" href="../tutorials/additional.html">Additional Tutorials</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li><li><a class="toctext" href="../basics/integrator.html">Integrator Interface</a></li><li><a class="toctext" href="../basics/problem.html">Problem interface</a></li><li><a class="toctext" href="../basics/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../basics/compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Problems</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Problems</a></li><li><a class="toctext" href="../types/dynamical_types.html">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../types/split_ode_types.html">Split ODE Problems</a></li><li><a class="toctext" href="../types/steady_state_types.html">Steady State Problems</a></li><li><a class="toctext" href="../types/bvp_types.html">BVP Problems</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Problems</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Problems</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Problems</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Problems</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../solvers/discrete_solve.html">Discrete Solvers</a></li><li><a class="toctext" href="../solvers/ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="../solvers/dynamical_solve.html">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="../solvers/split_ode_solve.html">Split ODE Solvers</a></li><li><a class="toctext" href="../solvers/steady_state_solve.html">Steady State Solvers</a></li><li><a class="toctext" href="../solvers/bvp_solve.html">BVP Solvers</a></li><li><a class="toctext" href="../solvers/jump_solve.html">Jump Problem Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="../solvers/rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="../solvers/dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="../solvers/dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="../solvers/benchmarks.html">Solver Benchmarks</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="../features/performance_overloads.html">Performance Overloads</a></li><li><a class="toctext" href="../features/diffeq_arrays.html">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="../features/diffeq_operator.html">DiffEqOperators</a></li><li><a class="toctext" href="../features/noise_process.html">Noise Processes</a></li><li><a class="toctext" href="../features/linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="../features/callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="../features/callback_library.html">Callback Library</a></li><li><a class="toctext" href="../features/monte_carlo.html">Parallel Monte Carlo Simulations</a></li><li><a class="toctext" href="../features/io.html">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="../features/low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="../features/progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="parameterized_functions.html">ParameterizedFunctions</a></li><li class="current"><a class="toctext" href="parameter_estimation.html">Parameter Estimation</a><ul class="internal"><li><a class="toctext" href="#Recommended-Methods-1">Recommended Methods</a></li><li><a class="toctext" href="#Optimization-Based-Methods-1">Optimization-Based Methods</a></li><li><a class="toctext" href="#Bayesian-Methods-1">Bayesian Methods</a></li><li><a class="toctext" href="#Optimization-Based-ODE-Inference-Examples-1">Optimization-Based ODE Inference Examples</a></li><li><a class="toctext" href="#Parameter-Estimation-for-Stochastic-Differential-Equations-and-Monte-Carlo-1">Parameter Estimation for Stochastic Differential Equations and Monte Carlo</a></li><li><a class="toctext" href="#Bayesian-Inference-Examples-1">Bayesian Inference Examples</a></li></ul></li><li><a class="toctext" href="bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="sensitivity.html">Sensitivity Analysis</a></li><li><a class="toctext" href="uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/physical.html">Physical Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Chemical Reaction Models</a></li><li><a class="toctext" href="../models/external_modeling.html">External Modeling Packages</a></li></ul></li><li><span class="toctext">Extra Details</span><ul><li><a class="toctext" href="../extras/timestepping.html">Timestepping Method Descriptions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Analysis Tools</li><li><a href="parameter_estimation.html">Parameter Estimation</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/blob/master/docs/src/analysis/parameter_estimation.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Parameter Estimation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#Parameter-Estimation-1" id="Parameter-Estimation-1">Parameter Estimation</a></h1><p>Parameter estimation for ODE models, also known as dynamic data analysis, is provided by the DiffEq suite.</p><h2><a class="nav-anchor" href="#Recommended-Methods-1" id="Recommended-Methods-1">Recommended Methods</a></h2><p>The recommended method is to use <code>build_loss_objective</code> with the optimizer of your choice. This method can thus be paired with global optimizers from packages like BlackBoxOptim.jl or NLopt.jl which can be much less prone to finding local minima than local optimization methods. Also, it allows the user to define the cost function in the way they choose as a function <code>loss(sol)</code>, and thus can fit using any cost function on the solution, making it applicable to fitting non-temporal data and other types of problems. Also, <code>build_loss_objective</code> works for all of the <code>DEProblem</code> types, allowing it to optimize parameters on ODEs, SDEs, DDEs, DAEs, etc.</p><p>However, this method requires repeated solution of the differential equation. If the data is temporal data, the most efficient method is the <code>two_stage_method</code> which does not require repeated solutions but is not as accurate. Usage of the <code>two_stage_method</code> should have a post-processing step which refines using a method like <code>build_loss_objective</code>.</p><h2><a class="nav-anchor" href="#Optimization-Based-Methods-1" id="Optimization-Based-Methods-1">Optimization-Based Methods</a></h2><h3><a class="nav-anchor" href="#two_stage_method-1" id="two_stage_method-1">two_stage_method</a></h3><p>The two-stage method is a collocation method for estimating parameters without requiring repeated solving of the differential equation. It does so by determining a smoothed estimated trajectory of the data and optimizing the derivative function and the data's timepoints to match the derivatives of the smoothed trajectory. This method has less accuracy than other methods but is much faster, and is a good method to try first to get in the general "good parameter" region, to then finish using one of the other methods.</p><pre><code class="language-julia">function two_stage_method(prob::DEProblem,tpoints,data;kernel= :Epanechnikov,
                          loss_func = L2DistLoss,mpg_autodiff = false,
                          verbose = false,verbose_steps = 100)</code></pre><h3><a class="nav-anchor" href="#build_loss_objective-1" id="build_loss_objective-1">build_loss_objective</a></h3><p><code>build_loss_objective</code> builds an objective function to be used with Optim.jl and MathProgBase-associated solvers like NLopt.</p><pre><code class="language-julia">function build_loss_objective(prob::DEProblem,alg,loss_func
                              regularization=nothing;
                              mpg_autodiff = false,
                              verbose_opt = false,
                              verbose_steps = 100,
                              prob_generator = problem_new_parameters,
                              kwargs...)</code></pre><p>The first argument is the <code>DEProblem</code> to solve, and next is the <code>alg</code> to use. The <code>alg</code> must match the problem type, which can be any <code>DEProblem</code> (ODEs, SDEs, DAEs, DDEs, etc.). <code>regularization</code> defaults to nothing which has no regularization function. One can also choose <code>verbose_opt</code> and <code>verbose_steps</code>, which, in the optimization routines, will print the steps and the values at the steps every <code>verbose_steps</code> steps. <code>mpg_autodiff</code> uses autodifferentiation to define the derivative for the MathProgBase solver. The extra keyword arguments are passed to the differential equation solver.</p><h4><a class="nav-anchor" href="#The-Loss-Function-1" id="The-Loss-Function-1">The Loss Function</a></h4><pre><code class="language-julia">loss_func(sol)</code></pre><p>is a function which reduces the problem's solution to a scalar which the optimizer will try to minimize. While this is very flexible, two convenience routines are included for fitting to data with standard cost functions:</p><pre><code class="language-julia">L2Loss(t,data;weight=nothing)
CostVData(t,data;loss_func = L2Loss,weight=nothing)
</code></pre><p>where <code>t</code> is the set of timepoints which the data is found at, and <code>data</code> are the values that are known where each column corresponds to measures of the values of the system. <code>L2Loss</code> is an optimized version of the L2-distance. In <code>CostVData</code>, one can choose any loss function from LossFunctions.jl or use the default of an L2 loss. The <code>weight</code> is a vector of weights for the loss function which must match the size of the data. Note that minimization of a weighted <code>L2Loss</code> is equivalent to maximum likelihood estimation of a heteroskedastic Normally distributed likelihood.</p><p>Additionally, we include a more flexible log-likelihood approach:</p><pre><code class="language-julia">LogLikeLoss(t,distributions;loss_func = L2Loss,weight=nothing)</code></pre><p>In this case, there are two forms. The simple case is where <code>distributions[i,j]</code> is the likelihood distributions from a <code>UnivariateDistribution</code> from <a href="https://juliastats.github.io/Distributions.jl/latest/">Distributions.jl</a>, where it corresponds to the likelihood at <code>t[i]</code> for component <code>j</code>. The second case is where <code>distributions[i]</code> is a <code>MultivariateDistribution</code> which corresponds to the likelihood at <code>t[i]</code> over the vector of components. This likelihood function then calculates the negative of the total loglikelihood over time as its objective value (negative since optimizers generally find minimimums, and thus this corresponds to maximum likelihood estimation).</p><p>Note that these distributions can be generated via <code>fit_mle</code> on some dataset against some chosen distribution type.</p><h4><a class="nav-anchor" href="#Note-About-Loss-Functions-1" id="Note-About-Loss-Functions-1">Note About Loss Functions</a></h4><p>For parameter estimation problems, it's not uncommon for the optimizers to hit unstable regions of parameter space. This causes warnings that the solver exited early, and the built-in loss functions like <code>L2Loss</code> and <code>CostVData</code> automatically handle this. However, if using a user-supplied loss function, you should make sure it's robust to these issues. One common pattern is to apply infinite loss when the integration is not successful. Using the retcodes, this can be done via:</p><pre><code class="language-julia">function my_loss_function(sol)
   tot_loss = 0.0
   if any((s.retcode != :Success for s in sol))
     tot_loss = Inf
   else
     # calculation for the loss here
   end
   tot_loss
end</code></pre><h4><a class="nav-anchor" href="#The-Regularization-Function-1" id="The-Regularization-Function-1">The Regularization Function</a></h4><p>The regularization can be any function of <code>p</code>, the parameter vector:</p><pre><code class="language-julia">regularization(p)</code></pre><p>The <code>Regularization</code> helper function builds a regularization using a penalty function <code>penalty</code> from <a href="https://github.com/JuliaML/PenaltyFunctions.jl">PenaltyFunctions.jl</a>:</p><pre><code class="language-julia">Regularization(λ,penalty=L2Penalty())</code></pre><p>The regularization defaults to L2 if no penalty function is specified. <code>λ</code> is the weight parameter for the addition of the regularization term.</p><h4><a class="nav-anchor" href="#The-Problem-Generator-Function-1" id="The-Problem-Generator-Function-1">The Problem Generator Function</a></h4><p>The argument <code>prob_generator</code> allows one to specify a function for generating new problems from a given parameter set. By default, this just builds a new problem which fixes the element types in a way that's autodifferentiation compatible and adds the new parameter vector <code>p</code>. For example, for ODEs this is given by the dispatch on <code>DiffEqBase.problem_new_parameters</code> which does the following:</p><pre><code class="language-julia">function problem_new_parameters(prob::ODEProblem,p;kwargs...)
  uEltype = eltype(p)
  u0 = [uEltype(prob.u0[i]) for i in 1:length(prob.u0)]
  tspan = (uEltype(prob.tspan[1]),uEltype(prob.tspan[2]))
  ODEProblem{isinplace(prob)}(prob.f,u0,tspan,p,prob.problem_type;
  callback = prob.callback, mass_matrix = prob.mass_matrix,
  kwargs...)
end</code></pre><p>Then the new problem with these new values is returned.</p><p>One can use this to change the meaning of the parameters using this function. For example, if one instead wanted to optimize the initial conditions for a function without parameters, you could change this to:</p><pre><code class="language-julia">function my_problem_new_parameters(prob::ODEProblem,p)
  uEltype = eltype(p)
  tspan = (uEltype(prob.tspan[1]),uEltype(prob.tspan[2]))
  ODEProblem(prob.f,p,tspan)
end</code></pre><p>which simply matches the type for time to <code>p</code> (once again, for autodifferentiation) and uses <code>p</code> as the initial condition in the initial value problem.</p><h3><a class="nav-anchor" href="#build_lsoptim_objective-1" id="build_lsoptim_objective-1">build_lsoptim_objective</a></h3><p><code>build_lsoptim_objective</code> builds an objective function to be used with LeastSquaresOptim.jl.</p><pre><code class="language-julia">build_lsoptim_objective(prob,tspan,t,data;prob_generator = problem_new_parameters,kwargs...)</code></pre><p>The arguments are the same as <code>build_loss_objective</code>.</p><h3><a class="nav-anchor" href="#lm_fit-1" id="lm_fit-1">lm_fit</a></h3><p><code>lm_fit</code> is a function for fitting the parameters of an ODE using the Levenberg-Marquardt algorithm. This algorithm is really bad and thus not recommended since, for example, the Optim.jl algorithms on an L2 loss are more performant and robust. However, this is provided for completeness as most other differential equation libraries use an LM-based algorithm, so this allows one to test the increased effectiveness of not using LM.</p><pre><code class="language-julia">lm_fit(prob::DEProblem,tspan,t,data,p0;prob_generator = problem_new_parameters,kwargs...)</code></pre><p>The arguments are similar to before, but with <code>p0</code> being the initial conditions for the parameters and the <code>kwargs</code> as the args passed to the LsqFit <code>curve_fit</code> function (which is used for the LM solver). This returns the fitted parameters.</p><h2><a class="nav-anchor" href="#Bayesian-Methods-1" id="Bayesian-Methods-1">Bayesian Methods</a></h2><p>The following methods require the DiffEqBayes.jl</p><pre><code class="language-julia">Pkg.add("DiffEqBayes")
using DiffEqBayes</code></pre><h3><a class="nav-anchor" href="#stan_inference-1" id="stan_inference-1">stan_inference</a></h3><pre><code class="language-julia">stan_inference(prob::ODEProblem,t,data,priors = nothing;alg=:rk45,
               num_samples=1000, num_warmup=1000, reltol=1e-3,
               abstol=1e-6, maxiter=Int(1e5),likelihood=Normal,
               vars=(StanODEData(),InverseGamma(2,3)))</code></pre><p><code>stan_inference</code> uses <a href="http://goedman.github.io/Stan.jl/latest/INTRO.html">Stan.jl</a> to perform the Bayesian inference. The <a href="http://goedman.github.io/Stan.jl/latest/INSTALLATION.html">Stan installation process</a> is required to use this function. The input requires that the function is defined by a <code>ParameterizedFunction</code> with the <code>@ode_def</code> macro. <code>t</code> is the array of time and <code>data</code> is the array where the first dimension (columns) corresponds to the array of system values. <code>priors</code> is an array of prior distributions for each parameter, specified via a <a href="https://juliastats.github.io/Distributions.jl/latest/">Distributions.jl</a> type. <code>alg</code> is a choice between <code>:rk45</code> and <code>:bdf</code>, the two internal integrators of Stan. <code>num_samples</code> is the number of samples to take per chain, and <code>num_warmup</code> is the number of MCMC warmup steps. <code>abstol</code> and <code>reltol</code> are the keyword arguments for the internal integrator. <code>liklihood</code> is the likelihood distribution to use with the arguments from <code>vars</code>, and <code>vars</code> is a tuple of priors for the distributions of the likelihood hyperparameters. The special value <code>StanODEData()</code> in this tuple denotes the position that the ODE solution takes in the likelihood's parameter list.</p><h3><a class="nav-anchor" href="#turing_inference-1" id="turing_inference-1">turing_inference</a></h3><pre><code class="language-julia">turing_inference(prob::DEProblem,alg,t,data,priors = nothing;
                 num_samples=1000, epsilon = 0.02, tau = 4, kwargs...)</code></pre><p><code>turing_inference</code> uses <a href="https://github.com/yebai/Turing.jl">Turing.jl</a> to perform its parameter inference. <code>prob</code> can be any <code>DEProblem</code> with a corresponding <code>alg</code> choice. <code>t</code> is the array of time points and <code>data[:,i]</code> is the set of observations for the differential equation system at time point <code>t[i]</code> (or higher dimensional). <code>priors</code> is an array of prior distributions for each parameter, specified via a <a href="https://juliastats.github.io/Distributions.jl/latest/">Distributions.jl</a> type. <code>num_samples</code> is the number of samples per MCMC chain. <code>epsilon</code> and <code>tau</code> are the HMC parameters. The extra <code>kwargs</code> are given to the internal differential equation solver.</p><h3><a class="nav-anchor" href="#dynamichmc_inference-1" id="dynamichmc_inference-1">dynamichmc_inference</a></h3><pre><code class="language-julia">dynamichmc_inference(prob::DEProblem,alg,t,data,priors,transformations;
                      σ = 0.01,ϵ=0.001,initial=Float64[])</code></pre><p><code>dynamichmc_inference</code> uses <a href="https://github.com/tpapp/DynamicHMC.jl">DynamicHMC.jl</a> to   perform the bayesian parameter estimation. <code>prob</code> can be any <code>DEProblem</code>, <code>data</code> is the set   of observations for our model whihc is to be used in the Bayesian Inference process. <code>priors</code> represent the   choice of prior distributions for the parameters to be determined, passed as an array of <a href="https://juliastats.github.io/Distributions.jl/latest/">Distributions.jl</a> distributions. <code>t</code> is the array of time points. <code>transformations</code>  is an array of <a href="https://github.com/tpapp/ContinuousTransformations.jl">Tranformations</a> imposed for constraining the   parameter values to specific domains. <code>initial</code> values for the parameters can be passed, if not passed the means of the  <code>priors</code> are used. <code>ϵ</code> can be used as a kwarg to pass the initial step size for the NUTS algorithm.      </p><h3><a class="nav-anchor" href="#abc_inference-1" id="abc_inference-1">abc_inference</a></h3><pre><code class="language-julia">abc_inference(prob::DEProblem, alg, t, data, priors; ϵ=0.001,
     distancefunction = euclidean, ABCalgorithm = ABCSMC, progress = false,
     num_samples = 500, maxiterations = 10^5, kwargs...)</code></pre><p><code>abc_inference</code> uses <a href="https://github.com/marcjwilliams1/ApproxBayes.jl">ApproxBayes.jl</a> which uses Approximate Bayesian Computation (ABC) to perform its parameter inference. <code>prob</code> can be any <code>DEProblem</code> with a corresponding <code>alg</code> choice. <code>t</code> is the array of time points and <code>data[:,i]</code> is the set of observations for the differential equation system at time point <code>t[i]</code> (or higher dimensional). <code>priors</code> is an array of prior distributions for each parameter, specified via a <a href="https://juliastats.github.io/Distributions.jl/latest/">Distributions.jl</a> type. <code>num_samples</code> is the number of posterior samples. <code>ϵ</code> is the target distance between the data and simulated data. <code>distancefunction</code> is a distance metric specified from the <a href="https://github.com/JuliaStats/Distances.jl">Distances.jl</a> package, the default is <code>euclidean</code>. <code>ABCalgorithm</code> is the ABC algorithm to use, options are <code>ABCSMC</code> or <code>ABCRejection</code> from <a href="https://github.com/marcjwilliams1/ApproxBayes.jl">ApproxBayes.jl</a>, the default is the former which is more efficient. <code>maxiterations</code> is the maximum number of iterations before the algorithm terminates. The extra <code>kwargs</code> are given to the internal differential equation solver.</p><h2><a class="nav-anchor" href="#Optimization-Based-ODE-Inference-Examples-1" id="Optimization-Based-ODE-Inference-Examples-1">Optimization-Based ODE Inference Examples</a></h2><h3><a class="nav-anchor" href="#Simple-Local-Optimization-1" id="Simple-Local-Optimization-1">Simple Local Optimization</a></h3><p>We choose to optimize the parameters on the Lotka-Volterra equation. We do so by defining the function as a <a href="https://github.com/JuliaDiffEq/ParameterizedFunctions.jl">ParameterizedFunction</a>:</p><pre><code class="language-julia">f = @ode_def LotkaVolterraTest begin
  dx = a*x - x*y
  dy = -3y + x*y
end a

u0 = [1.0;1.0]
tspan = (0.0,10.0)
p = [1.5]
prob = ODEProblem(f,u0,tspan,p)</code></pre><p>We create data using the numerical result with <code>a=1.5</code>:</p><pre><code class="language-julia">sol = solve(prob,Tsit5())
t = collect(linspace(0,10,200))
using RecursiveArrayTools # for VectorOfArray
randomized = VectorOfArray([(sol(t[i]) + .01randn(2)) for i in 1:length(t)])
data = convert(Array,randomized)</code></pre><p>Here we used <code>VectorOfArray</code> from <a href="https://github.com/ChrisRackauckas/RecursiveArrayTools.jl">RecursiveArrayTools.jl</a> to turn the result of an ODE into a matrix.</p><p>If we plot the solution with the parameter at <code>a=1.42</code>, we get the following:</p><p><img alt="Parameter Estimation Not Fit" src="../assets/paramest_notfit.png"/></p><p>Notice that after one period this solution begins to drift very far off: this problem is sensitive to the choice of <code>a</code>.</p><p>To build the objective function for Optim.jl, we simply call the <code>build_loss_objective</code> function:</p><pre><code class="language-julia">cost_function = build_loss_objective(prob,Tsit5(),L2Loss(t,data),
                                     maxiters=10000,verbose=false)</code></pre><p>This objective function internally is calling the ODE solver to get solutions to test against the data. The keyword arguments are passed directly to the solver. Note that we set <code>maxiters</code> in a way that causes the differential equation solvers to error more quickly when in bad regions of the parameter space, speeding up the process. If the integrator stops early (due to divergence), then those parameters are given an infinite loss, and thus this is a quick way to avoid bad parameters. We set <code>verbose=false</code> because this divergence can get noisy.</p><p>Before optimizing, let's visualize our cost function by plotting it for a range of parameter values:</p><pre><code class="language-julia">range = 0.0:0.1:10.0
using Plots; plotly()
plot(range,[cost_function(i) for i in range],yscale=:log10,
     xaxis = "Parameter", yaxis = "Cost", title = "1-Parameter Cost Function",
     lw = 3)</code></pre><p><img alt="1 Parameter Likelihood" src="../assets/1paramcost.png"/></p><p>Here we see that there is a very well-defined minimum in our cost function at the real parameter (because this is where the solution almost exactly fits the dataset).</p><p>Now this cost function can be used with Optim.jl in order to get the parameters. For example, we can use Brent's algorithm to search for the best solution on the interval <code>[0,10]</code> by:</p><pre><code class="language-julia">using Optim
result = optimize(cost_function, 0.0, 10.0)</code></pre><p>This returns <code>result.minimizer[1]==1.5</code> as the best parameter to match the data. When we plot the fitted equation on the data, we receive the following:</p><p><img alt="Parameter Estimation Fit" src="../assets/paramest_fit.png"/></p><p>Thus we see that after fitting, the lines match up with the generated data and receive the right parameter value.</p><p>We can also use the multivariate optimization functions. For example, we can use the <code>BFGS</code> algorithm to optimize the parameter starting at <code>a=1.42</code> using:</p><pre><code class="language-julia">result = optimize(cost_function, [1.42], BFGS())</code></pre><p>Note that some of the algorithms may be sensitive to the initial condition. For more details on using Optim.jl, see the <a href="http://julianlsolvers.github.io/Optim.jl/latest/">documentation for Optim.jl</a>. We can improve our solution by noting that the Lotka-Volterra equation requires that the parameters are positive. Thus <a href="http://julianlsolvers.github.io/Optim.jl/latest/user/minimization/#box-minimization">following the Optim.jl documentation</a> we can add box constraints to ensure the optimizer only checks between 0.0 and 3.0 which improves the efficiency of our algorithm:</p><pre><code class="language-julia">lower = [0.0]
upper = [3.0]
result = optimize(cost_function, [1.42], lower, upper, Fminbox{BFGS}())</code></pre><p>Lastly, we can use the same tools to estimate multiple parameters simultaneously. Let's use the Lotka-Volterra equation with all parameters free:</p><pre><code class="language-julia">f2 = @ode_def_nohes LotkaVolterraAll begin
  dx = a*x - b*x*y
  dy = -c*y + d*x*y
end a b c d

u0 = [1.0;1.0]
tspan = (0.0,10.0)
p = [1.5,1.0,3.0,1.0]
prob = ODEProblem(f2,u0,tspan,p)</code></pre><p>We can build an objective function and solve the multiple parameter version just as before:</p><pre><code class="language-julia">cost_function = build_loss_objective(prob,Tsit5(),CostVData(t,data),
                                      maxiters=10000,verbose=false)
result_bfgs = Optim.optimize(cost_function, [1.3,0.8,2.8,1.2], Optim.BFGS())</code></pre><p>To solve it using LeastSquaresOptim.jl, we use the <code>build_lsoptim_objective</code> function:</p><pre><code class="language-julia">cost_function = build_lsoptim_objective(prob1,t,data,Tsit5())</code></pre><p>The result is a cost function which can be used with LeastSquaresOptim. For more details, consult the <a href="https://github.com/matthieugomez/LeastSquaresOptim.jl">documentation for LeastSquaresOptim.jl</a>:</p><pre><code class="language-julia">x = [1.3,0.8,2.8,1.2]
res = optimize!(LeastSquaresProblem(x = x, f! = cost_function,
                output_length = length(t)*length(prob.u0)),
                LeastSquaresOptim.Dogleg(),LeastSquaresOptim.LSMR())</code></pre><p>We can see the results are:</p><pre><code class="language-julia">println(res.minimizer)

Results of Optimization Algorithm
 * Algorithm: Dogleg
 * Minimizer: [1.4995074428834114,0.9996531871795851,3.001556360700904,1.0006272074128821]
 * Sum of squares at Minimum: 0.035730
 * Iterations: 63
 * Convergence: true
 * |x - x'| &lt; 1.0e-15: true
 * |f(x) - f(x')| / |f(x)| &lt; 1.0e-14: false
 * |g(x)| &lt; 1.0e-14: false
 * Function Calls: 64
 * Gradient Calls: 9
 * Multiplication Calls: 135</code></pre><p>and thus this algorithm was able to correctly identify all four parameters.</p><h3><a class="nav-anchor" href="#More-Algorithms-(Global-Optimization)-via-MathProgBase-Solvers-1" id="More-Algorithms-(Global-Optimization)-via-MathProgBase-Solvers-1">More Algorithms (Global Optimization) via MathProgBase Solvers</a></h3><p>The <code>build_loss_objective</code> function builds an objective function which is able to be used with MathProgBase-associated solvers. This includes packages like IPOPT, NLopt, MOSEK, etc. Building off of the previous example, we can build a cost function for the single parameter optimization problem like:</p><pre><code class="language-julia">f = @ode_def_nohes LotkaVolterraTest begin
  dx = a*x - x*y
  dy = -3y + x*y
end a

u0 = [1.0;1.0]
tspan = (0.0,10.0)
p = [1.5]
prob = ODEProblem(f,u0,tspan,p)
sol = solve(prob,Tsit5())

t = collect(linspace(0,10,200))
randomized = VectorOfArray([(sol(t[i]) + .01randn(2)) for i in 1:length(t)])
data = convert(Array,randomized)

obj = build_loss_objective(prob,Tsit5(),L2Loss(t,data),maxiters=10000)</code></pre><p>We can now use this <code>obj</code> as the objective function with MathProgBase solvers. For our example, we will use NLopt. To use the local derivative-free Constrained Optimization BY Linear Approximations algorithm, we can simply do:</p><pre><code class="language-julia">using NLopt
opt = Opt(:LN_COBYLA, 1)
min_objective!(opt, obj)
(minf,minx,ret) = NLopt.optimize(opt,[1.3])</code></pre><p>This finds a minimum at <code>[1.49997]</code>. For a modified evolutionary algorithm, we can use:</p><pre><code class="language-julia">opt = Opt(:GN_ESCH, 1)
min_objective!(opt, obj)
lower_bounds!(opt,[0.0])
upper_bounds!(opt,[5.0])
xtol_rel!(opt,1e-3)
maxeval!(opt, 100000)
(minf,minx,ret) = NLopt.optimize(opt,[1.3])</code></pre><p>We can even use things like the Improved Stochastic Ranking Evolution Strategy (and add constraints if needed). This is done via:</p><pre><code class="language-julia">opt = Opt(:GN_ISRES, 1)
min_objective!(opt, obj.cost_function2)
lower_bounds!(opt,[-1.0])
upper_bounds!(opt,[5.0])
xtol_rel!(opt,1e-3)
maxeval!(opt, 100000)
(minf,minx,ret) = NLopt.optimize(opt,[0.2])</code></pre><p>which is very robust to the initial condition. The fastest result comes from the following:</p><pre><code class="language-julia">using NLopt
opt = Opt(:LN_BOBYQA, 1)
min_objective!(opt, obj)
(minf,minx,ret) = NLopt.optimize(opt,[1.3])</code></pre><p>For more information, see the NLopt documentation for more details. And give IPOPT or MOSEK a try!</p><h3><a class="nav-anchor" href="#Generalized-Likelihood-Example-1" id="Generalized-Likelihood-Example-1">Generalized Likelihood Example</a></h3><p>In this example we will demo the likelihood-based approach to parameter fitting. First let's generate a dataset to fit. We will re-use the Lotka-Volterra equation but in this case fit just two parameters. Note that the parameter estimation tools do not require the use of the <code>@ode_def</code> macro, so let's demonstrate what the macro-less version looks like:</p><pre><code class="language-julia">f1 = function (du,u,p,t)
  du[1] = p[1] * u[1] - p[2] * u[1]*u[2]
  du[2] = -3.0 * u[2] + u[1]*u[2]
end
p = [1.5,1.0]
u0 = [1.0;1.0]
tspan = (0.0,10.0)
prob1 = ODEProblem(f1,u0,tspan,p)
sol = solve(prob1,Tsit5())</code></pre><p>This is a function with two parameters, <code>[1.5,1.0]</code> which generates the same ODE solution as before. This time, let's generate 100 datasets where at each point adds a little bit of randomness:</p><pre><code class="language-julia">using RecursiveArrayTools # for VectorOfArray
t = collect(linspace(0,10,200))
function generate_data(sol,t)
  randomized = VectorOfArray([(sol(t[i]) + .01randn(2)) for i in 1:length(t)])
  data = convert(Array,randomized)
end
aggregate_data = convert(Array,VectorOfArray([generate_data(sol,t) for i in 1:100]))</code></pre><p>here with <code>t</code> we measure the solution at 200 evenly spaced points. Thus <code>aggregate_data</code> is a 2x200x100 matrix where <code>aggregate_data[i,j,k]</code> is the <code>i</code>th component at time <code>j</code> of the <code>k</code>th dataset. What we first want to do is get a matrix of distributions where <code>distributions[i,j]</code> is the likelihood of component <code>i</code> at take <code>j</code>. We can do this via <code>fit_mle</code> on a chosen distributional form. For simplicity we choose the <code>Normal</code> distribution. <code>aggregate_data[i,j,:]</code> is the array of points at the given component and time, and thus we find the distribution parameters which fits best at each time point via:</p><pre><code class="language-julia">using Distributions
distributions = [fit_mle(Normal,aggregate_data[i,j,:]) for i in 1:2, j in 1:200]</code></pre><p>Notice for example that we have:</p><pre><code class="language-julia">julia&gt; distributions[1,1]
Distributions.Normal{Float64}(μ=1.0022440583676806, σ=0.009851964521952437)</code></pre><p>that is, it fit the distribution to have its mean just about where our original solution was and the variance is about how much noise we added to the dataset. This this is a good check to see that the distributions we are trying to fit our parameters to makes sense.</p><p>Note that in this case the <code>Normal</code> distribution was a good choice, and in many cases it's a nice go-to choice, but one should experiment with other choices of distributions as well. For example, a <code>TDist</code> can be an interesting way to incorporate robustness to outliers since low degrees of free T-distributions act like Normal distributions but with longer tails (though <code>fit_mle</code> does not work with a T-distribution, you can get the means/variances and build appropriate distribution objects yourself).</p><p>Once we have the matrix of distributions, we can build the objective function corresponding to that distribution fit:</p><pre><code class="language-julia">using DiffEqParamEstim
obj = build_loss_objective(prob1,Tsit5(),LogLikeLoss(t,distributions),
                                     maxiters=10000,verbose=false)</code></pre><p>First let's use the objective function to plot the likelihood landscape:</p><pre><code class="language-julia">using Plots; plotly()
range = 0.5:0.1:5.0
heatmap(range,range,[obj([j,i]) for i in range, j in range],
        yscale=:log10,xlabel="Parameter 1",ylabel="Parameter 2",
        title="Likelihood Landscape")</code></pre><p><img alt="2 Parameter Likelihood" src="../assets/2paramlike.png"/></p><p>Recall that this is the negative loglikelihood and thus the minimum is the maximum of the likelihood. There is a clear valley where the second parameter is 1.5, while the first parameter's likelihood is more muddled. By taking a one-dimensional slice:</p><pre><code class="language-julia">plot(range,[obj([i,1.0]) for i in range],lw=3,
     title="Parameter 1 Likelihood (Parameter 2 = 1.5)",
     xlabel = "Parameter 1", ylabel = "Objective Function Value")</code></pre><p><img alt="1 Parmaeter Likelihood" src="../assets/1paramlike.png"/></p><p>we can see that there's still a clear minimum at the true value. Thus we will use the global optimizers from BlackBoxOptim.jl to find the values. We set our search range to be from <code>0.5</code> to <code>5.0</code> for both of the parameters and let it optimize:</p><pre><code class="language-julia">using BlackBoxOptim
bound1 = Tuple{Float64, Float64}[(0.5, 5),(0.5, 5)]
result = bboptimize(obj;SearchRange = bound1, MaxSteps = 11e3)

Starting optimization with optimizer BlackBoxOptim.DiffEvoOpt{BlackBoxOptim.FitPopulation{Float64},B
lackBoxOptim.RadiusLimitedSelector,BlackBoxOptim.AdaptiveDiffEvoRandBin{3},BlackBoxOptim.RandomBound
{BlackBoxOptim.RangePerDimSearchSpace}}
0.00 secs, 0 evals, 0 steps
0.50 secs, 1972 evals, 1865 steps, improv/step: 0.266 (last = 0.2665), fitness=-737.311433781
1.00 secs, 3859 evals, 3753 steps, improv/step: 0.279 (last = 0.2913), fitness=-739.658421879
1.50 secs, 5904 evals, 5799 steps, improv/step: 0.280 (last = 0.2830), fitness=-739.658433715
2.00 secs, 7916 evals, 7811 steps, improv/step: 0.225 (last = 0.0646), fitness=-739.658433715
2.50 secs, 9966 evals, 9861 steps, improv/step: 0.183 (last = 0.0220), fitness=-739.658433715

Optimization stopped after 11001 steps and 2.7839999198913574 seconds
Termination reason: Max number of steps (11000) reached
Steps per second = 3951.50873439296
Function evals per second = 3989.2242527195904
Improvements/step = 0.165
Total function evaluations = 11106


Best candidate found: [1.50001, 1.00001]

Fitness: -739.658433715</code></pre><p>This shows that it found the true parameters as the best fit to the likelihood.</p><h2><a class="nav-anchor" href="#Parameter-Estimation-for-Stochastic-Differential-Equations-and-Monte-Carlo-1" id="Parameter-Estimation-for-Stochastic-Differential-Equations-and-Monte-Carlo-1">Parameter Estimation for Stochastic Differential Equations and Monte Carlo</a></h2><p>We can use any <code>DEProblem</code>, which not only includes <code>DAEProblem</code> and <code>DDEProblem</code>s, but also stochastic problems. In this case, let's use the generalized maximum likelihood to fit the parameters of an SDE's Monte Carlo evaluation.</p><p>Let's use the same Lotka-Volterra equation as before, but this time add noise:</p><pre><code class="language-julia">pf = function (du,u,p,t)
  du[1] = p[1] * u[1] - u[1]*u[2]
  du[2] = -3u[2] + u[1]*u[2]
end

u0 = [1.0;1.0]
pg = function (du,u,p,t)
  du[1] = p[2]*u[1]
  du[2] = 1e-2u[2]
end
p = [1.5,1e-2]
tspan = (0.0,10.0)
prob = SDEProblem(pf,pg,u0,tspan,p)</code></pre><p>Now lets generate a dataset from 10,000 solutions of the SDE</p><pre><code class="language-julia">using RecursiveArrayTools # for VectorOfArray
t = collect(linspace(0,10,200))
function generate_data(t)
  sol = solve(prob,SRIW1())
  randomized = VectorOfArray([(sol(t[i]) + .01randn(2)) for i in 1:length(t)])
  data = convert(Array,randomized)
end
aggregate_data = convert(Array,VectorOfArray([generate_data(t) for i in 1:10000]))</code></pre><p>Instead of using <code>UnivariateDistribution</code>s like in the previous example, lets fit our data to <code>MultivariateNormal</code> distributions.</p><pre><code class="language-julia">using Distributions
distributions = [fit_mle(MultivariateNormal,aggregate_data[:,j,:]) for j in 1:200]</code></pre><p>Now let's estimate the parameters. Instead of using single runs from the SDE, we will use a <code>MonteCarloProblem</code>. This means that it will solve the SDE <code>N</code> times to come up with an approximate probability distribution at each time point and use that in the likelihood estimate.</p><pre><code class="language-julia">monte_prob = MonteCarloProblem(prob)
obj = build_loss_objective(monte_prob,SOSRI(),LogLikeLoss(t,distributions),
                                     maxiters=10000,verbose=false,num_monte = 1000,
                                     parallel_type = :threads)</code></pre><p>To speed things up I enabled multithreading. Just as before, we hand this over to BlackBoxOptim.jl:</p><pre><code class="language-julia">using BlackBoxOptim
bound1 = Tuple{Float64, Float64}[(0.5, 3),(1e-3, 1e-1)]
result = bboptimize(obj;SearchRange = bound1, MaxSteps = 400)

Optimization stopped after 201 steps and 2713
.5920000076294 seconds
Termination reason: Max number of steps (200)
 reached
Steps per second = 0.07407156271076672
Function evals per second = 0.106869418836429
59
Improvements/step = 0.42
Total function evaluations = 290


Best candidate found: [1.52075, 0.0216393]

Fitness: 1544423.794270536</code></pre><p>Here we see that we successfully recovered the drift parameter, and got close to the original noise parameter after searching a two orders of magnitude range. It would require a larger <code>num_monte</code> to accurately get samples of the the variance and receive a better estimate there.</p><h2><a class="nav-anchor" href="#Bayesian-Inference-Examples-1" id="Bayesian-Inference-Examples-1">Bayesian Inference Examples</a></h2><h3><a class="nav-anchor" href="#Stan-1" id="Stan-1">Stan</a></h3><p>Like in the previous examples, we setup the Lotka-Volterra system and generate data:</p><pre><code class="language-julia">f1 = @ode_def LotkaVolterraTest4 begin
  dx = a*x - b*x*y
  dy = -c*y + d*x*y
end a b c d
p = [1.5,1.0,3.0,1.0]
u0 = [1.0,1.0]
tspan = (0.0,10.0)
prob1 = ODEProblem(f1,u0,tspan,p)
sol = solve(prob1,Tsit5())
t = collect(linspace(1,10,10))
randomized = VectorOfArray([(sol(t[i]) + .01randn(2)) for i in 1:length(t)])
data = convert(Array,randomized)</code></pre><p>Here we now give Stan an array of prior distributions for our parameters. Since the parameters of our differential equation must be positive, we utilize truncated Normal distributions to make sure that is satisfied in the result:</p><pre><code class="language-julia">priors = [Truncated(Normal(1.5,0.1),0,2),Truncated(Normal(1.0,0.1),0,1.5),
          Truncated(Normal(3.0,0.1),0,4),Truncated(Normal(1.0,0.1),0,2)]</code></pre><p>We then give these to the inference function.</p><pre><code class="language-julia">bayesian_result = stan_inference(prob1,t,data,priors;
                                 num_samples=100,num_warmup=500,
                                 vars = (StanODEData(),InverseGamma(4,1)))</code></pre><p><code>InverseGamma(4,1)</code> is our starting estimation for the variance hyperparameter of the default <code>Normal</code> distribution. The result is a <a href="http://mambajl.readthedocs.io/en/latest/intro.html">Mamba.jl</a> chain object. We can pull out the parameter values via:</p><pre><code class="language-julia">theta1 = bayesian_result.chain_results[:,["theta.1"],:]
theta2 = bayesian_result.chain_results[:,["theta.2"],:]
theta3 = bayesian_result.chain_results[:,["theta.3"],:]
theta4 = bayesian_result.chain_results[:,["theta.4"],:]</code></pre><p>From these chains we can get our estimate for the parameters via:</p><pre><code class="language-julia">mean(theta1.value[:,:,1])</code></pre><p>We can get more of a description via:</p><pre><code class="language-julia">Mamba.describe(bayesian_result.chain_results)

# Result

Iterations = 1:100
Thinning interval = 1
Chains = 1,2,3,4
Samples per chain = 100

Empirical Posterior Estimates:
                  Mean         SD        Naive SE        MCSE         ESS    
         lp__ -6.15472697 1.657551334 0.08287756670 0.18425029767  80.9314979
accept_stat__  0.90165904 0.125913744 0.00629568721 0.02781181930  20.4968668
   stepsize__  0.68014975 0.112183047 0.00560915237 0.06468790087   3.0075188
  treedepth__  2.68750000 0.524911975 0.02624559875 0.10711170182  24.0159141
 n_leapfrog__  6.77000000 4.121841086 0.20609205428 0.18645821695 100.0000000
  divergent__  0.00000000 0.000000000 0.00000000000 0.00000000000         NaN
     energy__  9.12245750 2.518330231 0.12591651153 0.32894488320  58.6109941
     sigma1.1  0.57164997 0.128579363 0.00642896816 0.00444242658 100.0000000
     sigma1.2  0.58981422 0.131346442 0.00656732209 0.00397310122 100.0000000
       theta1  1.50237077 0.008234095 0.00041170473 0.00025803930 100.0000000
       theta2  0.99778276 0.009752574 0.00048762870 0.00009717115 100.0000000
       theta3  3.00087782 0.009619775 0.00048098873 0.00020301023 100.0000000
       theta4  0.99803569 0.008893244 0.00044466218 0.00040886528 100.0000000
      theta.1  1.50237077 0.008234095 0.00041170473 0.00025803930 100.0000000
      theta.2  0.99778276 0.009752574 0.00048762870 0.00009717115 100.0000000
      theta.3  3.00087782 0.009619775 0.00048098873 0.00020301023 100.0000000
      theta.4  0.99803569 0.008893244 0.00044466218 0.00040886528 100.0000000

Quantiles:
                  2.5%        25.0%      50.0%      75.0%       97.5%   
         lp__ -10.11994750 -7.0569000 -5.8086150 -4.96936500 -3.81514375
accept_stat__   0.54808912  0.8624483  0.9472840  0.98695850  1.00000000
   stepsize__   0.57975100  0.5813920  0.6440120  0.74276975  0.85282400
  treedepth__   2.00000000  2.0000000  3.0000000  3.00000000  3.00000000
 n_leapfrog__   3.00000000  7.0000000  7.0000000  7.00000000 15.00000000
  divergent__   0.00000000  0.0000000  0.0000000  0.00000000  0.00000000
     energy__   5.54070300  7.2602200  8.7707000 10.74517500 14.91849500
     sigma1.1   0.38135240  0.4740865  0.5533195  0.64092575  0.89713635
     sigma1.2   0.39674703  0.4982615  0.5613655  0.66973025  0.88361407
       theta1   1.48728600  1.4967650  1.5022750  1.50805500  1.51931475
       theta2   0.97685115  0.9914630  0.9971435  1.00394250  1.01765575
       theta3   2.98354100  2.9937575  3.0001450  3.00819000  3.02065950
       theta4   0.97934128  0.9918495  0.9977415  1.00430750  1.01442975
      theta.1   1.48728600  1.4967650  1.5022750  1.50805500  1.51931475
      theta.2   0.97685115  0.9914630  0.9971435  1.00394250  1.01765575
      theta.3   2.98354100  2.9937575  3.0001450  3.00819000  3.02065950
      theta.4   0.97934128  0.9918495  0.9977415  1.00430750  1.01442975</code></pre><p>More extensive information about the distributions is given by the plots:</p><pre><code class="language-julia">plot_chain(bayesian_result)</code></pre><h3><a class="nav-anchor" href="#Turing-1" id="Turing-1">Turing</a></h3><p>This case we will build off of the Stan example. Note that <code>turing_inference</code> does not require the use of the <code>@ode_def</code> macro like Stan does, but it will still work with macro-defined functions. Thus, using the same setup as before, we simply give the setup to:</p><pre><code class="language-julia">bayesian_result = turing_inference(prob,Tsit5(),t,data,priors;num_samples=500)</code></pre><p>The chain for the <code>i</code>th parameter is then given by:</p><pre><code class="language-julia">bayesian_result[:theta1]</code></pre><p>Summary statistics can be also be accessed:</p><pre><code class="language-julia">Mamba.describe(bayesian_result)</code></pre><p>The chain can be analysed by the trace plots and other plots obtained by:</p><pre><code class="language-julia">plot_chain(bayesian_result)</code></pre><h3><a class="nav-anchor" href="#DynamicHMC-1" id="DynamicHMC-1">DynamicHMC</a></h3><p>We can use <a href="https://github.com/tpapp/DynamicHMC.jl">DynamicHMC.jl</a> as the backend for sampling with the <code>dynamic_inference</code> function. It supports any <code>DEProblem</code>,  <code>priors</code> can be passed as an array of <a href="https://juliastats.github.io/Distributions.jl/latest/">Distributions.jl</a> distributions, passing <code>initial</code> values is optional and in case where the user has a firm understanding of the  domain the parameter values will lie in, <code>tranformations</code> can be used to pass an array of constraints for the parameters as an array of <a href="https://github.com/tpapp/ContinuousTransformations.jl">Transformations</a>.</p><pre><code class="language-julia">bayesian_result_hmc = dynamichmc_inference(prob1, Tsit5(), t, data, [Normal(1.5, 1)], [bridge(ℝ, ℝ⁺, )])</code></pre><p>A tuple with summary statistics and the chain values is returned. The chain for the <code>i</code>th parameter is given by:</p><pre><code class="language-julia">bayesian_result_hmc[1][i]</code></pre><p>For accessing the various summary statistics:</p><pre><code class="language-julia">DynamicHMC.NUTS_statistics(bayesian_result_dynamic[2])</code></pre><p>Some details about the NUTS sampler can be obtained from:</p><pre><code class="language-julia">bayesian_result_dynamic[3]</code></pre><p>In case of <code>dynamic_inference</code> the trace plots for the <code>i</code>th parameter can be obtained by:</p><pre><code class="language-julia">plot(bayesian_result_hmc[1][i])</code></pre><p>For a better idea of the summary statistics and plotting you can take a look at the benchmark <a href="https://github.com/JuliaDiffEq/DiffEqBenchmarks.jl/tree/master/ParameterEstimation">notebooks</a></p><footer><hr/><a class="previous" href="parameterized_functions.html"><span class="direction">Previous</span><span class="title">ParameterizedFunctions</span></a><a class="next" href="bifurcation.html"><span class="direction">Next</span><span class="title">Bifurcation Analysis</span></a></footer></article></body></HTML>