<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>SDE Solvers · DifferentialEquations.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-90474609-3', 'auto');
ga('send', 'pageview');
</script><link href="https://docs.juliadiffeq.org/stable/solvers/sde_solve/index.html" rel="canonical"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script data-main="../../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><script data-is-old-version="">document.addEventListener("DOMContentLoaded", function(){
    const div = document.createElement('div');
    div.setAttribute('style', 'position: fixed; bottom: 1em; right: 1em; z-index: 999; background-color: #ffaf9c; color: rgba(0, 0, 0, 0.7); border: 1px solid #d54625; border-radius: 4px; padding: 2em; text-align: center');
    const closer = document.createElement('div');
    closer.setAttribute('style', 'position: absolute; top: 0; right: 5px; padding: 5px; cursor: pointer; width: 12px; height: 12px;')
    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', () => {
        document.body.removeChild(div)
    })
    const href = documenterBaseURL + '/../stable'
    div.innerHTML = 'This is an old version of the documentation. <br> Click <a href="' + href + '">here</a> to go to the newest version.';
    div.appendChild(closer)
    document.body.appendChild(div);
});
</script></head><body><nav class="toc"><a href="../../"><img alt="DifferentialEquations.jl logo" class="logo" src="../../assets/logo.png"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../../search/" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../../tutorials/ode_example/">Ordinary Differential Equations</a></li><li><a class="toctext" href="../../tutorials/advanced_ode_example/">Solving Stiff Equations</a></li><li><a class="toctext" href="../../tutorials/sde_example/">Stochastic Differential Equations</a></li><li><a class="toctext" href="../../tutorials/rode_example/">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../../tutorials/dde_example/">Delay Differential Equations</a></li><li><a class="toctext" href="../../tutorials/dae_example/">Differential Algebraic Equations</a></li><li><a class="toctext" href="../../tutorials/discrete_stochastic_example/">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="toctext" href="../../tutorials/bvp_example/">Boundary Value Problems</a></li><li><a class="toctext" href="../../tutorials/additional/">Additional Tutorials</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../../basics/common_solver_opts/">Common Solver Options</a></li><li><a class="toctext" href="../../basics/solution/">Solution Handling</a></li><li><a class="toctext" href="../../basics/plot/">Plot Functions</a></li><li><a class="toctext" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="toctext" href="../../basics/problem/">Problem Interface</a></li><li><a class="toctext" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="toctext" href="../../types/ode_types/">ODE Problems</a></li><li><a class="toctext" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="toctext" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="toctext" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="toctext" href="../../types/sde_types/">SDE Problems</a></li><li><a class="toctext" href="../../types/rode_types/">RODE Problems</a></li><li><a class="toctext" href="../../types/dde_types/">DDE Problems</a></li><li><a class="toctext" href="../../types/dae_types/">DAE Problems</a></li><li><a class="toctext" href="../../types/jump_types/">Jump Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../discrete_solve/">Discrete Solvers</a></li><li><a class="toctext" href="../ode_solve/">ODE Solvers</a></li><li><a class="toctext" href="../dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="../split_ode_solve/">Split ODE Solvers</a></li><li><a class="toctext" href="../steady_state_solve/">Steady State Solvers</a></li><li><a class="toctext" href="../bvp_solve/">BVP Solvers</a></li><li><a class="toctext" href="../jump_solve/">Jump Problem Solvers</a></li><li class="current"><a class="toctext" href="">SDE Solvers</a><ul class="internal"><li><a class="toctext" href="#Recommended-Methods-1">Recommended Methods</a></li><li><a class="toctext" href="#Mass-Matrices-and-Stochastic-DAEs-1">Mass Matrices and Stochastic DAEs</a></li><li><a class="toctext" href="#Special-Noise-Forms-1">Special Noise Forms</a></li><li><a class="toctext" href="#Special-Keyword-Arguments-1">Special Keyword Arguments</a></li><li><a class="toctext" href="#Full-List-of-Methods-1">Full List of Methods</a></li></ul></li><li><a class="toctext" href="../rode_solve/">RODE Solvers</a></li><li><a class="toctext" href="../dde_solve/">DDE Solvers</a></li><li><a class="toctext" href="../dae_solve/">DAE Solvers</a></li><li><a class="toctext" href="../benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="../../features/performance_overloads/">DiffEqFunctions (Jacobians, Gradients, etc.) and Jacobian Types</a></li><li><a class="toctext" href="../../features/diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="../../features/diffeq_operator/">DiffEqOperators</a></li><li><a class="toctext" href="../../features/noise_process/">Noise Processes</a></li><li><a class="toctext" href="../../features/linear_nonlinear/">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="../../features/callback_functions/">Event Handling and Callback Functions</a></li><li><a class="toctext" href="../../features/callback_library/">Callback Library</a></li><li><a class="toctext" href="../../features/ensemble/">Parallel Ensemble Simulations</a></li><li><a class="toctext" href="../../features/io/">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="../../features/low_dep/">Low Dependency Usage</a></li><li><a class="toctext" href="../../features/progress_bar/">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../../analysis/parameterized_functions/">ParameterizedFunctions</a></li><li><a class="toctext" href="../../analysis/parameter_estimation/">Parameter Estimation and Bayesian Analysis</a></li><li><a class="toctext" href="../../analysis/bifurcation/">Bifurcation Analysis</a></li><li><a class="toctext" href="../../analysis/sensitivity/">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li><a class="toctext" href="../../analysis/global_sensitivity/">Global Sensitivity Analysis</a></li><li><a class="toctext" href="../../analysis/uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="toctext" href="../../analysis/neural_networks/">Neural Networks</a></li><li><a class="toctext" href="../../analysis/dev_and_test/">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../../models/multiscale/">Multi-Scale Models</a></li><li><a class="toctext" href="../../models/physical/">Physical Models</a></li><li><a class="toctext" href="../../models/financial/">Financial Models</a></li><li><a class="toctext" href="../../models/biological/">Chemical Reaction Models</a></li><li><a class="toctext" href="../../models/external_modeling/">External Modeling Packages</a></li></ul></li><li><span class="toctext">APIs</span><ul><li><span class="toctext">DiffEqBase API</span><ul><li><a class="toctext" href="../../apis/diffeqbase/overview/">Overview</a></li><li><a class="toctext" href="../../apis/diffeqbase/functions/">DE functions</a></li><li><a class="toctext" href="../../apis/diffeqbase/problems/">Problems</a></li><li><a class="toctext" href="../../apis/diffeqbase/solutions/">Solutions</a></li><li><a class="toctext" href="../../apis/diffeqbase/solvers/">Solvers</a></li><li><a class="toctext" href="../../apis/diffeqbase/de_types/">DE types</a></li><li><a class="toctext" href="../../apis/diffeqbase/operators/">Operators</a></li><li><a class="toctext" href="../../apis/diffeqbase/callbacks/">Callbacks</a></li><li><a class="toctext" href="../../apis/diffeqbase/interpolation/">Interpolation</a></li><li><a class="toctext" href="../../apis/diffeqbase/ensembles/">Ensembles</a></li><li><a class="toctext" href="../../apis/diffeqbase/data_arrays/">Data arrays</a></li><li><a class="toctext" href="../../apis/diffeqbase/noise/">Noise processes</a></li><li><a class="toctext" href="../../apis/diffeqbase/utility/">Utility</a></li></ul></li><li><a class="toctext" href="../../apis/diffeqbio/">DiffEqBiological.jl API</a></li></ul></li><li><span class="toctext">Extra Details</span><ul><li><a class="toctext" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver Algorithms</li><li><a href="">SDE Solvers</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/blob/master/docs/src/solvers/sde_solve.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>SDE Solvers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#SDE-Solvers-1" id="SDE-Solvers-1">SDE Solvers</a></h1><h2><a class="nav-anchor" href="#Recommended-Methods-1" id="Recommended-Methods-1">Recommended Methods</a></h2><p>For most Ito diagonal and scalar noise problems where a good amount of accuracy is required and mild stiffness may be an issue, the <code>SOSRI</code> algorithm should do well. If the problem has additive noise, then <code>SOSRA</code> will be the optimal algorithm. At low tolerances (<code>&lt;1e-4</code>?) <code>SRA3</code> will be more efficient, though <code>SOSRA</code> is more robust to stiffness. For commutative noise, <code>RKMilCommute</code> is a strong order 1.0 method which utilizes the commutivity property to greatly speed up the Wiktorsson approximation and can choose between Ito and Stratonovich. For non-commutative noise, difficult problems usually require adaptive time stepping in order to be efficient. In this case, <code>LambaEM</code> and <code>LambaEulerHeun</code> are adaptive and handle general non-diagonal problems (for Ito and Stratonovich interpretations respectively). If adaptivity isn't necessary, the <code>EM</code> and <code>EulerHeun</code> are good choices (for Ito and Stratonovich interpretations respectively).</p><p>For stiff problems with additive noise, the high order adaptive method <code>SKenCarp</code> is highly preferred and will solve problems with similar efficiency as ODEs. If possible, stiff problems should be converted to make use of this additive noise solver. If the noise term is large/stiff, then the split-step methods are required in order for the implicit methods to be stable. For Ito in this case, use <code>ISSEM</code> and for Stratonovich use <code>ISSEulerHeun</code>. These two methods can handle any noise form.</p><p>If the noise term is not too large, for stiff problems with diagonal noise, <code>ImplicitRKMil</code> is the most efficient method and can choose between Ito and Stratonovich. For each of the theta methods, the parameter <code>theta</code> can be chosen. The default is <code>theta=1/2</code> which will not dampen numerical oscillations and thus is symmetric (and almost symplectic) and will lead to less error when noise is sufficiently small. However, <code>theta=1/2</code> is not L-stable in the drift term, and thus one can receive more stability (L-stability in the drift term) with <code>theta=1</code>, but with a tradeoff of error efficiency in the low noise case. In addition, the option <code>symplectic=true</code> will turns these methods into an implicit Midpoint extension which is symplectic in distribution but has an accuracy tradeoff.</p><h2><a class="nav-anchor" href="#Mass-Matrices-and-Stochastic-DAEs-1" id="Mass-Matrices-and-Stochastic-DAEs-1">Mass Matrices and Stochastic DAEs</a></h2><p>The stiff methods can solve stochastic equations with mass matrices (including stochastic DAEs written in mass matrix form) when either <code>symplectic=true</code> or <code>theta=1</code>. These methods interpret the mass matrix equation as:</p><div>\[Mu' = f(t,u)dt + Mg(t,u)dW_t\]</div><p>i.e. with no mass matrix inversion applied to the <code>g</code> term. Thus these methods apply noise per dependent variable instead of on the combinations of the dependent variables and this is designed for phenomenological noise on the dependent variables (like multiplicative or additive noise)</p><h2><a class="nav-anchor" href="#Special-Noise-Forms-1" id="Special-Noise-Forms-1">Special Noise Forms</a></h2><p>Some solvers are for specialized forms of noise. Diagonal noise is the default setup. Non-diagonal noise is specified via setting <code>noise_rate_prototype</code> to a matrix in the <code>SDEProblem</code> type. A special form of non-diagonal noise, commutative noise, occurs when the noise satisfies the following condition:</p><div>\[\sum_{i=1}^d g_{i,j_1}(t,x) \frac{\partial g_{k,j_2}(t,x)}{\partial x_i} = \sum_{i=1}^d g_{i,j_2}(t,x) \frac{\partial g_{k,j_1}(t,x)}{\partial x_i}\]</div><p>for every <span>$j_1,j_2$</span> and <span>$k$</span>. Additive noise is when <span>$g(t,u)=g(t)$</span>, i.e. is independent of <code>u</code>. Multiplicative noise is <span>$g_i(t,u)=a_i u$</span>.</p><h2><a class="nav-anchor" href="#Special-Keyword-Arguments-1" id="Special-Keyword-Arguments-1">Special Keyword Arguments</a></h2><ul><li><code>save_noise</code>: Determines whether the values of <code>W</code> are saved whenever the timeseries is saved. Defaults to true.</li><li><code>delta</code>: The <code>delta</code> adaptivity parameter for the natural error estimator. Determines the balance between drift and diffusion error. For more details, see <a href="http://chrisrackauckas.com/assets/Papers/ChrisRackauckas-AdaptiveSRK.pdf">the publication</a>.</li><li><code>seed</code>: Sets the seed for the random number generator. This overrides any seed set in the <code>SDEProblem</code>.</li></ul><h2><a class="nav-anchor" href="#Full-List-of-Methods-1" id="Full-List-of-Methods-1">Full List of Methods</a></h2><h3><a class="nav-anchor" href="#StochasticDiffEq.jl-1" id="StochasticDiffEq.jl-1">StochasticDiffEq.jl</a></h3><p>Each of the StochasticDiffEq.jl solvers come with a linear interpolation. Orders are given in terms of strong order.</p><h4><a class="nav-anchor" href="#Nonstiff-Methods-1" id="Nonstiff-Methods-1">Nonstiff Methods</a></h4><ul><li><code>EM</code>- The Euler-Maruyama method. Strong Order 0.5 in the Ito sense. Has an optional argument <code>split=true</code> for controlling step splitting. When splitting is enabled, the stability with large diffusion eigenvalues is improved. Can handle all forms of noise, including non-diagonal, scalar, and colored noise. Fixed time step only.†</li><li><code>LambaEM</code>- A modified Euler-Maruyama method with adaptive time stepping with an error estimator based on Lamba and Rackauckas. Has an optional argument <code>split=true</code> for controlling step splitting. When splitting is enabled, the stability with   large diffusion eigenvalues is improved. Strong Order 0.5 in the Ito sense. Can handle all forms of noise, including non-diagonal, scalar, and colored noise.†</li><li><code>EulerHeun</code> - The Euler-Heun method. Strong Order 0.5 in the Stratonovich sense. Can handle all forms of noise, including non-diagonal, scalar, and colored noise. Fixed time step only.†</li><li><code>LambaEulerHeun</code> - A modified Euler-Heun method with adaptive time stepping with an error estimator based on Lamba due to Rackauckas. Strong order 0.5 in the Stratonovich sense. Can handle all forms of noise, including non-diagonal, scalar, and colored noise.†</li><li><code>RKMil</code> - An explicit Runge-Kutta discretization of the strong order 1.0 Milstein method. Defaults to solving the Ito problem, but <code>RKMil(interpretation=:Stratonovich)</code> makes it solve the Stratonovich problem. Only handles scalar and diagonal noise.†</li><li><code>RKMilCommute</code> - An explicit Runge-Kutta discretization of the strong order 1.0 Milstein method for commutative noise problems. Defaults to solving the Ito problem, but <code>RKMilCommute(interpretation=:Stratonovich)</code> makes it solve the Stratonovich problem. Uses a 1.5/2.0 error estimate for adaptive time stepping.†</li><li><code>WangLi3SMil_A</code> - fixed step-size explicit 3-stage Milstein methods for Ito problem with strong and weak order 1.0</li><li><code>WangLi3SMil_B</code> - fixed step-size explicit 3-stage Milstein methods for Ito problem with strong and weak order 1.0</li><li><code>WangLi3SMil_C</code> - fixed step-size explicit 3-stage Milstein methods for Ito problem with strong and weak order 1.0</li><li><code>WangLi3SMil_D</code> - fixed step-size explicit 3-stage Milstein methods for Ito problem with strong and weak order 1.0</li><li><code>WangLi3SMil_E</code> - fixed step-size explicit 3-stage Milstein methods for Ito problem with strong and weak order 1.0</li><li><code>WangLi3SMil_F</code> - fixed step-size explicit 3-stage Milstein methods for Ito problem with strong and weak order 1.0</li><li><code>SRA</code> - Adaptive strong order 1.5 methods for additive Ito and Stratonovich SDEs. Default tableau is for SRA1. Can handle diagonal, non-diagonal and scalar additive noise.</li><li><code>SRI</code> - Adaptive strong order 1.5 methods for diagonal/scalar Ito SDEs. Default tableau is for SRIW1.</li><li><code>SRIW1</code> - Adaptive strong order 1.5 and weak order 2.0 for diagonal/scalar Ito SDEs.†</li><li><code>SRIW2</code> - Adaptive strong order 1.5 and weak order 3.0 for diagonal/scalar Ito SDEs.†</li><li><code>SOSRI</code> - Stability-optimized adaptive strong order 1.5 and weak order 2.0 for diagonal/scalar Ito SDEs. Stable at high tolerances and robust to stiffness.†</li><li><code>SOSRI2</code> - Stability-optimized adaptive strong order 1.5 and weak order 2.0 for diagonal/scalar Ito SDEs. Stable at high tolerances and robust to stiffness.†</li><li><code>SRA1</code> - Adaptive strong order 1.5 for additive Ito and Stratonovich SDEs with weak order 2. Can handle diagonal, non-diagonal, and scalar additive noise.†</li><li><code>SRA2</code> - Adaptive strong order 1.5 for additive Ito and Stratonovich SDEs with weak order 2. Can handle diagonal, non-diagonal, and scalar additive noise.†</li><li><code>SRA3</code> - Adaptive strong order 1.5 for additive Ito and Stratonovich SDEs with weak order 3. Can handle non-diagonal and scalar additive noise.†</li><li><code>SOSRA</code> - A stability-optimized adaptive SRA. Strong order 1.5 for additive Ito and Stratonovich SDEs with weak order 2. Can handle diagonal, non-diagonal, and scalar additive noise. Stable at high tolerances and robust to stiffness.†</li><li><code>SOSRA2</code> - A stability-optimized adaptive SRA. Strong order 1.5 for additive Ito and Stratonovich SDEs with weak order 2. Can handle diagonal, non-diagonal, and scalar additive noise. Stable at high tolerances and robust to stiffness.†</li></ul><p>Example usage:</p><pre><code class="language-julia">sol = solve(prob,SRIW1())</code></pre><p>3-stage Milstein Methods <code>WangLi3SMil_A</code>, <code>WangLi3SMil_B</code>, <code>WangLi3SMil_D</code>, <code>WangLi3SMil_E</code> and <code>WangLi3SMil_F</code> are currently implemented for 1-dimensional and diagonal noise only.</p><h4><a class="nav-anchor" href="#Tableau-Controls-1" id="Tableau-Controls-1">Tableau Controls</a></h4><p>For <code>SRA</code> and <code>SRI</code>, the following option is allowed:</p><ul><li><code>tableau</code>: The tableau for an <code>:SRA</code> or <code>:SRI</code> algorithm. Defaults to SRIW1 or SRA1.</li></ul><h4><a class="nav-anchor" href="#S-ROCK-Methods-1" id="S-ROCK-Methods-1">S-ROCK Methods</a></h4><ul><li><code>SROCK1</code> - is a fixed step size stabilized explicit method for stiff problems. Defaults to solving th Ito problem but <code>SROCK1(interpretation=:Stratonovich)</code> can make it solve the Stratonovich problem. Strong order of convergence is 0.5 and weak order 1, but is optimised to get order 1 in case os scalar/diagonal noise.</li><li><code>SROCKEM</code> - is fixed step Euler-Mayurama with first order ROCK stabilization thus can handle stiff problems. Only for Ito problems. Defaults to strong and weak order 1.0, but can solve with weak order 0.5 as <code>SROCKEM(strong_order_1=false)</code>. This method can handle 1-dimensional, diagonal and multi-dimensional noise.</li><li><code>SROCK2</code> - is a weak second order and strong first order fixed step stabilized method for stiff Ito problems.This method can handle 1-dimensional, diagonal and multi-dimensional noise.</li><li><code>SKSROCK</code> - is fixed step stabilized explicit method for stiff Ito problems. Strong order 0.5 and weak order 1. This method has a better stability domain then <code>SROCK1</code>. Also it allows special post-processing techniques in case of ergodic dynamical systems, in the context of ergodic Brownian dynamics, to achieve order 2 accuracy. <code>SKSROCK(;post_processing=true)</code> will make use of post processing. By default it doesn't use post processing. Post processing is optional and under development. The rest of the method is completely functional and can handle 1-dimensional, diagonal and multi-dimensional noise.  </li><li><code>TangXiaoSROCK2</code> - is a fixed step size stabilized expicit method for stiff problems. Only for Ito problems. Weak order of 2 and strog order of 1. Has 5 versions with different stability domains which can be used as <code>TangXiaoSROCK2(version_num=i)</code> where <code>i</code> is 1-5. Under Development.</li></ul><h4><a class="nav-anchor" href="#Stiff-Methods-1" id="Stiff-Methods-1">Stiff Methods</a></h4><ul><li><code>ImplicitEM</code> - An order 0.5 Ito drift-implicit method. This is a theta method which defaults to <code>theta=1/2</code> or the Trapezoid method on the drift term. This method defaults to <code>symplectic=false</code>, but when true and <code>theta=1/2</code> this is the implicit Midpoint method on the drift term and is symplectic in distribution. Can handle all forms of noise, including non-diagonal, scalar, and colored noise. Uses a 1.0/1.5 heuristic for adaptive time stepping.</li><li><code>ImplicitEulerHeun</code> - An order 0.5 Stratonovich drift-implicit method. This is a theta method which defaults to <code>theta=1/2</code> or the Trapezoid method on the drift term. This method defaults to <code>symplectic=false</code>, but when true and <code>theta=1/2</code> this is the implicit Midpoint method on the drift term and is symplectic in distribution. Can handle all forms of noise, including non-diagonal, scalar, and colored noise. Uses a 1.0/1.5 heuristic for adaptive time stepping.</li><li><code>ImplicitRKMil</code> - An order 1.0 drift-implicit method. This is a theta method which defaults to <code>theta=1/2</code> or the Trapezoid method on the drift term. Defaults to solving the Ito problem, but <code>ImplicitRKMil(interpretation=:Stratonovich)</code> makes it solve the Stratonovich problem. This method defaults to <code>symplectic=false</code>, but when true and <code>theta=1/2</code> this is the implicit Midpoint method on the drift term and is symplectic in distribution. Handles diagonal and scalar noise. Uses a 1.5/2.0 heuristic for adaptive time stepping.</li><li><code>ISSEM</code> - An order 0.5 split-step Ito implicit method. It is fully implicit, meaning it can handle stiffness in the noise term. This is a theta method which defaults to <code>theta=1</code> or the Trapezoid method on the drift term. This method defaults to <code>symplectic=false</code>, but when true and <code>theta=1/2</code> this is the implicit Midpoint method on the drift term and is symplectic in distribution. Can handle all forms of noise, including non-diagonal, scalar, and colored noise. Uses a 1.0/1.5 heuristic for adaptive time stepping.</li><li><code>ISSEulerHeun</code> - An order 0.5 split-step Stratonovich implicit method. It is fully implicit, meaning it can handle stiffness in the noise term. This is a theta method which defaults to <code>theta=1</code> or the Trapezoid method on the drift term. This method defaults to <code>symplectic=false</code>, but when true and <code>theta=1/2</code> this is the implicit Midpoint method on the drift term and is symplectic in distribution. Can handle all forms of noise, including non-diagonal,Q scalar, and colored noise. Uses a 1.0/1.5 heuristic for adaptive time stepping.</li><li><code>SKenCarp</code> - Adaptive L-stable drfit-implicit strong order 1.5 for additive Ito and Stratonovich SDEs with weak order 2. Can handle diagonal, non-diagonal and scalar additive noise.*†</li></ul><h4><a class="nav-anchor" href="#Derivative-Based-Methods-1" id="Derivative-Based-Methods-1">Derivative-Based Methods</a></h4><p>The following methods require analytic derivatives of the diffusion term.</p><ul><li><p><code>PCEuler</code> - The predictor corrector euler method. Strong Order 0.5 in the Ito sense. Requires the ggprime function, which is defined as</p><div>\[  \text{ggprime}^k(t,x) = \sum_{j=1}^m \sum_{i=1}^d g_{i,j}(t,x) \frac{\partial g_{k,j}(t,x)}{\partial x_i}.\]</div><p>This can also be understood more intuitively in vector/matrix form as,</p><div>\[\text{ggprime}(t,x) = \sum_{j=1}^m \bar{\mathcal{J}}[\vec g^{(j)}(t,x)] \vec g^{(j)}(t,x).\]</div><p>where <span>$\vec g^{(j)}$</span> is the noise vector for the j'th noise channel and <span>$\bar{\mathcal{J}}$</span> is the Jacobian of the j'th   noise vector.</p><p>The default settings for the drift implicitness is <code>theta=0.5</code> and the diffusion implicitness is <code>eta=0.5</code>.  </p></li></ul><h3><a class="nav-anchor" href="#StochasticCompositeAlgorithm-1" id="StochasticCompositeAlgorithm-1">StochasticCompositeAlgorithm</a></h3><p>One unique feature of StochasticDiffEq.jl is the <code>StochasticCompositeAlgorithm</code>, which allows you to, with very minimal overhead, design a multimethod which switches between chosen algorithms as needed. The syntax is <code>StochasticCompositeAlgorithm(algtup,choice_function)</code> where <code>algtup</code> is a tuple of StochasticDiffEq.jl algorithms, and <code>choice_function</code> is a function which declares which method to use in the following step. For example, we can design a multimethod which uses <code>EM()</code> but switches to <code>RKMil()</code> whenever <code>dt</code> is too small:</p><pre><code class="language-julia">choice_function(integrator) = (Int(integrator.dt&lt;0.001) + 1)
alg_switch = StochasticCompositeAlgorithm((EM(),RKMil()),choice_function)</code></pre><p>The <code>choice_function</code> takes in an <code>integrator</code> and thus all of the features available in the <a href="../../basics/integrator/#Integrator-Interface-1">Integrator Interface</a> can be used in the choice function.</p><h3><a class="nav-anchor" href="#SimpleDiffEq.jl-1" id="SimpleDiffEq.jl-1">SimpleDiffEq.jl</a></h3><p>This setup provides access to simplified versions of a few SDE solvers. They mostly exist for experimentation, but offer shorter compile times. They have limitations compared to StochasticDiffEq.jl.</p><ul><li><code>SimpleEM</code> - A fixed timestep solve method for Euler-Maruyama. Only works with non-colored Gaussian noise.</li></ul><p>Note that this setup is not automatically included with DifferentialEquaitons.jl. To use the following algorithms, you must install and use SimpleDiffEq.jl:</p><pre><code class="language-julia">]add SimpleDiffEq
using SimpleDiffEq</code></pre><h3><a class="nav-anchor" href="#BridgeDiffEq.jl-1" id="BridgeDiffEq.jl-1">BridgeDiffEq.jl</a></h3><p>Bridge.jl is a set of fixed timestep algorithms written in Julia. These methods are made and optimized for out-of-place functions on immutable (static vector) types. Note that this setup is not automatically included with DifferentialEquaitons.jl. To use the following algorithms, you must install and use BridgeDiffEq.jl:</p><pre><code class="language-julia">Pkg.clone("https://github.com/JuliaDiffEq/BridgeDiffEq.jl")
using BridgeDiffEq</code></pre><ul><li><code>BridgeEuler</code> - Strong order 0.5 Euler-Maruyama method for Ito equations.†</li><li><code>BridgeHeun</code> - Strong order 0.5 Euler-Heun method for Stratonovich equations.†</li><li><code>BridgeSRK</code> - Strong order 1.0 derivative-free stochastic Runge-Kutta method for scalar (<code>&lt;:Number</code>) Ito equations.†</li></ul><h5><a class="nav-anchor" href="#Notes-1" id="Notes-1">Notes</a></h5><p>†: Does not step to the interval endpoint. This can cause issues with discontinuity detection, and <a href="../../features/diffeq_arrays">discrete variables need to be updated appropriately</a>.</p><p>*:  Note that although <code>SKenCarp</code> uses the same table as <code>KenCarp3</code>, solving a ODE problem using <code>SKenCarp</code> by setting <code>g(du,u,p,t) = du .= 0</code> will take much more steps than <code>KenCarp3</code> because error estimator of <code>SKenCarp</code> is different (because of noise terms) and default value of <code>qmax</code> (maximum permissible ratio of relaxing/tightening <code>dt</code> for adaptive steps) is smaller for StochasticDiffEq algorithms.</p><footer><hr/><a class="previous" href="../jump_solve/"><span class="direction">Previous</span><span class="title">Jump Problem Solvers</span></a><a class="next" href="../rode_solve/"><span class="direction">Next</span><span class="title">RODE Solvers</span></a></footer></article></body></HTML>