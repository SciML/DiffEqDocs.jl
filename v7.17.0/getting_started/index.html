<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started with Differential Equations in Julia · DifferentialEquations.jl</title><meta name="title" content="Getting Started with Differential Equations in Julia · DifferentialEquations.jl"/><meta property="og:title" content="Getting Started with Differential Equations in Julia · DifferentialEquations.jl"/><meta property="twitter:title" content="Getting Started with Differential Equations in Julia · DifferentialEquations.jl"/><meta name="description" content="Documentation for DifferentialEquations.jl."/><meta property="og:description" content="Documentation for DifferentialEquations.jl."/><meta property="twitter:description" content="Documentation for DifferentialEquations.jl."/><meta property="og:url" content="https://docs.sciml.ai/DiffEqDocs/stable/getting_started/"/><meta property="twitter:url" content="https://docs.sciml.ai/DiffEqDocs/stable/getting_started/"/><link rel="canonical" href="https://docs.sciml.ai/DiffEqDocs/stable/getting_started/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">DifferentialEquations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">DifferentialEquations.jl: Efficient Differential Equation Solving in Julia</a></li><li class="is-active"><a class="tocitem" href>Getting Started with Differential Equations in Julia</a><ul class="internal"><li><a class="tocitem" href="#Example-1-:-Solving-Scalar-Equations"><span>Example 1 : Solving Scalar Equations</span></a></li><li><a class="tocitem" href="#Example-2:-Solving-Systems-of-Equations"><span>Example 2: Solving Systems of Equations</span></a></li><li><a class="tocitem" href="#Defining-Parameterized-Functions"><span>Defining Parameterized Functions</span></a></li><li><a class="tocitem" href="#Example-3:-Solving-Nonhomogeneous-Equations-using-Parameterized-Functions"><span>Example 3: Solving Nonhomogeneous Equations using Parameterized Functions</span></a></li><li><a class="tocitem" href="#ode_other_types"><span>Example 4: Using Other Types for Systems of Equations</span></a></li><li><a class="tocitem" href="#Going-Beyond-ODEs:-How-to-Use-the-Documentation"><span>Going Beyond ODEs: How to Use the Documentation</span></a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/faster_ode_example/">Code Optimization for Differential Equations</a></li><li><a class="tocitem" href="../tutorials/advanced_ode_example/">Solving Large Stiff Equations</a></li><li><a class="tocitem" href="../tutorials/sde_example/">Stochastic Differential Equations</a></li><li><a class="tocitem" href="../tutorials/rode_example/">Random Ordinary Differential Equations</a></li><li><a class="tocitem" href="../tutorials/dde_example/">Delay Differential Equations</a></li><li><a class="tocitem" href="../tutorials/dae_example/">Differential Algebraic Equations</a></li><li><a class="tocitem" href="../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="tocitem" href="../tutorials/bvp_example/">Boundary Value Problems</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Beginner</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/classical_physics/">Classical Physics Models</a></li><li><a class="tocitem" href="../examples/conditional_dosing/">Conditional Dosing in Pharmacometrics</a></li><li><a class="tocitem" href="../examples/kepler_problem/">The Kepler Problem</a></li><li><a class="tocitem" href="../examples/outer_solar_system/">Simulating the Outer Solar System</a></li><li><a class="tocitem" href="../examples/min_and_max/">Finding Maxima and Minima of ODEs Solutions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Advanced</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/spiking_neural_systems/">Spiking Neural Systems</a></li><li><a class="tocitem" href="../examples/beeler_reuter/">An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model</a></li><li><a class="tocitem" href="../examples/diffusion_implicit_heat_equation/">Solving the heat equation with diffusion-implicit time-stepping</a></li></ul></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="tocitem" href="../basics/common_solver_opts/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../basics/solution/">Solution Handling</a></li><li><a class="tocitem" href="../basics/plot/">Plot Functions</a></li><li><a class="tocitem" href="../basics/integrator/">Integrator Interface</a></li><li><a class="tocitem" href="../basics/problem/">Problem Interface</a></li><li><a class="tocitem" href="../basics/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="tocitem">Problem Types</span><ul><li><a class="tocitem" href="../types/discrete_types/">Discrete Problems</a></li><li><a class="tocitem" href="../types/ode_types/">ODE Problems</a></li><li><a class="tocitem" href="../types/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group Problems</a></li><li><a class="tocitem" href="../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="tocitem" href="../types/split_ode_types/">Split ODE Problems</a></li><li><a class="tocitem" href="../types/steady_state_types/">Steady State Problems</a></li><li><a class="tocitem" href="../types/bvp_types/">BVP Problems</a></li><li><a class="tocitem" href="../types/sde_types/">SDE Problems</a></li><li><a class="tocitem" href="../types/sdae_types/">SDAE Problems</a></li><li><a class="tocitem" href="../types/rode_types/">RODE Problems</a></li><li><a class="tocitem" href="../types/dde_types/">DDE Problems</a></li><li><a class="tocitem" href="../types/sdde_types/">SDDE Problems</a></li><li><a class="tocitem" href="../types/dae_types/">DAE Problems</a></li></ul></li><li><span class="tocitem">Solver Algorithms</span><ul><li><a class="tocitem" href="../solvers/discrete_solve/">Discrete Solvers</a></li><li><a class="tocitem" href="../solvers/ode_solve/">ODE Solvers</a></li><li><a class="tocitem" href="../solvers/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group ODE Solvers</a></li><li><a class="tocitem" href="../solvers/dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="tocitem" href="../solvers/split_ode_solve/">Split ODE Solvers</a></li><li><a class="tocitem" href="../solvers/steady_state_solve/">Steady State Solvers</a></li><li><a class="tocitem" href="../solvers/bvp_solve/">BVP Solvers</a></li><li><a class="tocitem" href="../solvers/sde_solve/">SDE Solvers</a></li><li><a class="tocitem" href="../solvers/sdae_solve/">SDAE Solvers</a></li><li><a class="tocitem" href="../solvers/rode_solve/">RODE Solvers</a></li><li><a class="tocitem" href="../solvers/dde_solve/">DDE Solvers</a></li><li><a class="tocitem" href="../solvers/sdde_solve/">SDDE Solvers</a></li><li><a class="tocitem" href="../solvers/dae_solve/">Mass Matrix and Fully Implicit DAE Solvers</a></li><li><a class="tocitem" href="../solvers/benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="tocitem">Additional Features</span><ul><li><a class="tocitem" href="../features/performance_overloads/">Jacobians, Gradients, etc.</a></li><li><a class="tocitem" href="../features/diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="tocitem" href="../features/diffeq_operator/">Matrix-Free Linear Operators with SciMLOperators.jl</a></li><li><a class="tocitem" href="../features/noise_process/">Noise Processes</a></li><li><a class="tocitem" href="../features/linear_nonlinear/">Specifying (Non)Linear Solvers and Preconditioners</a></li><li><a class="tocitem" href="../features/callback_functions/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../features/callback_library/">Callback Library</a></li><li><a class="tocitem" href="../features/ensemble/">Parallel Ensemble Simulations</a></li><li><a class="tocitem" href="../features/io/">I/O: Saving and Loading Solution Data</a></li><li><a class="tocitem" href="../features/low_dep/">Reduced Compile Time, Optimizing Runtime, and Low Dependency Usage</a></li><li><a class="tocitem" href="../features/progress_bar/">Progress Bar Integration</a></li></ul></li><li><span class="tocitem">External Solver APIs</span><ul><li><a class="tocitem" href="../api/sundials/">Sundials.jl</a></li><li><a class="tocitem" href="../api/daskr/">DASKR.jl</a></li></ul></li><li><span class="tocitem">OrdinaryDiffEq.jl API</span><ul><li><a class="tocitem" href="../api/ordinarydiffeq/">OrdinaryDiffEq.jl: ODE solvers and utilities</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/usage/">Usage</a></li><li><input class="collapse-toggle" id="menuitem-10-3" type="checkbox"/><label class="tocitem" for="menuitem-10-3"><span class="docs-label">Explicit Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/ordinarydiffeq/explicit/Tsit5/">OrdinaryDiffEqTsit5</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/explicit/Verner/">OrdinaryDiffEqVerner</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/explicit/AdamsBashforthMoulton/">OrdinaryDiffEqAdamsBashforthMoulton</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/explicit/LowStorageRK/">OrdinaryDiffEqLowStorageRK</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/explicit/SSPRK/">OrdinaryDiffEqSSPRK</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/explicit/LowOrderRK/">OrdinaryDiffEqLowOrderRK</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/explicit/HighOrderRK/">OrdinaryDiffEqHighOrderRK</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/explicit/Feagin/">OrdinaryDiffEqFeagin</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/explicit/PRK/">OrdinaryDiffEqPRK</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/explicit/QPRK/">OrdinaryDiffEqQPRK</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/explicit/TaylorSeries/">OrdinaryDiffEqTaylorSeries</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/explicit/Extrapolation/">OrdinaryDiffEqExtrapolation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-4" type="checkbox"/><label class="tocitem" for="menuitem-10-4"><span class="docs-label">Semi-Implicit Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/ordinarydiffeq/semiimplicit/Rosenbrock/">OrdinaryDiffEqRosenbrock</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/semiimplicit/StabilizedRK/">OrdinaryDiffEqStabilizedRK</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/semiimplicit/ExponentialRK/">OrdinaryDiffEqExponentialRK</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-5" type="checkbox"/><label class="tocitem" for="menuitem-10-5"><span class="docs-label">Implicit Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/ordinarydiffeq/implicit/SDIRK/">OrdinaryDiffEqSDIRK</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/implicit/FIRK/">OrdinaryDiffEqFIRK</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/implicit/BDF/">OrdinaryDiffEqBDF</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/implicit/Extrapolation/">OrdinaryDiffEqExtrapolation</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/implicit/PDIRK/">OrdinaryDiffEqPDIRK</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/implicit/Nordsieck/">OrdinaryDiffEqNordsieck</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-6" type="checkbox"/><label class="tocitem" for="menuitem-10-6"><span class="docs-label">IMEX Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/ordinarydiffeq/imex/IMEXMultistep/">OrdinaryDiffEqIMEXMultistep</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/imex/StabilizedIRK/">OrdinaryDiffEqStabilizedIRK</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/imex/IMEXBDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-7" type="checkbox"/><label class="tocitem" for="menuitem-10-7"><span class="docs-label">Dynamical ODE Explicit Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/ordinarydiffeq/dynamicalodeexplicit/RKN/">OrdinaryDiffEqRKN</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/dynamicalodeexplicit/SymplecticRK/">OrdinaryDiffEqSymplecticRK</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-8" type="checkbox"/><label class="tocitem" for="menuitem-10-8"><span class="docs-label">Semilinear ODE Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/ordinarydiffeq/semilinear/ExponentialRK/">OrdinaryDiffEqExponentialRK</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/semilinear/Linear/">OrdinaryDiffEqLinear</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-9" type="checkbox"/><label class="tocitem" for="menuitem-10-9"><span class="docs-label">Mass Matrix DAE Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/ordinarydiffeq/massmatrixdae/Rosenbrock/">OrdinaryDiffEqRosenbrock</a></li><li><a class="tocitem" href="../api/ordinarydiffeq/massmatrixdae/BDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-10" type="checkbox"/><label class="tocitem" for="menuitem-10-10"><span class="docs-label">Fully Implicit DAE Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/ordinarydiffeq/fullyimplicitdae/BDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-11" type="checkbox"/><label class="tocitem" for="menuitem-10-11"><span class="docs-label">Misc Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/ordinarydiffeq/misc/">Miscellaneous Solvers</a></li></ul></li></ul></li><li><span class="tocitem">StochasticDiffEq.jl API</span><ul><li><a class="tocitem" href="../api/stochasticdiffeq/">StochasticDiffEq.jl: SDE solvers and utilities</a></li><li><a class="tocitem" href="../api/stochasticdiffeq/usage/">Usage</a></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Nonstiff Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/stochasticdiffeq/nonstiff/basic_methods/">Basic Nonstiff Methods</a></li><li><a class="tocitem" href="../api/stochasticdiffeq/nonstiff/sra_sri_methods/">SRA/SRI Methods - Stochastic Runge-Kutta</a></li><li><a class="tocitem" href="../api/stochasticdiffeq/nonstiff/high_weak_order/">High Weak Order Methods</a></li><li><a class="tocitem" href="../api/stochasticdiffeq/nonstiff/commutative_noise/">Commutative Noise Methods</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Stiff Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/stochasticdiffeq/stiff/implicit_methods/">Implicit Methods for Stiff SDEs</a></li><li><a class="tocitem" href="../api/stochasticdiffeq/stiff/split_step_methods/">Split-Step Methods for Fully Stiff Problems</a></li><li><a class="tocitem" href="../api/stochasticdiffeq/stiff/stabilized_methods/">Stabilized Methods (SROCK Family)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Jump Diffusion</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/stochasticdiffeq/jumpdiffusion/tau_leaping/">Tau-Leaping Methods for Jump-Diffusion</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Misc Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/stochasticdiffeq/misc/">Miscellaneous Methods</a></li></ul></li></ul></li><li><span class="tocitem">Extra Details</span><ul><li><a class="tocitem" href="../extras/timestepping/">Timestepping Method Descriptions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting Started with Differential Equations in Julia</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting Started with Differential Equations in Julia</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ode_example"><a class="docs-heading-anchor" href="#ode_example">Getting Started with Differential Equations in Julia</a><a id="ode_example-1"></a><a class="docs-heading-anchor-permalink" href="#ode_example" title="Permalink"></a></h1><p>This tutorial will introduce you to the functionality for solving ODEs. Additionally, a <a href="https://youtu.be/KPEqYtEd-zY">video tutorial</a> walks through this material.</p><h2 id="Example-1-:-Solving-Scalar-Equations"><a class="docs-heading-anchor" href="#Example-1-:-Solving-Scalar-Equations">Example 1 : Solving Scalar Equations</a><a id="Example-1-:-Solving-Scalar-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1-:-Solving-Scalar-Equations" title="Permalink"></a></h2><p>In this example, we will solve the equation</p><p class="math-container">\[\frac{du}{dt} = f(u,p,t)\]</p><p>on the time interval <span>$t\in[0,1]$</span> where <span>$f(u,p,t)=αu$</span>. Here, <span>$u$</span> is the current state variable, <span>$p$</span> is our parameter variable (containing things like a reaction rate or the constant of gravity), and <span>$t$</span> is the current time.</p><p>(In our example, we know by calculus that the solution to this equation is <span>$u(t)=u₀\exp(αt)$</span>, but we will use DifferentialEquations.jl to solve this problem <em>numerically</em>, which is essential for problems where a symbolic solution is not known.)</p><p>The general workflow is to define a problem, solve the problem, and then analyze the solution. The full code for solving this problem is:</p><pre><code class="language-julia hljs">import DifferentialEquations as DE
f(u, p, t) = 1.01 * u
u0 = 1 / 2
tspan = (0.0, 1.0)
prob = DE.ODEProblem(f, u0, tspan)
sol = DE.solve(prob, DE.Tsit5(), reltol = 1e-8, abstol = 1e-8)

import Plots
Plots.plot(sol, linewidth = 5, title = &quot;Solution to the linear ODE with a thick line&quot;,
    xaxis = &quot;Time (t)&quot;, yaxis = &quot;u(t) (in μm)&quot;, label = &quot;My Thick Line!&quot;) # legend=false
Plots.plot!(sol.t, t -&gt; 0.5 * exp(1.01t), lw = 3, ls = :dash, label = &quot;True Solution!&quot;)</code></pre><img src="58ed8ef4.svg" alt="Example block output"/><p>where the pieces are described below.</p><h3 id="Step-1:-Defining-a-Problem"><a class="docs-heading-anchor" href="#Step-1:-Defining-a-Problem">Step 1: Defining a Problem</a><a id="Step-1:-Defining-a-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Defining-a-Problem" title="Permalink"></a></h3><p>To solve this numerically, we define a problem type by giving it the equation, the initial condition, and the timespan to solve over:</p><pre><code class="language-julia hljs">import DifferentialEquations as DE
f(u, p, t) = 1.01 * u
u0 = 1 / 2
tspan = (0.0, 1.0)
prob = DE.ODEProblem(f, u0, tspan)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">ODEProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Float64</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">false</span>
Non-trivial mass matrix: <span class="sgr38_2" style="color:#56b6c2">false</span>
timespan: (0.0, 1.0)
u0: 0.5</code></pre><p>Note that DifferentialEquations.jl will choose the types for the problem based on the types used to define the problem type. For our example, notice that <code>u0</code> is a Float64, and therefore this will solve with the dependent variables being Float64. Since <code>tspan = (0.0,1.0)</code> is a tuple of Float64&#39;s, the independent variables will be solved using Float64&#39;s (note that the start time and end time must match types). You can use this to choose to solve with arbitrary precision numbers, unitful numbers, etc. Please see the <a href="https://github.com/SciML/SciMLTutorials.jl">notebook tutorials</a> for more examples.</p><p>The problem types include many other features, including the ability to define mass matrices and hold callbacks for events. Each problem type has a page which details its constructor and the available fields. For <a href="../types/ode_types/#ode_prob">ODEs, the appropriate page is here</a>. In addition, a user can specify additional functions to be associated with the function in order to speed up the solvers. These are detailed <a href="../features/performance_overloads/#performance_overloads">at the performance overloads page</a>.</p><h3 id="Step-2:-Solving-a-Problem"><a class="docs-heading-anchor" href="#Step-2:-Solving-a-Problem">Step 2: Solving a Problem</a><a id="Step-2:-Solving-a-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Solving-a-Problem" title="Permalink"></a></h3><h4 id="Controlling-the-Solvers"><a class="docs-heading-anchor" href="#Controlling-the-Solvers">Controlling the Solvers</a><a id="Controlling-the-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Controlling-the-Solvers" title="Permalink"></a></h4><p>After defining a problem, you solve it using <code>solve</code>.</p><pre><code class="language-julia hljs">sol = DE.solve(prob)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: 3rd order Hermite
t: 5-element Vector{Float64}:
 0.0
 0.09964258706516003
 0.3457024214672858
 0.6776921708765304
 1.0
u: 5-element Vector{Float64}:
 0.5
 0.552938681151017
 0.7089376222328616
 0.991359430285871
 1.3728004409033048</code></pre><p>This gives us an object <code>sol</code> which contains the solution. Looking at the solution object:</p><pre><code class="language-julia hljs">typeof(sol)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ODESolution{Float64, 1, Vector{Float64}, Nothing, Nothing, Vector{Float64}, Vector{Vector{Float64}}, Nothing, ODEProblem{Float64, Tuple{Float64, Float64}, false, SciMLBase.NullParameters, ODEFunction{false, SciMLBase.AutoSpecialize, typeof(Main.f), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing, Nothing}, Base.Pairs{Symbol, Union{}, Tuple{}, @NamedTuple{}}, SciMLBase.StandardODEProblem}, CompositeAlgorithm{0, Tuple{Tsit5{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}, Vern7{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}, Rosenbrock23{0, ADTypes.AutoFiniteDiff{Val{:forward}, Val{:forward}, Val{:hcentral}, Nothing, Nothing, Int64}, Nothing, typeof(OrdinaryDiffEqCore.DEFAULT_PRECS), Val{:forward}(), true, nothing, typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!)}, Rodas5P{0, ADTypes.AutoFiniteDiff{Val{:forward}, Val{:forward}, Val{:hcentral}, Nothing, Nothing, Int64}, Nothing, typeof(OrdinaryDiffEqCore.DEFAULT_PRECS), Val{:forward}(), true, nothing, typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!)}, FBDF{5, 0, ADTypes.AutoFiniteDiff{Val{:forward}, Val{:forward}, Val{:hcentral}, Nothing, Nothing, Int64}, Nothing, NLNewton{Rational{Int64}, Rational{Int64}, Rational{Int64}, Nothing}, typeof(OrdinaryDiffEqCore.DEFAULT_PRECS), Val{:forward}(), true, nothing, Nothing, Nothing, typeof(OrdinaryDiffEqCore.trivial_limiter!)}, FBDF{5, 0, ADTypes.AutoFiniteDiff{Val{:forward}, Val{:forward}, Val{:hcentral}, Nothing, Nothing, Int64}, LinearSolve.KrylovJL{typeof(Krylov.gmres!), Int64, Nothing, Tuple{}, Base.Pairs{Symbol, Union{}, Tuple{}, @NamedTuple{}}}, NLNewton{Rational{Int64}, Rational{Int64}, Rational{Int64}, Nothing}, typeof(OrdinaryDiffEqCore.DEFAULT_PRECS), Val{:forward}(), true, nothing, Nothing, Nothing, typeof(OrdinaryDiffEqCore.trivial_limiter!)}}, OrdinaryDiffEqCore.AutoSwitchCache{Tuple{Tsit5{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}, Vern7{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}}, Tuple{Rosenbrock23{0, ADTypes.AutoFiniteDiff{Val{:forward}, Val{:forward}, Val{:hcentral}, Nothing, Nothing, Int64}, Nothing, typeof(OrdinaryDiffEqCore.DEFAULT_PRECS), Val{:forward}(), true, nothing, typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!)}, Rodas5P{0, ADTypes.AutoFiniteDiff{Val{:forward}, Val{:forward}, Val{:hcentral}, Nothing, Nothing, Int64}, Nothing, typeof(OrdinaryDiffEqCore.DEFAULT_PRECS), Val{:forward}(), true, nothing, typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!)}, FBDF{5, 0, ADTypes.AutoFiniteDiff{Val{:forward}, Val{:forward}, Val{:hcentral}, Nothing, Nothing, Int64}, Nothing, NLNewton{Rational{Int64}, Rational{Int64}, Rational{Int64}, Nothing}, typeof(OrdinaryDiffEqCore.DEFAULT_PRECS), Val{:forward}(), true, nothing, Nothing, Nothing, typeof(OrdinaryDiffEqCore.trivial_limiter!)}, FBDF{5, 0, ADTypes.AutoFiniteDiff{Val{:forward}, Val{:forward}, Val{:hcentral}, Nothing, Nothing, Int64}, LinearSolve.KrylovJL{typeof(Krylov.gmres!), Int64, Nothing, Tuple{}, Base.Pairs{Symbol, Union{}, Tuple{}, @NamedTuple{}}}, NLNewton{Rational{Int64}, Rational{Int64}, Rational{Int64}, Nothing}, typeof(OrdinaryDiffEqCore.DEFAULT_PRECS), Val{:forward}(), true, nothing, Nothing, Nothing, typeof(OrdinaryDiffEqCore.trivial_limiter!)}}, Rational{Int64}, Int64}}, OrdinaryDiffEqCore.InterpolationData{ODEFunction{false, SciMLBase.AutoSpecialize, typeof(Main.f), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing, Nothing}, Vector{Float64}, Vector{Float64}, Vector{Vector{Float64}}, Vector{Int64}, OrdinaryDiffEqCore.DefaultCache{OrdinaryDiffEqTsit5.Tsit5ConstantCache, OrdinaryDiffEqVerner.Vern7ConstantCache, OrdinaryDiffEqRosenbrock.Rosenbrock23ConstantCache{Float64, SciMLBase.TimeDerivativeWrapper{false, ODEFunction{false, SciMLBase.AutoSpecialize, typeof(Main.f), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing, Nothing}, Float64, SciMLBase.NullParameters}, SciMLBase.UDerivativeWrapper{false, ODEFunction{false, SciMLBase.AutoSpecialize, typeof(Main.f), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing, Nothing}, Float64, SciMLBase.NullParameters}, Float64, Float64, Nothing, ADTypes.AutoFiniteDiff{Val{:forward}, Val{:forward}, Val{:hcentral}, Nothing, Nothing, Int64}}, OrdinaryDiffEqRosenbrock.RosenbrockCombinedConstantCache{SciMLBase.TimeDerivativeWrapper{false, ODEFunction{false, SciMLBase.AutoSpecialize, typeof(Main.f), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing, Nothing}, Float64, SciMLBase.NullParameters}, SciMLBase.UDerivativeWrapper{false, ODEFunction{false, SciMLBase.AutoSpecialize, typeof(Main.f), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing, Nothing}, Float64, SciMLBase.NullParameters}, OrdinaryDiffEqRosenbrock.RodasTableau{Float64, Float64}, Float64, Float64, Nothing, ADTypes.AutoFiniteDiff{Val{:forward}, Val{:forward}, Val{:hcentral}, Nothing, Nothing, Int64}}, OrdinaryDiffEqBDF.FBDFConstantCache{5, OrdinaryDiffEqNonlinearSolve.NLSolver{NLNewton{Rational{Int64}, Rational{Int64}, Rational{Int64}, Nothing}, false, Float64, Rational{Int64}, Nothing, Float64, OrdinaryDiffEqNonlinearSolve.NLNewtonConstantCache{Float64, Float64, Float64, Float64, SciMLBase.UDerivativeWrapper{false, ODEFunction{false, SciMLBase.AutoSpecialize, typeof(Main.f), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing, Nothing}, Float64, SciMLBase.NullParameters}}, Float64}, Vector{Float64}, Float64, Matrix{Float64}, Matrix{Float64}, StaticArraysCore.SMatrix{5, 6, Rational{Int64}, 30}, Float64, Vector{Float64}, Vector{Float64}}, OrdinaryDiffEqBDF.FBDFConstantCache{5, OrdinaryDiffEqNonlinearSolve.NLSolver{NLNewton{Rational{Int64}, Rational{Int64}, Rational{Int64}, Nothing}, false, Float64, Rational{Int64}, Nothing, Float64, OrdinaryDiffEqNonlinearSolve.NLNewtonConstantCache{Float64, Float64, Float64, OrdinaryDiffEqDifferentiation.WOperator{false, Float64, LinearAlgebra.UniformScaling{Bool}, Float64, Float64, Nothing, Float64, OrdinaryDiffEqDifferentiation.JVPCache{Float64}}, SciMLBase.UDerivativeWrapper{false, ODEFunction{false, SciMLBase.AutoSpecialize, typeof(Main.f), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing, Nothing}, Float64, SciMLBase.NullParameters}}, Float64}, Vector{Float64}, Float64, Matrix{Float64}, Matrix{Float64}, StaticArraysCore.SMatrix{5, 6, Rational{Int64}, 30}, Float64, Vector{Float64}, Vector{Float64}}, Tuple{Float64, Float64, DataType, DataType, DataType, Float64, Float64, ODEFunction{false, SciMLBase.AutoSpecialize, typeof(Main.f), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing, Nothing}, Float64, Float64, Float64, SciMLBase.NullParameters, Bool, Val{false}}, OrdinaryDiffEqCore.AutoSwitchCache{Tuple{Tsit5{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}, Vern7{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}}, Tuple{Rosenbrock23{0, ADTypes.AutoFiniteDiff{Val{:forward}, Val{:forward}, Val{:hcentral}, Nothing, Nothing, Int64}, Nothing, typeof(OrdinaryDiffEqCore.DEFAULT_PRECS), Val{:forward}(), true, nothing, typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!)}, Rodas5P{0, ADTypes.AutoFiniteDiff{Val{:forward}, Val{:forward}, Val{:hcentral}, Nothing, Nothing, Int64}, Nothing, typeof(OrdinaryDiffEqCore.DEFAULT_PRECS), Val{:forward}(), true, nothing, typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!)}, FBDF{5, 0, ADTypes.AutoFiniteDiff{Val{:forward}, Val{:forward}, Val{:hcentral}, Nothing, Nothing, Int64}, Nothing, NLNewton{Rational{Int64}, Rational{Int64}, Rational{Int64}, Nothing}, typeof(OrdinaryDiffEqCore.DEFAULT_PRECS), Val{:forward}(), true, nothing, Nothing, Nothing, typeof(OrdinaryDiffEqCore.trivial_limiter!)}, FBDF{5, 0, ADTypes.AutoFiniteDiff{Val{:forward}, Val{:forward}, Val{:hcentral}, Nothing, Nothing, Int64}, LinearSolve.KrylovJL{typeof(Krylov.gmres!), Int64, Nothing, Tuple{}, Base.Pairs{Symbol, Union{}, Tuple{}, @NamedTuple{}}}, NLNewton{Rational{Int64}, Rational{Int64}, Rational{Int64}, Nothing}, typeof(OrdinaryDiffEqCore.DEFAULT_PRECS), Val{:forward}(), true, nothing, Nothing, Nothing, typeof(OrdinaryDiffEqCore.trivial_limiter!)}}, Rational{Int64}, Int64}, Float64}, Nothing}, SciMLBase.DEStats, Vector{Int64}, Nothing, Nothing, Nothing}</code></pre><p>The solution object contains the time points and corresponding solution values:</p><pre><code class="language-julia hljs">@info &quot;Solution contains $(length(sol.t)) time points from t=$(sol.t[1]) to t=$(sol.t[end])&quot;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr36"><span class="sgr1">[ Info: </span></span>Solution contains 5 time points from t=0.0 to t=1.0</code></pre><p>The solvers can be controlled using the available options are described on the <a href="../basics/common_solver_opts/#solver_options">Common Solver Options manual page</a>. For example, we can lower the relative tolerance (in order to get a more correct result, at the cost of more timesteps) by using the command <code>reltol</code>:</p><pre><code class="language-julia hljs">sol = DE.solve(prob, reltol = 1e-6);</code></pre><p>There are many controls for handling outputs. For example, we can choose to have the solver save every <code>0.1</code> time points by setting <code>saveat=0.1</code>. Chaining this with the tolerance choice looks like:</p><pre><code class="language-julia hljs">sol = DE.solve(prob, reltol = 1e-6, saveat = 0.1);</code></pre><p>More generally, <code>saveat</code> can be any collection of time points to save at. Note that this uses interpolations to keep the timestep unconstrained to speed up the solution. In addition, if we only care about the endpoint, we can turn off intermediate saving in general:</p><pre><code class="language-julia hljs">sol = DE.solve(prob, reltol = 1e-6, save_everystep = false);</code></pre><p>which will only save the final time point.</p><h4 id="Choosing-a-Solver-Algorithm"><a class="docs-heading-anchor" href="#Choosing-a-Solver-Algorithm">Choosing a Solver Algorithm</a><a id="Choosing-a-Solver-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-a-Solver-Algorithm" title="Permalink"></a></h4><p>DifferentialEquations.jl has a method for choosing the default solver algorithm, which will find an efficient method to solve your problem. To help users receive the right algorithm, DifferentialEquations.jl offers a method for choosing algorithms through hints. This default chooser utilizes the precision of the number types and the keyword arguments (such as the tolerances) to select an algorithm. Additionally, one can provide <code>alg_hints</code> to help choose good defaults using properties of the problem and necessary features for the solution. For example, if we have a stiff problem where we need high accuracy, but don&#39;t know the best stiff algorithm for this problem, we can use:</p><pre><code class="language-julia hljs">sol = DE.solve(prob, alg_hints = [:stiff], reltol = 1e-8, abstol = 1e-8);</code></pre><p>You can also explicitly choose the algorithm to use. DifferentialEquations.jl offers a much wider variety of solver algorithms than traditional differential equations libraries. Many of these algorithms are from recent research and have been shown to be more efficient than the “standard” algorithms. For example, we can choose a 5th order Tsitouras method:</p><pre><code class="language-julia hljs">sol = DE.solve(prob, DE.Tsit5());</code></pre><p>Note that the solver controls can be combined with the algorithm choice. Thus we can for example solve the problem using <code>DE.Tsit5()</code> with a lower tolerance via:</p><pre><code class="language-julia hljs">sol = DE.solve(prob, DE.Tsit5(), reltol = 1e-8, abstol = 1e-8);</code></pre><p>In DifferentialEquations.jl, some good “go-to” choices for ODEs are:</p><ul><li><code>AutoTsit5(Rosenbrock23())</code> handles both stiff and non-stiff equations. This is a good algorithm to use if you know nothing about the equation.</li><li><code>AutoVern7(Rodas5())</code> handles both stiff and non-stiff equations in a way that&#39;s efficient for high accuracy.</li><li><code>DE.Tsit5()</code> for standard non-stiff. This is the first algorithm to try in most cases.</li><li><code>BS3()</code> for fast low accuracy non-stiff.</li><li><code>Vern7()</code> for high accuracy non-stiff.</li><li><code>Rodas4()</code> or <code>Rodas5()</code> for small stiff equations with Julia-defined types, events, etc.</li><li><code>KenCarp4()</code> or <code>TRBDF2()</code> for medium-sized (100-2000 ODEs) stiff equations</li><li><code>RadauIIA5()</code> for really high accuracy stiff equations</li><li><code>QNDF()</code> for large stiff equations</li></ul><p>For a comprehensive list of the available algorithms and detailed recommendations, <a href="../solvers/ode_solve/#ode_solve">please see the solver documentation</a>. Every problem type has an associated page detailing all the solvers associated with the problem.</p><h3 id="Step-3:-Analyzing-the-Solution"><a class="docs-heading-anchor" href="#Step-3:-Analyzing-the-Solution">Step 3: Analyzing the Solution</a><a id="Step-3:-Analyzing-the-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Analyzing-the-Solution" title="Permalink"></a></h3><h4 id="Handling-the-Solution-Type"><a class="docs-heading-anchor" href="#Handling-the-Solution-Type">Handling the Solution Type</a><a id="Handling-the-Solution-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-the-Solution-Type" title="Permalink"></a></h4><p>The result of <code>solve</code> is a solution object. We can access the 5th value of the solution with:</p><pre><code class="language-julia hljs">sol[5]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.569506783074463</code></pre><p>or get the time of the 8th timestep by:</p><pre><code class="language-julia hljs">sol.t[8]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.3147930010051887</code></pre><p>Convenience features are also included. We can build an array using a comprehension over the solution tuples via:</p><pre><code class="language-julia hljs">[t + u for (u, t) in DE.tuples(sol)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">17-element Vector{Float64}:
 0.5
 0.5187132051077795
 0.5644317550703615
 0.6248332143568608
 0.6983806394824756
 0.7862723535922229
 0.8874771710609809
 1.0019405413168716
 1.1289222312977705
 1.268084159245248
 1.4189930483255861
 1.5814562413921616
 1.7553817483840448
 1.940861234713997
 2.1381391068371607
 2.347620254588751
 2.372800507622575</code></pre><p>or more generally</p><pre><code class="language-julia hljs">[t + 2u for (u, t) in zip(sol.u, sol.t)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">17-element Vector{Float64}:
 1.0
 1.0250185840192507
 1.086362230732143
 1.1678859316432824
 1.2678874225569385
 1.3884467263334956
 1.5286797475444973
 1.6890880816285545
 1.869248088256517
 2.069306521077246
 2.289269935071749
 2.5294777442688066
 2.7904004504921716
 3.0727644192930974
 3.377512646692508
 3.7058242533805963
 3.7456010152451498</code></pre><p>allows one to use more parts of the solution type. The object that is returned by default acts as a continuous solution via an interpolation. We can access the interpolated values by treating <code>sol</code> as a function, for example:</p><pre><code class="language-julia hljs">sol(0.45) # The value of the solution at t=0.45</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.7876927465687831</code></pre><p>Note the difference between these: indexing with <code>[i]</code> is the value at the <code>i</code>th step, while <code>(t)</code> is an interpolation at time <code>t</code>!</p><p>If in the solver <code>dense=true</code> (this is the default unless <code>saveat</code> is used), then this interpolation is a high order interpolation and thus usually matches the error of the solution time points. The interpolations associated with each solver is <a href="../solvers/ode_solve/#ode_solve">detailed at the solver algorithm page</a>. If <code>dense=false</code> (unless specifically set, this only occurs when <code>save_everystep=false</code> or <code>saveat</code> is used) then this defaults to giving a linear interpolation.</p><p>For more details on handling the output, see <a href="../basics/solution/#solution">the solution handling page</a>.</p><h4 id="Plotting-Solutions"><a class="docs-heading-anchor" href="#Plotting-Solutions">Plotting Solutions</a><a id="Plotting-Solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-Solutions" title="Permalink"></a></h4><p>While one can directly plot solution time points using the tools given above, convenience commands are defined by recipes for Plots.jl. To plot the solution object, simply call plot:</p><pre><code class="language-julia hljs">#]add Plots # You need to install Plots.jl before your first time using it!
import Plots
#plotly() # You can optionally choose a plotting backend
Plots.plot(sol)</code></pre><img src="75ed03c4.svg" alt="Example block output"/><p>The plot function can be formatted using <a href="https://juliaplots.org/">the attributes available in Plots.jl</a>. Additional DiffEq-specific controls are documented <a href="../basics/plot/#plot">at the plotting page</a>.</p><p>For example, from the Plots.jl attribute page, we see that the line width can be set via the argument <code>linewidth</code>. Additionally, a title can be set with <code>title</code>. Thus we add these to our plot command to get the correct output, fix up some axis labels, and change the legend (note we can disable the legend with <code>legend=false</code>) to get a nice-looking plot:</p><pre><code class="language-julia hljs">Plots.plot(sol, linewidth = 5, title = &quot;Solution to the linear ODE with a thick line&quot;,
    xaxis = &quot;Time (t)&quot;, yaxis = &quot;u(t) (in μm)&quot;, label = &quot;My Thick Line!&quot;) # legend=false</code></pre><img src="50289019.svg" alt="Example block output"/><p>We can then add to the plot using the <code>plot!</code> command:</p><pre><code class="language-julia hljs">Plots.plot!(sol.t, t -&gt; 0.5 * exp(1.01t), lw = 3, ls = :dash, label = &quot;True Solution!&quot;)</code></pre><img src="c1b6882e.svg" alt="Example block output"/><h2 id="Example-2:-Solving-Systems-of-Equations"><a class="docs-heading-anchor" href="#Example-2:-Solving-Systems-of-Equations">Example 2: Solving Systems of Equations</a><a id="Example-2:-Solving-Systems-of-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-Solving-Systems-of-Equations" title="Permalink"></a></h2><p>In this example, we will solve the Lorenz equations:</p><p class="math-container">\[\begin{aligned}
\frac{dx}{dt} &amp;= σ(y-x) \\
\frac{dy}{dt} &amp;= x(ρ-z) - y \\
\frac{dz}{dt} &amp;= xy - βz \\
\end{aligned}\]</p><p>Defining your ODE function to be in-place updating can have performance benefits. What this means is that, instead of writing a function which outputs its solution, you write a function which updates a vector that is designated to hold the solution. By doing this, DifferentialEquations.jl&#39;s solver packages are able to reduce the amount of array allocations and achieve better performance.</p><p>The way we do this is we simply write the output to the 1st input of the function. For example, our Lorenz equation problem would be defined by the function:</p><pre><code class="language-julia hljs">function lorenz!(du, u, p, t)
    du[1] = 10.0 * (u[2] - u[1])
    du[2] = u[1] * (28.0 - u[3]) - u[2]
    du[3] = u[1] * u[2] - (8 / 3) * u[3]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">lorenz! (generic function with 1 method)</code></pre><p>and then we can use this function in a problem:</p><pre><code class="language-julia hljs">import DifferentialEquations as DE
u0 = [1.0; 0.0; 0.0]
tspan = (0.0, 100.0)
prob = DE.ODEProblem(lorenz!, u0, tspan)
sol = DE.solve(prob)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr36"><span class="sgr1">[ Info: </span></span>Solution has 1292 timesteps</code></pre><p>Using the plot recipe tools <a href="../basics/plot/#plot_vars">defined on the plotting page</a>, we can choose to do a 3D phase space plot between the different variables:</p><pre><code class="language-julia hljs">import Plots
Plots.plot(sol, idxs = (1, 2, 3))</code></pre><img src="8b130c19.svg" alt="Example block output"/><p>Note that the default plot for multidimensional systems is an overlay of each timeseries. We can plot the timeseries of just the second component using the variable choices interface once more:</p><pre><code class="language-julia hljs">Plots.plot(sol, idxs = (0, 2))</code></pre><img src="4dafb27f.svg" alt="Example block output"/><p>Note that here “variable 0” corresponds to the independent variable (“time”).</p><h2 id="Defining-Parameterized-Functions"><a class="docs-heading-anchor" href="#Defining-Parameterized-Functions">Defining Parameterized Functions</a><a id="Defining-Parameterized-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Parameterized-Functions" title="Permalink"></a></h2><p>Often, you want to explicitly have parameters associated with your differential equations. This can be used by things like <a href="https://docs.sciml.ai/Overview/stable/highlevels/inverse_problems/">parameter estimation routines</a>. In this case, you use the <code>p</code> values via the syntax:</p><pre><code class="language-julia hljs">function parameterized_lorenz!(du, u, p, t)
    du[1] = p[1] * (u[2] - u[1])
    du[2] = u[1] * (p[2] - u[3]) - u[2]
    du[3] = u[1] * u[2] - p[3] * u[3]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">parameterized_lorenz! (generic function with 1 method)</code></pre><p>and then we add the parameters to the <code>ODEProblem</code>:</p><pre><code class="language-julia hljs">u0 = [1.0, 0.0, 0.0]
tspan = (0.0, 1.0)
p = [10.0, 28.0, 8 / 3]
prob = DE.ODEProblem(parameterized_lorenz!, u0, tspan, p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">ODEProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Float64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
Non-trivial mass matrix: <span class="sgr38_2" style="color:#56b6c2">false</span>
timespan: (0.0, 1.0)
u0: 3-element Vector{Float64}:
 1.0
 0.0
 0.0</code></pre><p>We can make our functions look nicer by doing a few tricks. For example:</p><pre><code class="language-julia hljs">function parameterized_lorenz!(du, u, p, t)
    x, y, z = u
    σ, ρ, β = p
    du[1] = dx = σ * (y - x)
    du[2] = dy = x * (ρ - z) - y
    du[3] = dz = x * y - β * z
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">parameterized_lorenz! (generic function with 1 method)</code></pre><p>Note that the type for the parameters <code>p</code> can be anything: you can use arrays, static arrays, named tuples, etc. to enclose your parameters in a way that is sensible for your problem.</p><p>Since the parameters exist within the function, functions defined in this manner can also be used for sensitivity analysis, parameter estimation routines, and bifurcation plotting. This makes DifferentialEquations.jl a full-stop solution for differential equation analysis which also achieves high performance.</p><h2 id="Example-3:-Solving-Nonhomogeneous-Equations-using-Parameterized-Functions"><a class="docs-heading-anchor" href="#Example-3:-Solving-Nonhomogeneous-Equations-using-Parameterized-Functions">Example 3: Solving Nonhomogeneous Equations using Parameterized Functions</a><a id="Example-3:-Solving-Nonhomogeneous-Equations-using-Parameterized-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-Solving-Nonhomogeneous-Equations-using-Parameterized-Functions" title="Permalink"></a></h2><p>Parameterized functions can also be used for building <strong>nonhomogeneous ordinary differential equations</strong> (these are also referred to as ODEs with <strong>nonzero right-hand sides</strong>). They are frequently used as models for dynamical systems with external (in general time-varying) <strong>inputs</strong>. As an example, consider a <a href="https://en.wikipedia.org/wiki/Pendulum_(mathematics)">model of a pendulum</a> consisting of a slender rod of length <code>l</code> and mass <code>m</code>:</p><p class="math-container">\[\begin{aligned}
\frac{\mathrm{d}\theta(t)}{\mathrm{d}t} &amp;= \omega(t)\\
\frac{\mathrm{d}\omega(t)}{\mathrm{d}t} &amp;= - \frac{3}{2}\frac{g}{l}\sin\theta(t) + \frac{3}{ml^2}M(t)
\end{aligned},\]</p><p>where <code>θ</code> and <code>ω</code> are the angular deviation of the pendulum from the vertical (hanging) orientation and the angular rate, respectively, <code>M</code> is an external torque (developed, say, by a wind or a motor), and finally, <code>g</code> stands for gravitational acceleration.</p><pre><code class="language-julia hljs">import DifferentialEquations as DE
import Plots

l = 1.0                             # length [m]
m = 1.0                             # mass [kg]
g = 9.81                            # gravitational acceleration [m/s²]

function pendulum!(du, u, p, t)
    du[1] = u[2]                    # θ&#39;(t) = ω(t)
    du[2] = -3g / (2l) * sin(u[1]) + 3 / (m * l^2) * p(t) # ω&#39;(t) = -3g/(2l) sin θ(t) + 3/(ml^2)M(t)
end

θ₀ = 0.01                           # initial angular deflection [rad]
ω₀ = 0.0                            # initial angular velocity [rad/s]
u₀ = [θ₀, ω₀]                       # initial state vector
tspan = (0.0, 10.0)                  # time interval

M = t -&gt; 0.1sin(t)                    # external torque [Nm]

prob = DE.ODEProblem(pendulum!, u₀, tspan, M)
sol = DE.solve(prob)

Plots.plot(
    sol, linewidth = 2, xaxis = &quot;t&quot;, label = [&quot;θ [rad]&quot; &quot;ω [rad/s]&quot;], layout = (2, 1))</code></pre><img src="fa4d6264.svg" alt="Example block output"/><p>Note how the external <strong>time-varying</strong> torque <code>M</code> is introduced as a <strong>parameter</strong> in the <code>pendulum!</code> function. Indeed, as a general principle the parameters can be any type; here we specify <code>M</code> as time-varying by representing it by a function, which is expressed by appending the dependence on time <code>(t)</code> to the name of the parameter.</p><p>Note also that, in contrast with the time-varying parameter, the (vector of) state variables <code>u</code>, which is generally also time-varying, is always used without the explicit dependence on time <code>(t)</code>.</p><h2 id="ode_other_types"><a class="docs-heading-anchor" href="#ode_other_types">Example 4: Using Other Types for Systems of Equations</a><a id="ode_other_types-1"></a><a class="docs-heading-anchor-permalink" href="#ode_other_types" title="Permalink"></a></h2><p>DifferentialEquations.jl can handle many different dependent variable types (generally, anything with a linear index should work!). So instead of solving a vector equation, let&#39;s let <code>u</code> be a matrix! To do this, we simply need to have <code>u0</code> be a matrix, and define <code>f</code> such that it takes in a matrix and outputs a matrix. We can define a matrix of linear ODEs as follows:</p><pre><code class="language-julia hljs">import DifferentialEquations as DE
import Plots
A = [1.0 0 0 -5
     4 -2 4 -3
     -4 0 0 1
     5 -2 2 3]
u0 = rand(4, 2)
tspan = (0.0, 1.0)
f(u, p, t) = A * u
prob = DE.ODEProblem(f, u0, tspan)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">ODEProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Matrix{Float64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">false</span>
Non-trivial mass matrix: <span class="sgr38_2" style="color:#56b6c2">false</span>
timespan: (0.0, 1.0)
u0: 4×2 Matrix{Float64}:
 0.650689   0.626652
 0.0102827  0.30686
 0.0688691  0.897763
 0.0580737  0.181828</code></pre><p>Here our ODE is on a 4x2 matrix, and the ODE is the linear system defined by multiplication by <code>A</code>. To solve the ODE, we do the same steps as before.</p><pre><code class="language-julia hljs">sol = DE.solve(prob)
Plots.plot(sol)</code></pre><img src="28645cfa.svg" alt="Example block output"/><p>We can instead use the in-place form by using Julia&#39;s in-place matrix multiplication function <code>mul!</code>:</p><pre><code class="language-julia hljs">import LinearAlgebra
f(du, u, p, t) = LinearAlgebra.mul!(du, A, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">f (generic function with 2 methods)</code></pre><p>Additionally, we can use non-traditional array types as well. For example, <code>StaticArrays.jl</code> offers immutable arrays which are stack-allocated, meaning that their usage does not require any (slow) heap-allocations that arrays normally have. This means that they can be used to solve the same problem as above, with the only change being the type for the initial condition and constants:</p><pre><code class="language-julia hljs">import StaticArrays
A = StaticArrays.@SMatrix [1.0 0.0 0.0 -5.0
                           4.0 -2.0 4.0 -3.0
                           -4.0 0.0 0.0 1.0
                           5.0 -2.0 2.0 3.0]
u0 = StaticArrays.@SMatrix rand(4, 2)
tspan = (0.0, 1.0)
f2(u, p, t) = A * u
prob = DE.ODEProblem(f2, u0, tspan)
sol = DE.solve(prob)
Plots.plot(sol)</code></pre><img src="cc517a6d.svg" alt="Example block output"/><p>Note that the analysis tools generalize over to systems of equations as well.</p><pre><code class="language-julia hljs">sol[4]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×2 StaticArraysCore.SMatrix{4, 2, Float64, 8} with indices SOneTo(4)×SOneTo(2):
 -1.14696   -0.208764
 -0.349138   0.334863
  0.940251   0.341957
  1.62207    0.882561</code></pre><p>still returns the solution at the fourth timestep. It also indexes into the array as well. The last value is the timestep, and the beginning values are for the component. This means</p><pre><code class="language-julia hljs">sol[5, 3]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.12205649422543467</code></pre><p>is the value of the 5th component (by linear indexing) at the 3rd timepoint, or</p><pre><code class="language-julia hljs">sol[2, 1, :]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element Vector{Float64}:
  0.3184221006159742
  0.24136236274992323
  0.01929886580069792
 -0.34913790659183713
 -0.8715912669690703
 -1.331943592867627
 -1.1957294712169924
  0.3971320224886438
  4.215212927591681
  9.145728064484016</code></pre><p>is the timeseries for the component, which is the 2nd row and 1 column.</p><h2 id="Going-Beyond-ODEs:-How-to-Use-the-Documentation"><a class="docs-heading-anchor" href="#Going-Beyond-ODEs:-How-to-Use-the-Documentation">Going Beyond ODEs: How to Use the Documentation</a><a id="Going-Beyond-ODEs:-How-to-Use-the-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Going-Beyond-ODEs:-How-to-Use-the-Documentation" title="Permalink"></a></h2><p>Not everything can be covered in the tutorials. Instead, this tutorial will end by pointing you in the directions for the next steps.</p><h4 id="Common-API-for-Defining,-Solving,-and-Plotting"><a class="docs-heading-anchor" href="#Common-API-for-Defining,-Solving,-and-Plotting">Common API for Defining, Solving, and Plotting</a><a id="Common-API-for-Defining,-Solving,-and-Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Common-API-for-Defining,-Solving,-and-Plotting" title="Permalink"></a></h4><p>One feature of DifferentialEquations.jl is that this pattern for solving equations is conserved across the different types of differential equations. Every equation has a problem type, a solution type, and the same solution handling (+ plotting) setup. Thus the solver and plotting commands in the <strong>Basics</strong> section applies to all sorts of equations, like stochastic differential equations and delay differential equations. Each of these different problem types are defined in the <strong>Problem Types</strong> section of the docs. Every associated solver algorithm is detailed in the <strong>Solver Algorithms</strong> section, sorted by problem type. The same steps for ODEs can then be used for the analysis of the solution.</p><h4 id="Additional-Features-and-Analysis-Tools"><a class="docs-heading-anchor" href="#Additional-Features-and-Analysis-Tools">Additional Features and Analysis Tools</a><a id="Additional-Features-and-Analysis-Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-Features-and-Analysis-Tools" title="Permalink"></a></h4><p>In many cases, the common workflow only starts with solving the differential equation. Many common setups have built-in solutions in DifferentialEquations.jl. For example, check out the features for:</p><ul><li><a href="../features/ensemble/#ensemble">Handling, parallelizing, and analyzing large Ensemble experiments</a></li><li><a href="../features/io/#io">Saving the output to tabular formats like DataFrames and CSVs</a></li><li><a href="../features/callback_functions/#callbacks">Event handling</a></li><li><a href="https://docs.sciml.ai/Overview/stable/highlevels/inverse_problems/">Parameter estimation (inverse problems)</a></li><li><a href="https://docs.sciml.ai/Overview/stable/highlevels/uncertainty_quantification/">Quantification of numerical uncertainty and error</a></li></ul><p>Many more are defined in the relevant sections of the docs. Please explore the rest of the documentation, including tutorials for getting started with other types of equations. In addition, to get help, please either <a href="https://github.com/SciML/DifferentialEquations.jl">file an issue at the main repository</a> or <a href="https://julialang.zulipchat.com/#narrow/stream/279055-sciml-bridged">come have an informal discussion at the Julia Zulip chatroom</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« DifferentialEquations.jl: Efficient Differential Equation Solving in Julia</a><a class="docs-footer-nextpage" href="../tutorials/faster_ode_example/">Code Optimization for Differential Equations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 14 August 2025 22:49">Thursday 14 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
