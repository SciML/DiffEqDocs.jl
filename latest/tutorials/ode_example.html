<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ordinary Differential Equations (ODE) · DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script></head><body><nav class="toc"><h1>DifferentialEquations.jl</h1><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li class="current"><a class="toctext" href="ode_example.html">Ordinary Differential Equations (ODE)</a><ul class="internal"></ul></li><li><a class="toctext" href="sde_example.html">Stochastic Differential Equations (SDE)</a></li><li><a class="toctext" href="dae_example.html">Differential Algebraic Equations (DAE)</a></li><li><a class="toctext" href="fempoisson_example.html">Poisson Equation Finite Element Method</a></li><li><a class="toctext" href="femheat_example.html">Heat Equation Finite Element Method</a></li><li><a class="toctext" href="femstochastic_example.html">Stochastic Finite Element Method</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li></ul></li><li><span class="toctext">Equation Types</span><ul><li><a class="toctext" href="../types/ode_types.html">ODE Types</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Types</a></li><li><a class="toctext" href="../types/fem_types.html">FEM Types</a></li><li><a class="toctext" href="../types/stokes_types.html">Stokes Types</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../solvers/ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="../solvers/dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="../solvers/fempoisson_solve.html">FEM Poisson Solvers</a></li><li><a class="toctext" href="../solvers/femheat_solve.html">FEM Heat Solvers</a></li><li><a class="toctext" href="../solvers/fdmstokes_solve.html">Stokes Solvers</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="../features/performance_overloads.html">Performance Overloads</a></li><li><a class="toctext" href="../features/callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="../features/mesh.html">Meshes</a></li><li><a class="toctext" href="../features/output_specification.html">Output Specification</a></li><li><a class="toctext" href="../features/conditional_dependencies.html">Conditional Dependencies</a></li><li><a class="toctext" href="../features/progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../analysis/parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="../analysis/parameter_estimation.html">Parameter Estimation</a></li><li><a class="toctext" href="../analysis/sensitivity.html">Sensitivity Analysis</a></li><li><a class="toctext" href="../analysis/dev_and_test.html">Algorithm Development and Testing</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href="ode_example.html">Ordinary Differential Equations (ODE)</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/tree/1410d36fea13152da9e7b611a4f4bc8178e075d6/docs/src/tutorials/ode_example.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Ordinary-Differential-Equations-(ODE)-1" href="#Ordinary-Differential-Equations-(ODE)-1">Ordinary Differential Equations (ODE)</a></h1><p>This tutorial will introduce you to the functionality for solving ODEs. Other introductions can be found by <a href="https://github.com/JuliaDiffEq/DifferentialEquations.jl/tree/master/examples">checking out the IJulia notebooks in the examples folder</a>.</p><p>In this example we will solve the equation</p><div>\[\frac{du}{dt} = f(t,u)\]</div><p>on the time interval <span>$t\in[0,1]$</span> where <span>$f(t,u)=αu$</span>. We know via Calculus that the solution to this equation is <span>$u(t)=u₀\exp(αt)$</span>. To solve this numerically, we define a problem type by giving it the equation, the initial condition, and the timespan to solve over:</p><pre><code class="language-julia">using DifferentialEquations
α=1
u0=1/2
f(t,u) = α*u
tspan = (0.0,1.0)
prob = ODEProblem(f,u0,tspan)</code></pre><p>Note that DifferentialEquations.jl will choose the types for the problem based on the types used to define the problem type. For our example, notice that <code>u0</code> is a Float64, and therefore this will solve with the independent variables being Float64. Since <code>tspan = (0.0,1.0)</code> is a tuple of Float64&#39;s, the dependent variabes will be solved using Float64&#39;s (note that the start time and end time must match types). You can use this to choose to solve with arbitrary precision numbers, unitful numbers, etc. Please see the <a href="https://github.com/JuliaDiffEq/DiffEqTutorials.jl">tutorials</a> for more details.</p><p>After defining a problem, you solve it using <code>solve</code>.</p><pre><code class="language-julia">sol = solve(prob)</code></pre><p>DifferentialEquations.jl has a method for choosing the default solver algorithm and the (adaptive) stepsizes <code>dt</code>, and so this will find an efficient method to solve your problem. You can also explicitly choose an algorithm and pass in some parameters.</p><pre><code class="language-julia">sol = solve(prob,Euler,dt=1/2^4)</code></pre><p>In this case I chose to use the classic Euler method, and gave it a stepsize <code>dt=1/2^4</code>. Normally <code>dt</code> is the starting stepsize but since the Euler method is not adaptive this is the stepsize for the calculation. The available options is described on the <a href="../solvers/common_solvers_opts.html">Common Solver Options manual page</a>.</p><p>The result of <code>solve</code> is a solution object. We can access the 5th value of the solution with</p><pre><code class="language-julia">sol[5] #.637</code></pre><p>or get the time of the 8th timestep by</p><pre><code class="language-julia">sol.t[8]
#.438</code></pre><p>Convenience features are also included. We can build an array using a comprehension over the solution tuples via</p><pre><code class="language-julia">[t+u for (t,u) in tuples(sol)]</code></pre><p>or more generally</p><pre><code class="language-julia">[t+2u for (t,u) in zip(sol.t,sol.u)]</code></pre><p>allows one to use more parts of the solution type. The object that is returns by default acts as a continuous solution via an interpolation. We can access the interpolated values by treating <code>sol</code> as a function, for example:</p><pre><code class="language-julia">sol(0.45) # The value of the solution at t=0.45</code></pre><p>For details on more finely controlling the output, see <a href="http://juliadiffeq.github.io/DifferentialEquations.jl/latest/man/output_specification.html">the Output Specification manual page</a></p><p>Plotting commands are provided via a recipe to Plots.jl. To plot the solution object, simply call plot:</p><pre><code class="language-julia">using Plots
#gr() # You can optionally choose a plotting backend
plot(sol)</code></pre><p>If you are in Juno, this will plot to the plot pane. To open an interactive GUI (dependent on the backend), use the <code>gui</code> command:</p><pre><code class="language-julia">gui()</code></pre><p>The plot function can be formatted using <a href="https://juliaplots.github.io/">the attributes available in Plots.jl</a>. For more of an introduction to plotting solutions, <a href="http://nbviewer.jupyter.org/github/JuliaDiffEq/DiffEqTutorials.jl/blob/master/Plotting/Formatting%20the%20Plots.ipynb">see the IJulia notebook</a>.</p><h3><a class="nav-anchor" id="Other-Algorithms-1" href="#Other-Algorithms-1">Other Algorithms</a></h3><p>DifferentialEquations.jl offers a much wider variety of solver algorithms than traditional differential equations libraries. Many of these algorithms are from recent research and have been shown to be more efficient than the &quot;standard&quot; algorithms (which are also available). For example, we can choose a 7th order Verner Efficient method:</p><pre><code class="language-julia">sol = solve(prob,Vern7)
plot(sol,title=&quot;Solving using the Vern7 Method&quot;)</code></pre><p><img src="../assets/introODEplot.png" alt="Better ODE Solution"/></p><p>Because these advanced algorithms may not be known to most users, DifferentialEquations.jl offers an advanced method for choosing algorithm defaults. This algorithm utilizes the precisions of the number types and the keyword arguments (such as the tolerances) to select an algorithm. Additionally one can provide <code>alg_hints</code> to help choose good defaults using properties of the problem and necessary features for the solution. For example, if we have a stiff problem but don&#39;t know the best stiff algorithm for this problem, we can use</p><pre><code class="language-julia">sol = solve(prob,alg_hints=[:stiff])</code></pre><p><a href="../solvers/ode_solve.html">Please see the solver documentation for details on the algorithms and recommendations</a>.</p><h3><a class="nav-anchor" id="Systems-of-Equations-1" href="#Systems-of-Equations-1">Systems of Equations</a></h3><p>We can also solve systems of equations. DifferentialEquations.jl can handle many different independent variable types (generally, anything with a linear index should work!). So instead of showing solving a vector equation, let&#39;s let u be a matrix! To do this, we simply need to have u₀ be a matrix, and define f such that it takes in a matrix and outputs a matrix. We can define a matrix of linear ODEs as follows:</p><pre><code class="language-julia">A = [1. 0 0 -5
     4 -2 4 -3
     -4 0 0 1
     5 -2 2 3]
u0 = rand(4,2)
tspan = (0.0,1.0)
f(t,u) = A*u
prob = ODEProblem(f,u0,tspan)</code></pre><p>Here our ODE is on a 4x2 matrix, and the ODE is the linear system defined by multiplication by <code>A</code>. To solve the ODE, we do the same steps as before.</p><pre><code class="language-julia">sol = solve(prob)
plot(sol)</code></pre><p><img src="../assets/multiODEplot.png" alt="ODE System Solution"/></p><p>Note that the analysis tools generalize over to systems of equations as well.</p><pre><code class="language-julia">sol[4]</code></pre><p>still returns the solution at the fourth timestep. It also indexes into the array as well.</p><pre><code class="language-julia">sol[3,5]</code></pre><p>is the value of the 5th component (by linear indexing) at the 3rd timepoint, or</p><pre><code class="language-julia">sol[:,2,1]</code></pre><p>is the timeseries for the component which is the 2nd row and 1 column.</p><h3><a class="nav-anchor" id="In-Place-Updates-1" href="#In-Place-Updates-1">In-Place Updates</a></h3><p>Defining your ODE function to be in-place updating can have performance benefits. That this means is that, instead of writing a function which outputs its solution, write a function which updates a vector that is designated to hold the solution. By doing this, DifferentialEquations.jl&#39;s solver packages are able to reduce the amount of array allocations and achieve better performance.</p><p>For our example we will use <a href="https://en.wikipedia.org/wiki/Lorenz_system">the Lorenz system</a>. What we do is simply write the output to the 3rd input of the function. For example:</p><pre><code class="language-julia">function lorenz(t,u,du)
 du[1] = 10.0(u[2]-u[1])
 du[2] = u[1]*(28.0-u[3]) - u[2]
 du[3] = u[1]*u[2] - (8/3)*u[3]
end</code></pre><p>and then we can use this function in a problem:</p><pre><code class="language-julia">u0 = [1.0;0.0;0.0]
tspan = (0.0,1.0)
prob = ODEProblem(lorenz,u0,tspan)
sol = solve(prob)</code></pre><p><img src="../assets/lorenzplot.png" alt="Lorenz System"/></p><h3><a class="nav-anchor" id="Defining-Systems-of-Equations-Using-ParameterizedFunctions.jl-1" href="#Defining-Systems-of-Equations-Using-ParameterizedFunctions.jl-1">Defining Systems of Equations Using ParameterizedFunctions.jl</a></h3><p>To simplify your life, ParameterizedFunctions.jl provides the <code>@ode_def</code> macro for &quot;defining your ODE in pseudocode&quot; and getting a function which is efficient and runnable.</p><p>To use the macro, you write out your system of equations with the left-hand side being <code>d_</code> and those variables will be parsed as the independent variables. The dependent variable is <code>t</code>, and the other variables are parameters which you pass at the end. For example, we can write the Lorenz system as:</p><pre><code class="language-julia">using ParameterizedFunctions
g = @ode_def Lorenz begin
  dx = σ*(y-x)
  dy = x*(ρ-z) - y
  dz = x*y - β*z
end σ=&gt;10.0 ρ=&gt;28.0 β=(8/3)</code></pre><p>DifferentialEquations.jl will automatically translate this to be exactly the same as <code>f</code>. The result is more legible code with no performance loss. The result is that <code>g</code> is a function which you can now use to define the Lorenz problem.</p><pre><code class="language-julia">u0 = [1.0;0.0;0.0]
tspan = (0.0,1.0)
prob = ODEProblem(g,u0,tspan)</code></pre><p>Since we used <code>=&gt;</code>, <code>σ</code> and <code>ρ</code> are kept as mutable parameters. For example we can do:</p><pre><code class="language-julia">g.σ = 11.0</code></pre><p>to change the value of <code>σ</code> to 11.0. <code>β</code> is not able to be changed since we defined it using <code>=</code>. We can create a new instance with new parameters via the name used in the <code>@ode_def</code> command:</p><pre><code class="language-julia">h = Lorenz(σ=11.0,ρ=25.0)</code></pre><p>Note that the values will default to the values giving in the <code>@ode_def</code> command.</p><p>One last item to note is that you probably received a warning when defining this:</p><pre><code class="language-julia">WARNING: Hessian could not invert</code></pre><p>This is because the Hessian of the system was not able to be inverted. ParameterizedFunctions.jl does &quot;behind-the-scenes&quot; symbolic calculations to pre-compute things like the Jacobian, inverse Jacobian, etc. in order to speedup calculations. Thus not only will this lead to legible ODE definitions, but &quot;unfairly fast&quot; code! We can turn off some of the calculations by using a more specific macro. Here, we can turn off the Hessian calculations via <code>@ode_def_nohes</code>. See <a href="https://github.com/JuliaDiffEq/ParameterizedFunctions.jl">ParameterizedFunctions.jl</a> for more details.</p><p>Since the parameters exist within the function, functions defined in this manner can also be used for sensitivity analysis, parameter estimation routines, and bifurcation plotting. This makes DifferentialEquations.jl a full-stop solution for differential equation analysis which also achieves high performance.</p><footer><hr/><a class="previous" href="../index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="sde_example.html"><span class="direction">Next</span><span class="title">Stochastic Differential Equations (SDE)</span></a></footer></article></body></html>
