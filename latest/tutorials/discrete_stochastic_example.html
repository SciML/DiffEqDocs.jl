<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Discrete Stochastic (Gillespie) Equations · DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="dae_example.html">Differential Algebraic Equations</a></li><li class="current"><a class="toctext" href="discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a><ul class="internal"><li><a class="toctext" href="#Defining-a-Model-using-Reactions-1">Defining a Model using Reactions</a></li><li><a class="toctext" href="#Building-and-Solving-the-Problem-1">Building and Solving the Problem</a></li><li><a class="toctext" href="#Using-the-Reaction-Network-DSL-1">Using the Reaction Network DSL</a></li><li><a class="toctext" href="#Defining-the-Jumps-Directly-1">Defining the Jumps Directly</a></li><li><a class="toctext" href="#Adding-Jumps-to-a-Differential-Equation-1">Adding Jumps to a Differential Equation</a></li><li><a class="toctext" href="#Adding-a-VariableRateReaction-1">Adding a VariableRateReaction</a></li></ul></li><li><a class="toctext" href="jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="fempoisson_example.html">Poisson Equation Finite Element Method</a></li><li><a class="toctext" href="femheat_example.html">Heat Equation Finite Element Method</a></li><li><a class="toctext" href="femstochastic_example.html">Stochastic Finite Element Method</a></li><li><a class="toctext" href="bvp_example.html">Boundary Value Problems</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li><li><a class="toctext" href="../basics/integrator.html">Integrator Interface</a></li><li><a class="toctext" href="../basics/compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Problems</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Problems</a></li><li><a class="toctext" href="../types/dynamical_types.html">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../types/split_ode_types.html">Split ODE Problems</a></li><li><a class="toctext" href="../types/steady_state_types.html">Steady State Problems</a></li><li><a class="toctext" href="../types/bvp_types.html">BVP Problems</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Problems</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Problems</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Problems</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Problems</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Problems</a></li><li><a class="toctext" href="../types/fem_types.html">FEM Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../solvers/discrete_solve.html">Discrete Solvers</a></li><li><a class="toctext" href="../solvers/ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="../solvers/dynamical_solve.html">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="../solvers/split_ode_solve.html">Split ODE Solvers</a></li><li><a class="toctext" href="../solvers/steady_state_solve.html">Steady State Solvers</a></li><li><a class="toctext" href="../solvers/bvp_solve.html">BVP Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="../solvers/rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="../solvers/dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="../solvers/dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="../solvers/fempoisson_solve.html">FEM Poisson Solvers</a></li><li><a class="toctext" href="../solvers/femheat_solve.html">FEM Heat Solvers</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="../features/performance_overloads.html">Performance Overloads</a></li><li><a class="toctext" href="../features/diffeq_arrays.html">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="../features/diffeq_operator.html">DiffEqOperators</a></li><li><a class="toctext" href="../features/noise_process.html">Noise Processes</a></li><li><a class="toctext" href="../features/linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="../features/callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="../features/callback_library.html">Callback Library</a></li><li><a class="toctext" href="../features/monte_carlo.html">Parallel Monte Carlo Simulations</a></li><li><a class="toctext" href="../features/io.html">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="../features/low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="../features/mesh.html">Meshes</a></li><li><a class="toctext" href="../features/progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../analysis/parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="../analysis/parameter_estimation.html">Parameter Estimation</a></li><li><a class="toctext" href="../analysis/bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="../analysis/sensitivity.html">Sensitivity Analysis</a></li><li><a class="toctext" href="../analysis/uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="../analysis/dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/physical.html">Physical Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Chemical Reaction Models</a></li><li><a class="toctext" href="../models/external_modeling.html">External Modeling Packages</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href="discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/blob/master/docs/src/tutorials/discrete_stochastic_example.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Discrete Stochastic (Gillespie) Equations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Discrete-Stochastic-(Gillespie)-Equations-1" href="#Discrete-Stochastic-(Gillespie)-Equations-1">Discrete Stochastic (Gillespie) Equations</a></h1><p>In this tutorial we will describe how to define and solve discrete stochastic simulations, also known in biological fields as Gillespie-type models. This tutorial assumes you have read the <a href="ode_example.html">Ordinary Differential Equations tutorial</a>. Discrete stochastic simulations are a form of jump equation with a &quot;trivial&quot; (non-existent) differential equation. We will first demonstrate how to build these types of models using the biological modeling functionality, and then describe how to build it directly and more generally using jumps, and finally show how to add discrete stochastic simulations to differential equation models.</p><h2><a class="nav-anchor" id="Defining-a-Model-using-Reactions-1" href="#Defining-a-Model-using-Reactions-1">Defining a Model using Reactions</a></h2><p>For our example, we will build an SIR model which matches the tutorial from <a href="https://github.com/sdwfrost/Gillespie.jl">Gillespie.jl</a>. SIR stands for susceptible, infected, and recovered, and is a model is disease spread. When a susceptible person comes in contact with an infected person, the disease has a chance of infecting the susceptible person. This &quot;chance&quot; is determined by the number of susceptible persons and the number of infected persons, since when there are more people there is a greater chance that two come in contact. Normally, the rate is modeled as the amount</p><pre><code class="language-julia">rate_constant*num_of_susceptible_people*num_of_infected_people</code></pre><p>The <code>rate_constant</code> is some constant determined by other factors like the type of the disease.</p><p>Let&#39;s build our model using a vector <code>u</code>, and let <code>u[1]</code> be the number of susceptible persons, <code>u[2]</code> be the number of infected persons, and <code>u[3]</code> be the number of recovered persons. In this case, we can re-write our rate as being:</p><pre><code class="language-julia">rate_constant*u[1]*u[2]</code></pre><p>Thus we have that our &quot;reactants&quot; are components 1 and 2. When this &quot;reaction&quot; occurs, the result is that one susceptible person turns into an infected person. We can think of this as doing:</p><pre><code class="language-julia">u[1] -= 1
u[2] += 1</code></pre><p>that is, we decrease the number of susceptible persons by 1 and increase the number of infected persons by 1.</p><p>These are the facts that are required to build a <code>Reaction</code>. The constructor for a <code>Reaction</code> is as follows:</p><pre><code class="language-julia">Reaction(rate_constant,reactants,stoichiometry)</code></pre><p>The first value is the rate constant. We will use <code>1e-4</code>. Secondly, we pass in the indices for the reactants. In this case, since it uses the susceptible and infected persons, the indices are <code>[1,2]</code>. Lastly, we detail the stoichometric changes. These are tuples <code>(i,j)</code> where <code>i</code> is the reactant and <code>j</code> is the number to change by. Thus <code>(1,-1)</code> means &quot;decrease the number of susceptible persons by 1&quot; and <code>(2,1)</code> means &quot;increase the number of infected persons by 1&quot;.</p><p>Therefore, in total, our reaction is:</p><pre><code class="language-julia">r1 = Reaction(1e-4,[1,2],[(1,-1),(2,1)])</code></pre><p>To finish the model, we define one more reaction. Over time, infected people become less infected. The chance that any one person heals during some time unit depends on the number of people who are infected. Thus the rate at which infected persons are turning into recovered persons is</p><pre><code class="language-julia">rate_constant*u[2]</code></pre><p>When this happens, we lose one infected person and gain a recovered person. This reaction is thus modeled as:</p><pre><code class="language-julia">r2 = Reaction(0.01,[2],[(2,-1),(3,1)])</code></pre><p>where we have chosen the rate constant <code>0.01</code>.</p><h2><a class="nav-anchor" id="Building-and-Solving-the-Problem-1" href="#Building-and-Solving-the-Problem-1">Building and Solving the Problem</a></h2><p>First, we have to define some kind of differential equation. Since we do not want any continuous changes, we will build a <code>DiscreteProblem</code>. We do this by giving the constructor <code>u0</code>, the initial condition, and <code>tspan</code>, the timespan. Here, we will start with <code>999</code> susceptible people, <code>1</code> infected person, and <code>0</code> recovered people, and solve the problem from <code>t=0.0</code> to <code>t=250.0</code>. Thus we build the problem via:</p><pre><code class="language-julia">prob = DiscreteProblem([999,1,0],(0.0,250.0))</code></pre><p>Now we have to add the reactions/jumps to the problem. We do this using a <code>GillespieProblem</code>. This takes in a differential equation problem <code>prob</code> (which we just defined), a <code>ConstantJumpAggregator</code>, and the reactions. The <code>ConstantJumpAggregator</code> is the method by which the constant jumps are aggregated together and solved. In this case we will use the classic Direct method due to Gillespie, also known as GillespieSSA. This aggregator is denoted by <code>Direct()</code>. Thus we build the jumps into the problem via:</p><pre><code class="language-julia">jump_prob = GillespieProblem(prob,Direct(),r1,r2)</code></pre><p>This is now a problem that can be solved using the differential equations solvers. Since our problem is discrete, we will use the <code>Discrete()</code> method.</p><pre><code class="language-julia">sol = solve(jump_prob,Discrete())</code></pre><p>This solve command takes the standard commands of the common interface, and the solution object acts just like any other differential equation solution. Thus there exists a plot recipe, which we can plot with:</p><pre><code class="language-julia">using Plots; plot(sol)</code></pre><p><img src="../assets/gillespie_solution.png" alt="gillespie_solution"/></p><h2><a class="nav-anchor" id="Using-the-Reaction-Network-DSL-1" href="#Using-the-Reaction-Network-DSL-1">Using the Reaction Network DSL</a></h2><p>Also included as part of DiffEqBiological.jl is the reaction network DSL. We could define the previous problem via:</p><pre><code class="language-julia">rs = @reaction_network begin
  1e-4, S + I --&gt; 2I
  0.01,  I --&gt; R
end
prob = DiscreteProblem([999,1,0],(0.0,250.0))
jump_prob = GillespieProblem(prob,Direct(),rs)
sol = solve(jump_prob,Discrete())</code></pre><h2><a class="nav-anchor" id="Defining-the-Jumps-Directly-1" href="#Defining-the-Jumps-Directly-1">Defining the Jumps Directly</a></h2><p>Instead of using the biological modeling functionality of <code>Reaction</code>, we can directly define jumps. This allows for more general types of rates, at the cost of some modeling friendliness. The constructor for a <code>ConstantRateJump</code> is:</p><pre><code class="language-julia">jump = ConstantRateJump(rate,affect!)</code></pre><p>where <code>rate</code> is a function <code>rate(t,u)</code> and <code>affect!</code> is a function of the integrator <code>affect!(integrator)</code> (for details on the integrator, see the <a href="http://docs.juliadiffeq.org/latest/basics/integrator.html">integrator interface docs</a>). Thus, to define the jump equivalents to the above reactions, we can use:</p><pre><code class="language-julia">rate(t,u) = (0.1/1000.0)*u[1]*u[2]
function affect!(integrator)
  integrator.u[1] -= 1
  integrator.u[2] += 1
end
jump = ConstantRateJump(rate,affect!)

rate(t,u) = 0.01u[2]
function affect!(integrator)
  integrator.u[2] -= 1
  integrator.u[3] += 1
end
jump2 = ConstantRateJump(rate,affect!)</code></pre><p>We can then use <code>JumpProblem</code> to augment a problem with jumps. To add the jumps to the <code>DiscreteProblem</code> and solve it, we would simply do:</p><pre><code class="language-julia">jump_prob = JumpProblem(prob,Direct(),jump,jump2)
sol = solve(jump_prob,Discrete(apply_map=false))</code></pre><h2><a class="nav-anchor" id="Adding-Jumps-to-a-Differential-Equation-1" href="#Adding-Jumps-to-a-Differential-Equation-1">Adding Jumps to a Differential Equation</a></h2><p>Notice that if we instead used some form of differential equation instead of a <code>DiscreteProblem</code>, we would add the jumps/reactions to the differential equation. Let&#39;s define an ODE problem, where the continuous part only acts on some new 4th component:</p><pre><code class="language-julia">function f(t,u,du)
  du[4] = u[2]*u[3]/100000 - u[1]*u[2]/100000
end

prob = ODEProblem(f,[999.0,1.0,0.0,100.0],(0.0,250.0))</code></pre><p>Notice we gave the 4th component a starting value of 100. The same steps as above will thus solve this hybrid equation. For example, we can solve it using the <code>Tsit5()</code> method via:</p><pre><code class="language-julia">jump_prob = GillespieProblem(prob,Direct(),r1,r2)
sol = solve(jump_prob,Tsit5())</code></pre><p><img src="../assets/gillespie_ode.png" alt="gillespie_ode"/></p><h3><a class="nav-anchor" id="Caution-about-Constant-Rate-Jumps-1" href="#Caution-about-Constant-Rate-Jumps-1">Caution about Constant Rate Jumps</a></h3><p>Note that the assumption which is required for constant rate jumps is that their reaction rates must be constant on the interval between any constant rate jumps. Thus in the examples above,</p><pre><code class="language-julia">rate(t,u) = (0.1/1000.0)*u[1]*u[2]
rate(t,u) = 0.01u[2]</code></pre><p>both must be constant other than changes due to some constant rate jump (the same applies to reactions). Since these rates only change when <code>u[1]</code> or <code>u[2]</code> is changed, and <code>u[1]</code> and <code>u[2]</code> only change when one of the jumps occur, this setup is valid. However, <code>t*(0.1/1000.0)*u[1]*u[2]</code> would not be valid because the rate would change during the interval, as would <code>(0.1/1000.0)*u[1]*u[4]</code>. Thus one must be careful about to follow this rule when choosing rates.</p><p>(but note that it&#39;s okay for <code>u[4]</code> to depend on the other variables because its updated in a continuous manner!)</p><p>If your problem must have the rates depend on a continuously changing quantity, you need to use the <code>VariableRateJump</code> or <code>VariableRateReaction</code> instead.</p><h2><a class="nav-anchor" id="Adding-a-VariableRateReaction-1" href="#Adding-a-VariableRateReaction-1">Adding a VariableRateReaction</a></h2><p>Now let&#39;s consider adding a reaction whose rate changes continuously with the differential equation. To continue our example, let&#39;s let there be a new reaction which has the same effect as <code>r2</code>, but now is dependent on the amount of <code>u[4]</code>.</p><pre><code class="language-julia">r3 = VariableRateReaction(1e-2,[4],[(2,-1),(3,1)])</code></pre><p>We would expect this reaction to increase the amount of transitions from state 2 to 3. Solving the equation is exactly the same:</p><pre><code class="language-julia">prob = ODEProblem(f,[999.0,1.0,0.0,1.0],(0.0,250.0))
jump_prob = GillespieProblem(prob,Direct(),r1,r2,r3)
sol = solve(jump_prob,Tsit5())</code></pre><p><img src="../assets/variable_rate_gillespie.png" alt="variable_rate_gillespie"/></p><p>Notice that this increases the amount of 3 at the end, reducing the falloff in the rate (though this model is kind of nonsensical).</p><p>Note that even if the problem is a <code>DiscreteProblem</code>, <code>VariableRateJump</code>s and <code>VariableRateReaction</code>s require a continuous solver, like an ODE/SDE/DDE/DAE solver.</p><p>Lastly, we are not restricted to ODEs. For example, we can solve the same jump problem except with multiplicative noise on <code>u[4]</code> by using an <code>SDEProblem</code> instead:</p><pre><code class="language-julia">function g(t,u,du)
  du[4] = 0.1u[4]
end

prob = SDEProblem(f,g,[999.0,1.0,0.0,1.0],(0.0,250.0))
jump_prob = GillespieProblem(prob,Direct(),r1,r2,r3)
sol = solve(jump_prob,SRIW1())</code></pre><p><img src="../assets/sde_gillespie.png" alt="sde_gillespie"/></p><footer><hr/><a class="previous" href="dae_example.html"><span class="direction">Previous</span><span class="title">Differential Algebraic Equations</span></a><a class="next" href="jump_diffusion.html"><span class="direction">Next</span><span class="title">Jump Diffusion Equations</span></a></footer></article></body></html>
