<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solution Handling · DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/fempoisson_example.html">Poisson Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femheat_example.html">Heat Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femstochastic_example.html">Stochastic Finite Element Method</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="common_solver_opts.html">Common Solver Options</a></li><li class="current"><a class="toctext" href="solution.html">Solution Handling</a><ul class="internal"><li><a class="toctext" href="#Accessing-the-Values-1">Accessing the Values</a></li><li><a class="toctext" href="#Array-Interface-1">Array Interface</a></li><li><a class="toctext" href="#Interpolations-1">Interpolations</a></li><li><a class="toctext" href="#Comprehensions-1">Comprehensions</a></li><li><a class="toctext" href="#Special-Fields-1">Special Fields</a></li><li><a class="toctext" href="#Return-Codes-(RetCodes)-1">Return Codes (RetCodes)</a></li><li><a class="toctext" href="#Problem-Specific-Features-1">Problem-Specific Features</a></li></ul></li><li><a class="toctext" href="plot.html">Plot Functions</a></li><li><a class="toctext" href="integrator.html">Integrator Interface</a></li><li><a class="toctext" href="compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Equation Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Types</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Types</a></li><li><a class="toctext" href="../types/refined_ode_types.html">Refined ODE Types</a></li><li><a class="toctext" href="../types/steady_state_types.html">Steady State Types</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Types</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Types</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Types</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Types</a></li><li><a class="toctext" href="../types/refined_dae_types.html">Refined DAE Types</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Types</a></li><li><a class="toctext" href="../types/fem_types.html">FEM Types</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../solvers/discrete_solve.html">Discrete Solvers</a></li><li><a class="toctext" href="../solvers/ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="../solvers/refined_ode_solve.html">Refined ODE Solvers</a></li><li><a class="toctext" href="../solvers/steady_state_solve.html">Steady State Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="../solvers/rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="../solvers/dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="../solvers/dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="../solvers/fempoisson_solve.html">FEM Poisson Solvers</a></li><li><a class="toctext" href="../solvers/femheat_solve.html">FEM Heat Solvers</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="../features/performance_overloads.html">Performance Overloads</a></li><li><a class="toctext" href="../features/diffeq_arrays.html">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="../features/noise_process.html">Noise Processes</a></li><li><a class="toctext" href="../features/linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="../features/callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="../features/callback_library.html">Callback Library</a></li><li><a class="toctext" href="../features/monte_carlo.html">Parallel Monte Carlo Simulations</a></li><li><a class="toctext" href="../features/low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="../features/mesh.html">Meshes</a></li><li><a class="toctext" href="../features/progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../analysis/parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="../analysis/parameter_estimation.html">Parameter Estimation</a></li><li><a class="toctext" href="../analysis/bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="../analysis/sensitivity.html">Sensitivity Analysis</a></li><li><a class="toctext" href="../analysis/uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="../analysis/dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Biological Models</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Basics</li><li><a href="solution.html">Solution Handling</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/tree/6836aaaf16d8dc82066ac376caaa7cd841edb486/docs/src/basics/solution.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Solution-Handling-1" href="#Solution-Handling-1">Solution Handling</a></h1><h2><a class="nav-anchor" id="Accessing-the-Values-1" href="#Accessing-the-Values-1">Accessing the Values</a></h2><p>The solution type has a lot of built in functionality to help analysis. For example, it has an array interface for accessing the values. Internally, the solution type has two important fields:</p><ol><li><p><code>u</code> which holds the Vector of values at each timestep</p></li><li><p><code>t</code> which holds the times of each timestep.</p></li></ol><p>Different solution types may add extra information as necessary, such as the derivative at each timestep <code>du</code> or the spatial discretization <code>x</code>, <code>y</code>, etc.</p><h2><a class="nav-anchor" id="Array-Interface-1" href="#Array-Interface-1">Array Interface</a></h2><p>Instead of working on the <code>Vector{uType}</code> directly, we can use the provided array interface.</p><pre><code class="language-julia">sol[i]</code></pre><p>to access the value at timestep <code>i</code> (if the timeseries was saved), and</p><pre><code class="language-julia">sol.t[i]</code></pre><p>to access the value of <code>t</code> at timestep <code>i</code>. For multi-dimensional systems, this will address first by component and lastly by time, and thus</p><pre><code class="language-julia">sol[i,j]</code></pre><p>will be the <code>i</code>th component at timestep <code>j</code>. If the independent variables had shape (for example, was a matrix), then <code>i</code> is the linear index. We can also access solutions with shape:</p><pre><code class="language-julia">sol[i,j,k]</code></pre><p>gives the <code>[i,j]</code> component of the system at timestep <code>k</code>. The colon operator is supported, meaning that</p><pre><code class="language-julia">sol[j,:]</code></pre><p>gives the timeseries for the <code>j</code>th component.</p><h2><a class="nav-anchor" id="Interpolations-1" href="#Interpolations-1">Interpolations</a></h2><p>If the solver allows for dense output and <code>dense=true</code> was set for the solving (which is the default), then we can access the approximate value at a time <code>t</code> using the command</p><pre><code class="language-julia">sol(t)</code></pre><p>Note that the interpolating function allows for <code>t</code> to be a vector and uses this to speed up the interpolation calculations. The full API for the interpolations is</p><pre><code class="language-julia">sol(t,deriv=Val{0};idxs=nothing)</code></pre><p>The optional argument <code>deriv</code> lets you choose the number <code>n</code> derivative to solve the interpolation for, defaulting with <code>n=0</code>. Note that most of the derivatives have not yet been implemented (though it&#39;s not hard, it just has to be done by hand for each algorithm. Open an issue if there&#39;s a specific one you need). <code>idxs</code> allows you to choose the indices the interpolation should solve for. For example,</p><pre><code class="language-julia">sol(t,idxs=1:2:5)</code></pre><p>will return a <code>Vector</code> of length 3 which is the interpolated values at <code>t</code> for components <code>1</code>, <code>3</code>, and <code>5</code>. <code>idxs=nothing</code>, the default, means it will return every component. In addition, we can do</p><pre><code class="language-julia">sol(t,idxs=1)</code></pre><p>and it will return a <code>Number</code> for the interpolation of the single value. Note that this interpolation only computes the values which are requested, and thus it&#39;s much faster on large systems to use this rather than computing the full interpolation and using only a few values.</p><p>In addition, there is an inplace form:</p><pre><code class="language-julia">sol(out,t,deriv=Val{0};idxs=nothing)</code></pre><p>which will write the output to <code>out</code>. This allows one to use pre-allocated vectors for the output to improve the speed even more.</p><h2><a class="nav-anchor" id="Comprehensions-1" href="#Comprehensions-1">Comprehensions</a></h2><p>The solver interface also gives tools for using comprehensions over the solution. Using the <code>tuples(sol)</code> function, we can get a tuple for the output at each timestep. This allows one to do the following:</p><pre><code class="language-julia">[t+2u for (t,u) in tuples(sol)]</code></pre><p>One can use the extra components of the solution object as well as using <code>zip</code>. For example, say the solution type holds <code>du</code>, the derivative at each timestep. One can comprehend over the values using:</p><pre><code class="language-julia">[t+3u-du for (t,u,du) in zip(sol.t,sol.u,sol.du)]</code></pre><p>Note that the solution object acts as a vector in time, and so its length is the number of saved timepoints.</p><h2><a class="nav-anchor" id="Special-Fields-1" href="#Special-Fields-1">Special Fields</a></h2><p>The solution interface also includes some special fields. The problem object <code>prob</code> and the algorithm used to solve the problem <code>alg</code> are included in the solution. Additionally, the field <code>dense</code> is a boolean which states whether the interpolation functionality is available. Lastly, there is a mutable state <code>tslocation</code> which controls the plot recipe behavior. By default, <code>tslocation=0</code>. Its values have different meanings between partial and ordinary differential equations:</p><ul><li><p><code>tslocation=0</code>  for non-spatial problems (ODEs) means that the plot recipe will plot the full solution. <code>tslocation=i</code> means that it will only plot the timepoint <code>i</code>.</p></li><li><p><code>tslocation=0</code> for spatial problems (PDEs) means the plot recipe will plot the final timepoint. <code>tslocation=i</code> means that the plot recipe will plot the <code>i</code>th timepoint.</p></li></ul><p>What this means is that for ODEs, the plots will default to the full plot and PDEs will default to plotting the surface at the final timepoint. The iterator interface simply iterates the value of <code>tslocation</code>, and the <code>animate</code> function iterates the solution calling solve at each step.</p><h2><a class="nav-anchor" id="Return-Codes-(RetCodes)-1" href="#Return-Codes-(RetCodes)-1">Return Codes (RetCodes)</a></h2><p>The solution types have a <code>retcode</code> field which returns a symbol signifying the error state of the solution. The retcodes are as follows:</p><ul><li><p><code>:Default</code>: The solver did not set retcodes.</p></li><li><p><code>:Success</code>: The integration completed without erroring.</p></li><li><p><code>:MaxIters</code>: The integration exited early because it reached its maximum number of iterations.</p></li><li><p><code>:DtLessThanMin</code>: The timestep method chose a stepsize which is smaller than the allowed minimum timestep, and exited early.</p></li><li><p><code>:Unstable</code>: The solver detected that the solution was unstable and exited early.</p></li></ul><h2><a class="nav-anchor" id="Problem-Specific-Features-1" href="#Problem-Specific-Features-1">Problem-Specific Features</a></h2><p>Extra fields for solutions of specific problems are specified in the appropriate problem definition page.  </p><footer><hr/><a class="previous" href="common_solver_opts.html"><span class="direction">Previous</span><span class="title">Common Solver Options</span></a><a class="next" href="plot.html"><span class="direction">Next</span><span class="title">Plot Functions</span></a></footer></article></body></html>
