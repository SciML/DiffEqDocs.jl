<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DiffEq-Specific Array Types · DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/bvp_example.html">Boundary Value Problems</a></li><li><a class="toctext" href="../tutorials/additional.html">Additional Tutorials</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li><li><a class="toctext" href="../basics/integrator.html">Integrator Interface</a></li><li><a class="toctext" href="../basics/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../basics/compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Problems</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Problems</a></li><li><a class="toctext" href="../types/dynamical_types.html">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../types/split_ode_types.html">Split ODE Problems</a></li><li><a class="toctext" href="../types/steady_state_types.html">Steady State Problems</a></li><li><a class="toctext" href="../types/bvp_types.html">BVP Problems</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Problems</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Problems</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Problems</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Problems</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../solvers/discrete_solve.html">Discrete Solvers</a></li><li><a class="toctext" href="../solvers/ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="../solvers/dynamical_solve.html">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="../solvers/split_ode_solve.html">Split ODE Solvers</a></li><li><a class="toctext" href="../solvers/steady_state_solve.html">Steady State Solvers</a></li><li><a class="toctext" href="../solvers/bvp_solve.html">BVP Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="../solvers/rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="../solvers/dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="../solvers/dae_solve.html">DAE Solvers</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="performance_overloads.html">Performance Overloads</a></li><li class="current"><a class="toctext" href="diffeq_arrays.html">DiffEq-Specific Array Types</a><ul class="internal"><li><a class="toctext" href="#ArrayPartitions-1">ArrayPartitions</a></li><li><a class="toctext" href="#MultiScaleArrays-1">MultiScaleArrays</a></li><li><a class="toctext" href="#DEDataArrays-1">DEDataArrays</a></li></ul></li><li><a class="toctext" href="diffeq_operator.html">DiffEqOperators</a></li><li><a class="toctext" href="noise_process.html">Noise Processes</a></li><li><a class="toctext" href="linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="callback_library.html">Callback Library</a></li><li><a class="toctext" href="monte_carlo.html">Parallel Monte Carlo Simulations</a></li><li><a class="toctext" href="io.html">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../analysis/parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="../analysis/parameter_estimation.html">Parameter Estimation</a></li><li><a class="toctext" href="../analysis/bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="../analysis/sensitivity.html">Sensitivity Analysis</a></li><li><a class="toctext" href="../analysis/uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="../analysis/dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/physical.html">Physical Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Chemical Reaction Models</a></li><li><a class="toctext" href="../models/external_modeling.html">External Modeling Packages</a></li></ul></li><li><span class="toctext">Extra Details</span><ul><li><a class="toctext" href="../extras/timestepping.html">Timestepping Method Descriptions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Additional Features</li><li><a href="diffeq_arrays.html">DiffEq-Specific Array Types</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/blob/master/docs/src/features/diffeq_arrays.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>DiffEq-Specific Array Types</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="DiffEq-Specific-Array-Types-1" href="#DiffEq-Specific-Array-Types-1">DiffEq-Specific Array Types</a></h1><p>In many cases, a standard array may not be enough to fully hold the data for a model. Many of the solvers in DifferentialEquations.jl (only the native Julia methods) allow you to solve problems on <code>AbstractArray</code> types which allow you to extend the meaning of an array. This page describes some of the <code>AbstractArray</code> types which can be helpful for modeling differential equations problems.</p><h2><a class="nav-anchor" id="ArrayPartitions-1" href="#ArrayPartitions-1">ArrayPartitions</a></h2><p>ArrayPartitions in DiffEq are used for heterogeneous arrays. For example, <code>PartitionedODEProblem</code> solvers use them internally to turn the separate parts into a single array. You can construct an <code>ArrayPartition</code> using RecursiveArrayTools.jl:</p><pre><code class="language-julia">using RecursiveArrayTools
A = ArrayPartition(x::AbstractArray...)</code></pre><p>where is <code>x</code> a list of arrays. The resulting <code>A</code> will act like a single array, and its broadcast will be type stable, allowing for it to be used inside of the native Julia DiffEq solvers in an efficient way. This is a good way to generate an array which has different units for different parts, or different amounts of precision.</p><h3><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h3><p>An <code>ArrayPartition</code> acts like a single array. <code>A[i]</code> indexes through the first array, then the second, etc. all linearly. But <code>A.x</code> is where the arrays are stored. Thus for</p><pre><code class="language-julia">using RecursiveArrayTools
A = ArrayPartition(y,z)</code></pre><p>We would have <code>A.x[1]==y</code> and <code>A.x[2]==z</code>. Broadcasting like <code>f.(A)</code> is efficient.</p><h3><a class="nav-anchor" id="Example:-Dynamics-Equations-1" href="#Example:-Dynamics-Equations-1">Example: Dynamics Equations</a></h3><p>In this example we will show using heterogeneous units in dynamics equations. Our arrays will be:</p><pre><code class="language-julia">using Unitful, RecursiveArrayTools, DiffEqBase, OrdinaryDiffEq

r0 = [1131.340, -2282.343, 6672.423]u&quot;km&quot;
v0 = [-5.64305, 4.30333, 2.42879]u&quot;km/s&quot;
Δt = 86400.0*365u&quot;s&quot;
mu = 398600.4418u&quot;km^3/s^2&quot;
rv0 = ArrayPartition(r0,v0)</code></pre><p>Here, <code>r0</code> is the initial positions, and <code>v0</code> are the initial velocities. <code>rv0</code> is the <code>ArrayPartition</code> initial condition. We now write our update function in terms of the <code>ArrayPartition</code>:</p><pre><code class="language-julia">function f(t, y, dy, μ)
    r = norm(y.x[1])
    dy.x[1] .= y.x[2]
    dy.x[2] .= -μ .* y.x[1] / r^3
end</code></pre><p>Notice that <code>y.x[1]</code> is the <code>r</code> part of <code>y</code>, and <code>y.x[2]</code> is the <code>v</code> part of <code>y</code>. Using this kind of indexing is type stable, even though the array itself is heterogeneous. Note that one can also use things like <code>2y</code> or <code>y.+x</code> and the broadcasting will be efficient.</p><p>Now to solve our equations, we do the same thing as always in DiffEq:</p><pre><code class="language-julia">prob = ODEProblem((t, y, dy) -&gt; f(t, y, dy, mu), rv0, (0.0u&quot;s&quot;, Δt))
sol = solve(prob, Vern8())</code></pre><h2><a class="nav-anchor" id="MultiScaleArrays-1" href="#MultiScaleArrays-1">MultiScaleArrays</a></h2><p>The multi-scale modeling functionality is provided by MultiScaleArrays.jl. It allows for designing a multi-scale model as an extension of an array, which in turn can be directly used in the native Julia solvers of DifferentialEquations.jl.</p><p>For more information, please see <a href="https://github.com/JuliaDiffEq/MultiScaleArrays.jl">the MultiScaleArrays.jl README</a>.</p><h2><a class="nav-anchor" id="DEDataArrays-1" href="#DEDataArrays-1">DEDataArrays</a></h2><p>The <code>DEDataArray{T}</code> type allows one to add other &quot;non-continuous&quot; variables to an array, which can be useful in many modeling situations involving lots of events. To define an <code>DEDataArray</code>, make a type which subtypes <code>DEDataArray{T}</code> with a field <code>x</code> for the &quot;array of continuous variables&quot; for which you would like the differential equation to treat directly. The other fields are treated as &quot;discrete variables&quot;. For example:</p><pre><code class="language-julia">type MyDataArray{T,N} &lt;: DEDataArray{T,N}
    x::Array{T,1}
    a::T
    b::Symbol
end</code></pre><p>In this example, our resultant array is a <code>SimType</code>, and its data which is presented to the differential equation solver will be the array <code>x</code>. Any array which the differential equation solver can use is allowed to be made as the field <code>x</code>, including other <code>DEDataArray</code>s. Other than that, you can add whatever fields you please, and let them be whatever type you please.</p><p>These extra fields are carried along in the differential equation solver that the user can use in their <code>f</code> equation and modify via callbacks. For example, inside of a an update function, it is safe to do:</p><pre><code class="language-julia">function f(du,u,p,t)
  u.a = t
end</code></pre><p>to update the discrete variables (unless the algorithm notes that it does not step to the endpoint, in which case a callback must be used to update appropriately.)</p><p>Note that the aliases <code>DEDataVector</code> and <code>DEDataMatrix</code> cover the one and two dimensional cases.</p><h3><a class="nav-anchor" id="Example:-A-Control-Problem-1" href="#Example:-A-Control-Problem-1">Example: A Control Problem</a></h3><p>In this example we will use a <code>DEDataArray</code> to solve a problem where control parameters change at various timepoints. First we will build</p><pre><code class="language-julia">type SimType{T} &lt;: DEDataVector{T}
    x::Array{T,1}
    f1::T
end</code></pre><p>as our <code>DEDataVector</code>. It has an extra field <code>f1</code> which we will use as our control variable. Our ODE function will use this field as follows:</p><pre><code class="language-julia">function f(du,u,p,t)
    du[1] = -0.5*u[1] + u.f1
    du[2] = -0.5*u[2]
end</code></pre><p>Now we will setup our control mechanism. It will be a simple setup which uses set timepoints at which we will change <code>f1</code>. At <code>t=5.0</code> we will want to increase the value of <code>f1</code>, and at <code>t=8.0</code> we will want to decrease the value of <code>f1</code>. Using the <a href="callback_functions.html"><code>DiscreteCallback</code> interface</a>, we code these conditions as follows:</p><pre><code class="language-julia">const tstop1 = [5.]
const tstop2 = [8.]


function condition(u,p,t,integrator)
  t in tstop1
end

function condition2(u,p,t,integrator)
  t in tstop2
end</code></pre><p>Now we have to apply an effect when these conditions are reached. When <code>condition</code> is hit (at <code>t=5.0</code>), we will increase <code>f1</code> to 1.5. When <code>condition2</code> is reached, we will decrease <code>f1</code> to <code>-1.5</code>. This is done via the functions:</p><pre><code class="language-julia">function affect!(integrator)
  for c in user_cache(integrator)
    c.f1 = 1.5
  end
end

function affect2!(integrator)
  for c in user_cache(integrator)
    c.f1 = -1.5
  end
end</code></pre><p>Notice that we have to loop through the <code>user_cache</code> array (provided by the integrator interface) to ensure that all internal caches are also updated. With these functions we can build our callbacks:</p><pre><code class="language-julia">save_positions = (true,true)

cb = DiscreteCallback(condition, affect!, save_positions=save_positions)

save_positions = (false,true)

cb2 = DiscreteCallback(condition2, affect2!, save_positions=save_positions)

cbs = CallbackSet(cb,cb2)</code></pre><p>Now we define our initial condition. We will start at <code>[10.0;10.0]</code> with <code>f1=0.0</code>.</p><pre><code class="language-julia">u0 = SimType([10.0;10.0], 0.0)
prob = ODEProblem(f,u0,(0.0,10.0))</code></pre><p>Lastly we solve the problem. Note that we must pass <code>tstop</code> values of <code>5.0</code> and <code>8.0</code> to ensure the solver hits those timepoints exactly:</p><pre><code class="language-julia">const tstop = [5.;8.]
sol = solve(prob,Tsit5(),callback = cbs, tstops=tstop)</code></pre><p><img src="../assets/data_array.png" alt="data_array_plot"/></p><p>It&#39;s clear from the plot how the controls affected the outcome.</p><h3><a class="nav-anchor" id="Data-Arrays-vs-ParameterizedFunctions-1" href="#Data-Arrays-vs-ParameterizedFunctions-1">Data Arrays vs ParameterizedFunctions</a></h3><p>The reason for using a <code>DEDataArray</code> is because the solution will then save the control parameters. For example, we can see what the control parameter was at every timepoint by checking:</p><pre><code class="language-julia">[sol[i].f1 for i in 1:length(sol)]</code></pre><p>A similar solution can be achieved using a <code>ParameterizedFunction</code>. We could have instead created our function as:</p><pre><code class="language-julia">function f(du,u,p,t)
    du[1] = -0.5*u[1] + p
    du[2] = -0.5*u[2]
end
u0 = SimType([10.0;10.0], 0.0)
p = 0.0
prob = ODEProblem(f,u0,(0.0,10.0),p)
const tstop = [5.;8.]
sol = solve(prob,Tsit5(),callback = cbs, tstops=tstop)</code></pre><p>where we now change the callbacks to changing the parameter in the function:</p><pre><code class="language-julia">function affect!(integrator)
  integrator.f.params = 1.5
end

function affect2!(integrator)
  integrator.f.params = -1.5
end</code></pre><p>This will also solve the equation and get a similar result. It will also be slightly faster in some cases. However, if the equation is solved in this manner, there will be no record of what the parameter was at each timepoint. That is the tradeoff between <code>DEDataArray</code>s and <code>ParameterizedFunction</code>s.</p><footer><hr/><a class="previous" href="performance_overloads.html"><span class="direction">Previous</span><span class="title">Performance Overloads</span></a><a class="next" href="diffeq_operator.html"><span class="direction">Next</span><span class="title">DiffEqOperators</span></a></footer></article></body></html>
