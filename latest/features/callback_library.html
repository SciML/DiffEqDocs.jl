<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Callback Library · DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/bvp_example.html">Boundary Value Problems</a></li><li><a class="toctext" href="../tutorials/additional.html">Additional Tutorials</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li><li><a class="toctext" href="../basics/integrator.html">Integrator Interface</a></li><li><a class="toctext" href="../basics/problem.html">Problem Interface</a></li><li><a class="toctext" href="../basics/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../basics/compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Problems</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Problems</a></li><li><a class="toctext" href="../types/dynamical_types.html">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../types/split_ode_types.html">Split ODE Problems</a></li><li><a class="toctext" href="../types/steady_state_types.html">Steady State Problems</a></li><li><a class="toctext" href="../types/bvp_types.html">BVP Problems</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Problems</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Problems</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Problems</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Problems</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../solvers/discrete_solve.html">Discrete Solvers</a></li><li><a class="toctext" href="../solvers/ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="../solvers/dynamical_solve.html">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="../solvers/split_ode_solve.html">Split ODE Solvers</a></li><li><a class="toctext" href="../solvers/steady_state_solve.html">Steady State Solvers</a></li><li><a class="toctext" href="../solvers/bvp_solve.html">BVP Solvers</a></li><li><a class="toctext" href="../solvers/jump_solve.html">Jump Problem Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="../solvers/rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="../solvers/dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="../solvers/dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="../solvers/benchmarks.html">Solver Benchmarks</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="performance_overloads.html">DiffEqFunctions (Jacobians, Gradients, etc.) and Jacobian Types</a></li><li><a class="toctext" href="diffeq_arrays.html">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="diffeq_operator.html">DiffEqOperators</a></li><li><a class="toctext" href="noise_process.html">Noise Processes</a></li><li><a class="toctext" href="linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="callback_functions.html">Event Handling and Callback Functions</a></li><li class="current"><a class="toctext" href="callback_library.html">Callback Library</a><ul class="internal"><li><a class="toctext" href="#Manifold-Conservation-and-Projection-1">Manifold Conservation and Projection</a></li><li><a class="toctext" href="#AutoAbstol-1">AutoAbstol</a></li><li><a class="toctext" href="#PositiveDomain-1">PositiveDomain</a></li><li><a class="toctext" href="#GeneralDomain-1">GeneralDomain</a></li><li><a class="toctext" href="#Stepsize-Limiters-1">Stepsize Limiters</a></li><li><a class="toctext" href="#FunctionCallingCallback-1">FunctionCallingCallback</a></li><li><a class="toctext" href="#SavingCallback-1">SavingCallback</a></li><li><a class="toctext" href="#PresetTimeCallback-1">PresetTimeCallback</a></li><li><a class="toctext" href="#IterativeCallback-1">IterativeCallback</a></li><li><a class="toctext" href="#PeriodicCallback-1">PeriodicCallback</a></li><li><a class="toctext" href="#TerminateSteadyState-1">TerminateSteadyState</a></li></ul></li><li><a class="toctext" href="ensemble.html">Parallel Ensemble Simulations</a></li><li><a class="toctext" href="io.html">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../analysis/parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="../analysis/parameter_estimation.html">Parameter Estimation and Bayesian Analysis</a></li><li><a class="toctext" href="../analysis/bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="../analysis/sensitivity.html">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li><a class="toctext" href="../analysis/global_sensitivity.html">Global Sensitivity Analysis</a></li><li><a class="toctext" href="../analysis/uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="../analysis/neural_networks.html">Neural Networks</a></li><li><a class="toctext" href="../analysis/dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/physical.html">Physical Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Chemical Reaction Models</a></li><li><a class="toctext" href="../models/external_modeling.html">External Modeling Packages</a></li></ul></li><li><span class="toctext">APIs</span><ul><li><a class="toctext" href="../apis/diffeqbio.html">DiffEqBiological.jl API</a></li></ul></li><li><span class="toctext">Extra Details</span><ul><li><a class="toctext" href="../extras/timestepping.html">Timestepping Method Descriptions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Additional Features</li><li><a href="callback_library.html">Callback Library</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/blob/master/docs/src/features/callback_library.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Callback Library</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Callback-Library-1" href="#Callback-Library-1">Callback Library</a></h1><p>DiffEqCallbacks.jl provides a library of various helpful callbacks which can be used with any component solver which implements the callback interface. It adds the following callbacks which are available to users of DifferentialEquations.jl.</p><h2><a class="nav-anchor" id="Manifold-Conservation-and-Projection-1" href="#Manifold-Conservation-and-Projection-1">Manifold Conservation and Projection</a></h2><p>In many cases, you may want to declare a manifold on which a solution lives. Mathematically, a manifold <code>M</code> is defined by a function <code>g</code> as the set of points where <code>g(u)=0</code>. An embedded manifold can be a lower dimensional object which constrains the solution. For example, <code>g(u)=E(u)-C</code> where <code>E</code> is the energy of the system in state <code>u</code>, meaning that the energy must be constant (energy preservation). Thus by defining the manifold the solution should live on, you can retain desired properties of the solution.</p><p>It is a consequence of convergence proofs both in the deterministic and stochastic cases that post-step projection to manifolds keep the same convergence rate (stochastic requires a truncation in the proof, details details), thus any algorithm can be easily extended to conserve properties. If the solution is supposed to live on a specific manifold or conserve such property, this guarantees the conservation law without modifying the convergence properties.</p><h3><a class="nav-anchor" id="Constructor-1" href="#Constructor-1">Constructor</a></h3><pre><code class="language-julia">ManifoldProjection(g; nlsolve=NLSOLVEJL_SETUP(), save=true, autonomous=numargs(g)==2, nlopts=Dict{Symbol,Any}())</code></pre><ul><li><code>g</code>: The residual function for the manifold. This is an inplace function of form <code>g(u, resid)</code> or <code>g(t, u, resid)</code> which writes to the residual the difference from the manifold components.</li><li><code>nlsolve</code>: A nonlinear solver as defined <a href="linear_nonlinear.html">in the nlsolve format</a>.</li><li><code>save</code>: Whether to do the save after the callback is applied. Standard saving is unchanged.</li><li><code>autonomous</code>: Whether <code>g</code> is an autonomous function of the form <code>g(u, resid)</code>.</li><li><code>nlopts</code>: Optional arguments to nonlinear solver which can be any of the <a href="https://github.com/JuliaNLSolvers/NLsolve.jl#fine-tunings">NLsolve keywords</a>.</li></ul><h3><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h3><p>Here we solve the harmonic oscillator:</p><pre><code class="language-julia">u0 = ones(2)
function f(du,u,p,t)
  du[1] = u[2]
  du[2] = -u[1]
end
prob = ODEProblem(f,u0,(0.0,100.0))</code></pre><p>However, this problem is supposed to conserve energy, and thus we define our manifold to conserve the sum of squares:</p><pre><code class="language-julia">function g(resid,u,p,t)
  resid[1] = u[2]^2 + u[1]^2 - 2
  resid[2] = 0
end</code></pre><p>To build the callback, we just call</p><pre><code class="language-julia">cb = ManifoldProjection(g)</code></pre><p>Using this callback, the Runge-Kutta method <code>Vern7</code> conserves energy. Note that the standard saving occurs after the step and before the callback, and thus we set  <code>save_everystep=false</code> to turn off all standard saving and let the callback save after the projection is applied.</p><pre><code class="language-julia">sol = solve(prob,Vern7(),save_everystep=false,callback=cb)
@test sol[end][1]^2 + sol[end][2]^2 ≈ 2</code></pre><p><img src="../assets/manifold_projection.png" alt="manifold_projection"/></p><h4><a class="nav-anchor" id="Saveat-Warning-1" href="#Saveat-Warning-1">Saveat Warning</a></h4><p>Note that the <code>ManifoldProjection</code> callback modifies the endpoints of the integration intervals and thus breaks assumptions of internal interpolations. Because of this, the values for given by saveat will not be order-matching. However, the interpolation error can be proportional to the change by the projection, so if the projection is making small changes then one is still safe. However, if there are large changes from each projection, you should consider only saving at stopping/projection times. To do this, set <code>tstops</code> to the same values as <code>saveat</code>. There is a performance hit by doing so because now the integrator is forced to stop at every saving point, but this is guerenteed to match the order of the integrator even with the ManifoldProjection.</p><h2><a class="nav-anchor" id="AutoAbstol-1" href="#AutoAbstol-1">AutoAbstol</a></h2><p>Many problem solving environments <a href="https://www.mathworks.com/help/simulink/gui/absolute-tolerance.html">such as MATLAB</a> provide a way to automatically adapt the absolute tolerance to the problem. This helps the solvers automatically &quot;learn&quot; what appropriate limits are. Via the callback interface, DiffEqCallbacks.jl implements a callback <code>AutoAbstol</code> which has the same behavior as the MATLAB implementation, that is the absolute tolerance starts and at each iteration it is set to the maximum value that the state has thus far reached times the relative tolerance. If <code>init_curmax</code> is zero, then the initial value is determined by the <code>abstol</code> of the solver. Otherwise this is the initial value for the current maximum <code>abstol</code>.</p><p>To generate the callback, use the constructor:</p><pre><code class="language-julia">AutoAbstol(save=true;init_curmax=0.0)</code></pre><h2><a class="nav-anchor" id="PositiveDomain-1" href="#PositiveDomain-1">PositiveDomain</a></h2><p>Especially in biology and other natural sciences, a desired property of dynamical systems is the positive invariance of the positive cone, i.e. non-negativity of variables at time <span>$t_0$</span> ensures their non-negativity at times <span>$t \geq t_0$</span> for which the solution is defined. However, even if a system satisfies this property mathematically it can be difficult for ODE solvers to ensure it numerically, as these <a href="https://www.mathworks.com/help/matlab/math/nonnegative-ode-solution.html">MATLAB examples</a> show.</p><p>In order to deal with this problem one can specify <code>isoutofdomain=(u,p,t) -&gt; any(x -&gt; x &lt; 0, u)</code> as additional <a href="http://docs.juliadiffeq.org/latest/basics/common_solver_opts.html">solver option</a>, which will reject any step that leads to non-negative values and reduce the next time step. However, since this approach only rejects steps and hence calculations might be repeated multiple times until a step is accepted, it can be computationally expensive.</p><p>Another approach is taken by a <code>PositiveDomain</code> callback in DiffEqCallbacks.jl, which is inspired by <a href="http://www.sciencedirect.com/science/article/pii/S0096300304009683">Shampine&#39;s et al. paper about non-negative ODE solutions</a>. It reduces the next step by a certain scale factor until the extrapolated value at the next time point is non-negative with a certain tolerance. Extrapolations are cheap to compute but might be inaccurate, so if a time step is changed it is additionally reduced by a safety factor of 0.9. Since extrapolated values are only non-negative up to a certain tolerance and in addition actual calculations might lead to negative values, also any negative values at the current time point are set to 0. Hence by this callback non-negative values at any time point are ensured in a computationally cheap way, but the quality of the solution depends on how accurately extrapolations approximate next time steps.</p><p>Please note that the system should be defined also outside the positive domain, since even with these approaches negative variables might occur during the calculations. Moreover, one should follow Shampine&#39;s et. al. advice and set the derivative <span>$x&#39;_i$</span> of a negative component <span>$x_i$</span> to <span>$\max \{0, f_i(x, t)\}$</span>, where <span>$t$</span> denotes the current time point with state vector <span>$x$</span> and <span>$f_i$</span> is the <span>$i$</span>-th component of function <span>$f$</span> in an ODE system <span>$x&#39; = f(x, t)$</span>.</p><h3><a class="nav-anchor" id="Constructor-2" href="#Constructor-2">Constructor</a></h3><pre><code class="language-julia">PositiveDomain(u=nothing; save=true, abstol=nothing, scalefactor=nothing)</code></pre><ul><li><code>u</code>: A prototype of the state vector of the integrator. A copy of it is saved and extrapolated values are written to it. If it is not specified every application of the callback allocates a new copy of the state vector.</li><li><code>save</code>: Whether to do the standard saving (applied after the callback).</li><li><code>abstol</code>: Tolerance up to which negative extrapolated values are accepted. Element-wise tolerances are allowed. If it is not specified every application of the callback uses the current absolute tolerances of the integrator.</li><li><code>scalefactor</code>: Factor by which an unaccepted time step is reduced. If it is not specified time steps are halved.</li></ul><h2><a class="nav-anchor" id="GeneralDomain-1" href="#GeneralDomain-1">GeneralDomain</a></h2><p>A <code>GeneralDomain</code> callback in DiffEqCallbacks.jl generalizes the concept of a <code>PositiveDomain</code> callback to arbitrary domains. Domains are specified by in-place functions <code>g(u, resid)</code> or <code>g(t, u, resid)</code> that calculate residuals of a state vector <code>u</code> at time <code>t</code> relative to that domain. As for <code>PositiveDomain</code>, steps are accepted if residuals of the extrapolated values at the next time step are below a certain tolerance. Moreover, this callback is automatically coupled with a <code>ManifoldProjection</code> that keeps all calculated state vectors close to the desired domain, but in contrast to a <code>PositiveDomain</code> callback the nonlinear solver in a <code>ManifoldProjection</code> can not guarantee that all state vectors of the solution are actually inside the domain. Thus a <code>PositiveDomain</code> callback should in general be preferred.</p><h3><a class="nav-anchor" id="Constructor-3" href="#Constructor-3">Constructor</a></h3><pre><code class="language-julia">function GeneralDomain(g, u=nothing; nlsolve=NLSOLVEJL_SETUP(), save=true,
                       abstol=nothing, scalefactor=nothing, autonomous=numargs(g)==2,
                       nlopts=Dict(:ftol =&gt; 10*eps()))</code></pre><ul><li><code>g</code>: The residual function for the domain. This is an inplace function of form <code>g(resid, u, p, t)</code> which writes to the residual the difference from the domain.</li><li><code>u</code>: A prototype of the state vector of the integrator and the residuals. Two copies of it are saved, and extrapolated values and residuals are written to them. If it is not specified every application of the callback allocates two new copies of the state vector.</li><li><code>nlsolve</code>: A nonlinear solver as defined <a href="linear_nonlinear.html">in the nlsolve format</a> which is passed to a <code>ManifoldProjection</code>.</li><li><code>save</code>: Whether to do the standard saving (applied after the callback).</li><li><code>abstol</code>: Tolerance up to which residuals are accepted. Element-wise tolerances are allowed. If it is not specified every application of the callback uses the current absolute tolerances of the integrator.</li><li><code>scalefactor</code>: Factor by which an unaccepted time step is reduced. If it is not specified time steps are halved.</li><li><code>autonomous</code>: Whether <code>g</code> is an autonomous function of the form <code>g(u, resid)</code>.</li><li><code>nlopts</code>: Optional arguments to nonlinear solver of a <code>ManifoldProjection</code> which can be any of the <a href="https://github.com/JuliaNLSolvers/NLsolve.jl#fine-tunings">NLsolve keywords</a>. The default value of <code>ftol = 10*eps()</code> ensures that convergence is only declared if the infinite norm of residuals is very small and hence the state vector is very close to the domain.</li></ul><h2><a class="nav-anchor" id="Stepsize-Limiters-1" href="#Stepsize-Limiters-1">Stepsize Limiters</a></h2><p>In many cases there is a known maximal stepsize for which the computation is stable and produces correct results. For example, in hyperbolic PDEs one normally needs to ensure that the stepsize stays below some <span>$\Delta t_{FE}$</span> determined by the CFL condition. For nonlinear hyperbolic PDEs this limit can be a function <code>dtFE(u,p,t)</code> which changes throughout the computation. The stepsize limiter lets you pass a function which will adaptively limit the stepsizes to match these constraints.</p><h3><a class="nav-anchor" id="Constructor-4" href="#Constructor-4">Constructor</a></h3><pre><code class="language-julia">StepsizeLimiter(dtFE;safety_factor=9//10,max_step=false,cached_dtcache=0.0)</code></pre><ul><li><code>dtFE</code>: The function for the maximal timestep, called as <code>dtFE(u,p,t)</code> using the previous values of <code>u</code>, <code>p</code>, and <code>t</code>.</li><li><code>safety_factor</code>: The factor below the true maximum that will be stepped to which defaults to <code>9//10</code>.</li><li><code>max_step</code>: Makes every step equal to <code>safety_factor*dtFE(u,p,t)</code> when the solver is set to <code>adaptive=false</code>.</li><li><code>cached_dtcache</code>: Should be set to match the type for time when not using Float64 values.</li></ul><h2><a class="nav-anchor" id="FunctionCallingCallback-1" href="#FunctionCallingCallback-1">FunctionCallingCallback</a></h2><p>The function calling callback lets you define a function <code>func(u,t,integrator)</code> which gets calls at the time points of interest. The constructor is:</p><pre><code class="language-julia">  FunctionCallingCallback(func;
                 funcat=Vector{Float64}(),
                 func_everystep=isempty(funcat),
                 func_start = true,
                 tdir=1)</code></pre><ul><li><code>func(u, t, integrator)</code> is the function to be called.</li><li><code>funcat</code> values that the function is sure to be evaluated at.</li><li><code>func_everystep</code> whether to call the function after each integrator step.</li><li><code>func_start</code> whether the function is called the initial condition.</li><li><code>tdir</code> should be <code>sign(tspan[end]-tspan[1])</code>. It defaults to <code>1</code> and should   be adapted if <code>tspan[1] &gt; tspan[end]</code>.</li></ul><h2><a class="nav-anchor" id="SavingCallback-1" href="#SavingCallback-1">SavingCallback</a></h2><p>The saving callback lets you define a function <code>save_func(u, t, integrator)</code> which returns quantities of interest that shall be saved.</p><h3><a class="nav-anchor" id="Constructor-5" href="#Constructor-5">Constructor</a></h3><pre><code class="language-julia">SavingCallback(save_func, saved_values::SavedValues;
               saveat=Vector{eltype(saved_values.t)}(),
               save_everystep=isempty(saveat),
               tdir=1)</code></pre><ul><li><code>save_func(u, t, integrator)</code> returns the quantities which shall be saved. Note that this should allocate the output (not as a view to <code>u</code>).</li><li><code>saved_values::SavedValues</code> is the types that <code>save_func</code> will return, i.e. <code>save_func(u, t, integrator)::savevalType</code>. It&#39;s specified via <code>SavedValues(typeof(t),savevalType)</code>, i.e. give the type for time and the type that <code>save_func</code> will output (or higher compatible type).</li><li><code>saveat</code> mimicks <code>saveat</code> in <code>solve</code> from <code>solve</code>.</li><li><code>save_everystep</code> mimicks <code>save_everystep</code> from <code>solve</code>.</li><li><code>save_start</code> mimicks <code>save_start</code> from <code>solve</code>.</li><li><code>tdir</code> should be <code>sign(tspan[end]-tspan[1])</code>. It defaults to <code>1</code> and should be adapted if <code>tspan[1] &gt; tspan[end]</code>.</li></ul><p>The outputted values are saved into <code>saved_values</code>. Time points are found via <code>saved_values.t</code> and the values are <code>saved_values.saveval</code>.</p><h3><a class="nav-anchor" id="Example-2" href="#Example-2">Example</a></h3><p>In this example we will solve a matrix equation and at each step save a tuple of values which contains the current trace and the norm of the matrix. We build the <code>SavedValues</code> cache to use <code>Float64</code> for time and <code>Tuple{Float64,Float64}</code> for the saved values, and then call the solver with the callback.</p><pre><code class="language-julia">using DiffEqCallbacks, OrdinaryDiffEq, LinearAlgebra
prob = ODEProblem((du,u,p,t) -&gt; du .= u, rand(4,4), (0.0,1.0))
saved_values = SavedValues(Float64, Tuple{Float64,Float64})
cb = SavingCallback((u,t,integrator)-&gt;(tr(u),norm(u)), saved_values)
sol = solve(prob, Tsit5(), callback=cb)

print(saved_values.saveval)
#=
Tuple{Float64,Float64}[(2.23186, 2.49102), (2.46675, 2.75318), (3.16138, 3.52847), (4.42011, 4.93337), (6.06683, 6.77129)]
=#</code></pre><p>Note that the values are retrieved from the cache as <code>.saveval</code>, and the time points are found as <code>.t</code>. If we want to control the saved times, we use <code>saveat</code> in the callback. The save controls like <code>saveat</code> act analogously to how they act in the <code>solve</code> function.</p><pre><code class="language-julia">saved_values = SavedValues(Float64, Tuple{Float64,Float64})
cb = SavingCallback((u,t,integrator)-&gt;(tr(u),norm(u)), saved_values, saveat=0.0:0.1:1.0)
sol = solve(prob, Tsit5(), callback=cb)
print(saved_values.saveval)
print(saved_values.t)

#=
Tuple{Float64,Float64}[(2.23186, 2.49102), (2.46659, 2.753), (2.726, 3.04254), (3.0127, 3.36253), 
(3.32955, 3.71617), (3.67972, 4.107), (4.06672, 4.53893), (4.49442, 5.0163), (4.9671, 5.54387), 
(5.48949, 6.12692), (6.06683, 6.77129)]
[0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
=#</code></pre><h2><a class="nav-anchor" id="PresetTimeCallback-1" href="#PresetTimeCallback-1">PresetTimeCallback</a></h2><p><code>PresetTimeCallback</code> is a callback that adds callback <code>affect!</code> calls at preset times. No playing around with <code>tstops</code> or anything is required: this callback adds the triggers for you to make it automatic.</p><pre><code class="language-julia">PresetTimeCallback(tstops,user_affect!;
                            initialize = DiffEqBase.INITIALIZE_DEFAULT,
                            kwargs...)</code></pre><ul><li><code>tstops</code>: the times for the <code>affect!</code> to trigger at.</li><li><code>user_affect!</code>: an <code>affect!(integrator)</code> function to use at the time points.</li></ul><h2><a class="nav-anchor" id="IterativeCallback-1" href="#IterativeCallback-1">IterativeCallback</a></h2><p><code>IterativeCallback</code> is a callback to be used to iteratively apply some effect. For example, if given the first effect at <code>t₁</code>, you can define <code>t₂</code> to apply the next effect.</p><p>A <code>IterativeCallback</code> is constructed as follows:</p><pre><code class="language-julia">function IterativeCallback(time_choice, user_affect!,tType = Float64;
                           initial_affect = false, kwargs...)</code></pre><p>where <code>time_choice(integrator)</code> determines the time of the next callback and <code>user_affect!</code> is the effect applied to the integrator at the stopping points. If <code>nothing</code> is returned for the time choice then the iterator ends. <code>initial_affect</code>  is whether to apply the affect at <code>t=0</code> which defaults to <code>false</code>. <code>kwargs</code> are  keyword arguments accepted by the <code>DiscreteCallback</code> constructor.</p><h2><a class="nav-anchor" id="PeriodicCallback-1" href="#PeriodicCallback-1">PeriodicCallback</a></h2><p><code>PeriodicCallback</code> can be used when a function should be called periodically in terms of integration time (as opposed to wall time), i.e. at <code>t = tspan[1]</code>, <code>t = tspan[1] + Δt</code>, <code>t = tspan[1] + 2Δt</code>, and so on. This callback can, for example, be used to model a digital controller for an analog system, running at a fixed rate.</p><h3><a class="nav-anchor" id="Constructor-6" href="#Constructor-6">Constructor</a></h3><pre><code class="language-julia">PeriodicCallback(f, Δt::Number; initial_affect = true, kwargs...)</code></pre><p>where <code>f</code> is the function to be called periodically, <code>Δt</code> is the period,  <code>initial_affect</code> is whether to apply the affect at <code>t=0</code> which defaults to <code>true</code>, and <code>kwargs</code> are keyword arguments accepted by the <code>DiscreteCallback</code> constructor (see the <a href="callback_functions.html#DiscreteCallback-1">DiscreteCallback</a> section).</p><h2><a class="nav-anchor" id="TerminateSteadyState-1" href="#TerminateSteadyState-1">TerminateSteadyState</a></h2><p><code>TerminateSteadyState</code> can be used to solve the problem for the steady-state by running the solver until the derivatives of the problem converge to 0 or <code>tspan[2]</code> is reached. This is an alternative approach to root finding (see the <a href="../solvers/steady_state_solve.html#Steady-State-Solvers-1">Steady State Solvers</a> section). The constructor of this callback is:</p><pre><code class="language-julia">TerminateSteadyState(abstol = 1e-8, reltol = 1e-6, test = allDerivPass)</code></pre><p>where <code>abstol</code> and <code>reltol</code> are the absolute and relative tolerance, respectively. These tolerances may be specified as scalars or as arrays of the same length as the states of the problem. <code>test</code> represents the function that evaluates the condition for termination. The default condition is that all derivatives should become smaller than <code>abstol</code> and the states times <code>reltol</code>. The user can pass any other function to implement a different termination condition. Such function should take four arguments: <code>integrator</code> (see <a href="../basics/integrator.html#Integrator-Interface-1">Integrator Interface</a> for details), <code>abstol</code> and <code>reltol</code>.</p><footer><hr/><a class="previous" href="callback_functions.html"><span class="direction">Previous</span><span class="title">Event Handling and Callback Functions</span></a><a class="next" href="ensemble.html"><span class="direction">Next</span><span class="title">Parallel Ensemble Simulations</span></a></footer></article></body></html>
