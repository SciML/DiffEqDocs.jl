<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Callback Library · DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/fempoisson_example.html">Poisson Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femheat_example.html">Heat Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femstochastic_example.html">Stochastic Finite Element Method</a></li><li><a class="toctext" href="../tutorials/bvp_example.html">Boundary Value Problems</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li><li><a class="toctext" href="../basics/integrator.html">Integrator Interface</a></li><li><a class="toctext" href="../basics/compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Problems</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Problems</a></li><li><a class="toctext" href="../types/dynamical_types.html">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../types/split_ode_types.html">Split ODE Problems</a></li><li><a class="toctext" href="../types/steady_state_types.html">Steady State Problems</a></li><li><a class="toctext" href="../types/bvp_types.html">BVP Problems</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Problems</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Problems</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Problems</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Problems</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Problems</a></li><li><a class="toctext" href="../types/fem_types.html">FEM Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../solvers/discrete_solve.html">Discrete Solvers</a></li><li><a class="toctext" href="../solvers/ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="../solvers/dynamical_solve.html">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="../solvers/split_ode_solve.html">Split ODE Solvers</a></li><li><a class="toctext" href="../solvers/steady_state_solve.html">Steady State Solvers</a></li><li><a class="toctext" href="../solvers/bvp_solve.html">BVP Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="../solvers/rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="../solvers/dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="../solvers/dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="../solvers/fempoisson_solve.html">FEM Poisson Solvers</a></li><li><a class="toctext" href="../solvers/femheat_solve.html">FEM Heat Solvers</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="performance_overloads.html">Performance Overloads</a></li><li><a class="toctext" href="diffeq_arrays.html">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="diffeq_operator.html">DiffEqOperators</a></li><li><a class="toctext" href="noise_process.html">Noise Processes</a></li><li><a class="toctext" href="linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="callback_functions.html">Event Handling and Callback Functions</a></li><li class="current"><a class="toctext" href="callback_library.html">Callback Library</a><ul class="internal"><li><a class="toctext" href="#Manifold-Conservation-and-Projection-1">Manifold Conservation and Projection</a></li><li><a class="toctext" href="#AutoAbstol-1">AutoAbstol</a></li><li><a class="toctext" href="#PositiveDomain-1">PositiveDomain</a></li><li><a class="toctext" href="#GeneralDomain-1">GeneralDomain</a></li><li><a class="toctext" href="#Stepsize-Limiters-1">Stepsize Limiters</a></li></ul></li><li><a class="toctext" href="monte_carlo.html">Parallel Monte Carlo Simulations</a></li><li><a class="toctext" href="io.html">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="mesh.html">Meshes</a></li><li><a class="toctext" href="progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../analysis/parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="../analysis/parameter_estimation.html">Parameter Estimation</a></li><li><a class="toctext" href="../analysis/bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="../analysis/sensitivity.html">Sensitivity Analysis</a></li><li><a class="toctext" href="../analysis/uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="../analysis/dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/physical.html">Physical Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Biological Models</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Additional Features</li><li><a href="callback_library.html">Callback Library</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/tree/493bc1e17766784ae4961fb61fccc26e734c515d/docs/src/features/callback_library.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Callback Library</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Callback-Library-1" href="#Callback-Library-1">Callback Library</a></h1><p>DiffEqCallbacks.jl provides a library of various helpful callbacks which can be used with any component solver which implements the callback interface. It adds the following callbacks which are available to users of DifferentialEquations.jl.</p><h2><a class="nav-anchor" id="Manifold-Conservation-and-Projection-1" href="#Manifold-Conservation-and-Projection-1">Manifold Conservation and Projection</a></h2><p>In many cases, you may want to declare a manifold on which a solution lives. Mathematically, a manifold <code>M</code> is defined by a function <code>g</code> as the set of points where <code>g(u)=0</code>. An embedded manifold can be a lower dimensional object which constrains the solution. For example, <code>g(u)=E(u)-C</code> where <code>E</code> is the energy of the system in state <code>u</code>, meaning that the energy must be constant (energy preservation). Thus by defining the manifold the solution should live on, you can retain desired properties of the solution.</p><p>It is a consequence of convergence proofs both in the deterministic and stochastic cases that post-step projection to manifolds keep the same convergence rate (stochastic requires a truncation in the proof, details details), thus any algorithm can be easily extended to conserve properties. If the solution is supposed to live on a specific manifold or conserve such property, this guarantees the conservation law without modifying the convergence properties.</p><h3><a class="nav-anchor" id="Constructor-1" href="#Constructor-1">Constructor</a></h3><pre><code class="language-julia">ManifoldProjection(g; nlsolve=NLSOLVEJL_SETUP(), save=true, autonomous=numargs(g)==2, nlopts=Dict{Symbol,Any}())</code></pre><ul><li><p><code>g</code>: The residual function for the manifold. This is an inplace function of form <code>g(u, resid)</code> or <code>g(t, u, resid)</code> which writes to the residual the difference from the manifold components.</p></li><li><p><code>nlsolve</code>: A nonlinear solver as defined <a href="linear_nonlinear.html">in the nlsolve format</a>.</p></li><li><p><code>save</code>: Whether to do the standard saving (applied after the callback).</p></li><li><p><code>autonomous</code>: Whether <code>g</code> is an autonomous function of the form <code>g(u, resid)</code>.</p></li><li><p><code>nlopts</code>: Optional arguments to nonlinear solver which can be any of the <a href="https://github.com/JuliaNLSolvers/NLsolve.jl#fine-tunings">NLsolve keywords</a>.</p></li></ul><h3><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h3><p>Here we solve the harmonic oscillator:</p><pre><code class="language-julia">u0 = ones(2)
function f(t,u,du)
  du[1] = u[2]
  du[2] = -u[1]
end
prob = ODEProblem(f,u0,(0.0,100.0))</code></pre><p>However, this problem is supposed to conserve energy, and thus we define our manifold to conserve the sum of squares:</p><pre><code class="language-julia">function g(u,resid)
  resid[1] = u[2]^2 + u[1]^2 - 2
  resid[2] = 0
end</code></pre><p>To build the callback, we just call</p><pre><code class="language-julia">cb = ManifoldProjection(g)</code></pre><p>Using this callback, the Runge-Kutta method <code>Vern7</code> conserves energy:</p><pre><code class="language-julia">sol = solve(prob,Vern7(),callback=cb)
@test sol[end][1]^2 + sol[end][2]^2 ≈ 2</code></pre><p><img src="../assets/manifold_projection.png" alt="manifold_projection"/></p><h2><a class="nav-anchor" id="AutoAbstol-1" href="#AutoAbstol-1">AutoAbstol</a></h2><p>Many problem solving environments <a href="https://www.mathworks.com/help/simulink/gui/absolute-tolerance.html">such as MATLAB</a> provide a way to automatically adapt the absolute tolerance to the problem. This helps the solvers automatically &quot;learn&quot; what appropriate limits are. Via the callback interface, DiffEqCallbacks.jl implements a callback <code>AutoAbstol</code> which has the same behavior as the MATLAB implementation, that is the absolute tolerance starts and at each iteration it is set to the maximum value that the state has thus far reached times the relative tolerance. If <code>init_curmax</code> is zero, then the initial value is determined by the <code>abstol</code> of the solver. Otherwise this is the initial value for the current maximum <code>abstol</code>.</p><p>To generate the callback, use the constructor:</p><pre><code class="language-julia">AutoAbstol(save=true;init_curmax=0.0)</code></pre><h2><a class="nav-anchor" id="PositiveDomain-1" href="#PositiveDomain-1">PositiveDomain</a></h2><p>Especially in biology and other natural sciences, a desired property of dynamical systems is the positive invariance of the positive cone, i.e. non-negativity of variables at time <span>$t_0$</span> ensures their non-negativity at times <span>$t \geq t_0$</span> for which the solution is defined. However, even if a system satisfies this property mathematically it can be difficult for ODE solvers to ensure it numerically, as these <a href="https://www.mathworks.com/help/matlab/math/nonnegative-ode-solution.html">MATLAB examples</a> show.</p><p>In order to deal with this problem one can specify <code>isoutofdomain=(t,u) -&gt; any(x -&gt; x &lt; 0, u)</code> as additional <a href="http://docs.juliadiffeq.org/latest/basics/common_solver_opts.html">solver option</a>, which will reject any step that leads to non-negative values and reduce the next time step. However, since this approach only rejects steps and hence calculations might be repeated multiple times until a step is accepted, it can be computationally expensive.</p><p>Another approach is taken by a <code>PositiveDomain</code> callback in DiffEqCallbacks.jl, which is inspired by <a href="http://www.sciencedirect.com/science/article/pii/S0096300304009683">Shampine&#39;s et al. paper about non-negative ODE solutions</a>. It reduces the next step by a certain scale factor until the extrapolated value at the next time point is non-negative with a certain tolerance. Extrapolations are cheap to compute but might be inaccurate, so if a time step is changed it is additionally reduced by a safety factor of 0.9. Since extrapolated values are only non-negative up to a certain tolerance and in addition actual calculations might lead to negative values, also any negative values at the current time point are set to 0. Hence by this callback non-negative values at any time point are ensured in a computationally cheap way, but the quality of the solution depends on how accurately extrapolations approximate next time steps.</p><p>Please note that the system should be defined also outside the positive domain, since even with these approaches negative variables might occur during the calculations. Moreover, one should follow Shampine&#39;s et. al. advice and set the derivative <span>$x&#39;_i$</span> of a negative component <span>$x_i$</span> to <span>$\max \{0, f_i(t, x)\}$</span>, where <span>$t$</span> denotes the current time point with state vector <span>$x$</span> and <span>$f_i$</span> is the <span>$i$</span>-th component of function <span>$f$</span> in an ODE system <span>$x&#39; = f(t, x)$</span>.</p><h3><a class="nav-anchor" id="Constructor-2" href="#Constructor-2">Constructor</a></h3><pre><code class="language-julia">PositiveDomain(u=nothing; save=true, abstol=nothing, scalefactor=nothing)</code></pre><ul><li><p><code>u</code>: A prototype of the state vector of the integrator. A copy of it is saved and extrapolated values are written to it. If it is not specified every application of the callback allocates a new copy of the state vector.</p></li><li><p><code>save</code>: Whether to do the standard saving (applied after the callback).</p></li><li><p><code>abstol</code>: Tolerance up to which negative extrapolated values are accepted. Element-wise tolerances are allowed. If it is not specified every application of the callback uses the current absolute tolerances of the integrator.</p></li><li><p><code>scalefactor</code>: Factor by which an unaccepted time step is reduced. If it is not specified time steps are halved.</p></li></ul><h2><a class="nav-anchor" id="GeneralDomain-1" href="#GeneralDomain-1">GeneralDomain</a></h2><p>A <code>GeneralDomain</code> callback in DiffEqCallbacks.jl generalizes the concept of a <code>PositiveDomain</code> callback to arbitrary domains. Domains are specified by in-place functions <code>g(u, resid)</code> or <code>g(t, u, resid)</code> that calculate residuals of a state vector <code>u</code> at time <code>t</code> relative to that domain. As for <code>PositiveDomain</code>, steps are accepted if residuals of the extrapolated values at the next time step are below a certain tolerance. Moreover, this callback is automatically coupled with a <code>ManifoldProjection</code> that keeps all calculated state vectors close to the desired domain, but in contrast to a <code>PositiveDomain</code> callback the nonlinear solver in a <code>ManifoldProjection</code> can not guarantee that all state vectors of the solution are actually inside the domain. Thus a <code>PositiveDomain</code> callback should in general be preferred.</p><h3><a class="nav-anchor" id="Constructor-3" href="#Constructor-3">Constructor</a></h3><pre><code class="language-julia">function GeneralDomain(g, u=nothing; nlsolve=NLSOLVEJL_SETUP(), save=true,
                       abstol=nothing, scalefactor=nothing, autonomous=numargs(g)==2,
                       nlopts=Dict(:ftol =&gt; 10*eps()))</code></pre><ul><li><p><code>g</code>: The residual function for the domain. This is an inplace function of form <code>g(u, resid)</code> or <code>g(t, u, resid)</code> which writes to the residual the difference from the domain.</p></li><li><p><code>u</code>: A prototype of the state vector of the integrator and the residuals. Two copies of it are saved, and extrapolated values and residuals are written to them. If it is not specified every application of the callback allocates two new copies of the state vector.</p></li><li><p><code>nlsolve</code>: A nonlinear solver as defined <a href="linear_nonlinear.html">in the nlsolve format</a> which is passed to a <code>ManifoldProjection</code>.</p></li><li><p><code>save</code>: Whether to do the standard saving (applied after the callback).</p></li><li><p><code>abstol</code>: Tolerance up to which residuals are accepted. Element-wise tolerances are allowed. If it is not specified every application of the callback uses the current absolute tolerances of the integrator.</p></li><li><p><code>scalefactor</code>: Factor by which an unaccepted time step is reduced. If it is not specified time steps are halved.</p></li><li><p><code>autonomous</code>: Whether <code>g</code> is an autonomous function of the form <code>g(u, resid)</code>.</p></li><li><p><code>nlopts</code>: Optional arguments to nonlinear solver of a <code>ManifoldProjection</code> which can be any of the <a href="https://github.com/JuliaNLSolvers/NLsolve.jl#fine-tunings">NLsolve keywords</a>. The default value of <code>ftol = 10*eps()</code> ensures that convergence is only declared if the infinite norm of residuals is very small and hence the state vector is very close to the domain.</p></li></ul><h2><a class="nav-anchor" id="Stepsize-Limiters-1" href="#Stepsize-Limiters-1">Stepsize Limiters</a></h2><p>In many cases there is a known maximal stepsize for which the computation is stable and produces correct results. For example, in hyperbolic PDEs one normally needs to ensure that the stepsize stays below some <span>$\Delta t_{FE}$</span> determined by the CFL condition. For nonlinear hyperbolic PDEs this limit can be a function <code>dtFE(t,u)</code> which changes throughout the computation. The stepsize limiter lets you pass a function which will adaptively limit the stepsizes to match these constraints.</p><h3><a class="nav-anchor" id="Constructor-4" href="#Constructor-4">Constructor</a></h3><pre><code class="language-julia">StepsizeLimiter(dtFE;safety_factor=9//10,max_step=false,cached_dtcache=0.0)</code></pre><ul><li><p><code>dtFE</code>: The function for the maximal timestep. Calculated using the previous <code>t</code> and <code>u</code>.</p></li><li><p><code>safety_factor</code>: The factor below the true maximum that will be stepped to which defaults to <code>9//10</code>.</p></li><li><p><code>max_step</code>: Makes every step equal to <code>safety_factor*dtFE(t,u)</code> when the solver is set to <code>adaptive=false</code>.</p></li><li><p><code>cached_dtcache</code>: Should be set to match the type for time when not using Float64 values.</p></li></ul><footer><hr/><a class="previous" href="callback_functions.html"><span class="direction">Previous</span><span class="title">Event Handling and Callback Functions</span></a><a class="next" href="monte_carlo.html"><span class="direction">Next</span><span class="title">Parallel Monte Carlo Simulations</span></a></footer></article></body></html>
