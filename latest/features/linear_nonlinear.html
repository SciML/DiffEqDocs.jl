<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Specifying (Non)Linear Solvers · DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/bvp_example.html">Boundary Value Problems</a></li><li><a class="toctext" href="../tutorials/additional.html">Additional Tutorials</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li><li><a class="toctext" href="../basics/integrator.html">Integrator Interface</a></li><li><a class="toctext" href="../basics/problem.html">Problem Interface</a></li><li><a class="toctext" href="../basics/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../basics/compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Problems</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Problems</a></li><li><a class="toctext" href="../types/dynamical_types.html">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../types/split_ode_types.html">Split ODE Problems</a></li><li><a class="toctext" href="../types/steady_state_types.html">Steady State Problems</a></li><li><a class="toctext" href="../types/bvp_types.html">BVP Problems</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Problems</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Problems</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Problems</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Problems</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../solvers/discrete_solve.html">Discrete Solvers</a></li><li><a class="toctext" href="../solvers/ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="../solvers/dynamical_solve.html">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="../solvers/split_ode_solve.html">Split ODE Solvers</a></li><li><a class="toctext" href="../solvers/steady_state_solve.html">Steady State Solvers</a></li><li><a class="toctext" href="../solvers/bvp_solve.html">BVP Solvers</a></li><li><a class="toctext" href="../solvers/jump_solve.html">Jump Problem Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="../solvers/rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="../solvers/dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="../solvers/dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="../solvers/benchmarks.html">Solver Benchmarks</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="performance_overloads.html">DiffEqFunctions (Jacobians, Gradients, etc.) and Jacobian Types</a></li><li><a class="toctext" href="diffeq_arrays.html">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="diffeq_operator.html">DiffEqOperators</a></li><li><a class="toctext" href="noise_process.html">Noise Processes</a></li><li class="current"><a class="toctext" href="linear_nonlinear.html">Specifying (Non)Linear Solvers</a><ul class="internal"><li><a class="toctext" href="#Linear-Solvers:-linsolve-Specification-1">Linear Solvers: <code>linsolve</code> Specification</a></li></ul></li><li><a class="toctext" href="callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="callback_library.html">Callback Library</a></li><li><a class="toctext" href="ensemble.html">Parallel Ensemble Simulations</a></li><li><a class="toctext" href="io.html">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../analysis/parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="../analysis/parameter_estimation.html">Parameter Estimation and Bayesian Analysis</a></li><li><a class="toctext" href="../analysis/bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="../analysis/sensitivity.html">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li><a class="toctext" href="../analysis/global_sensitivity.html">Global Sensitivity Analysis</a></li><li><a class="toctext" href="../analysis/uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="../analysis/neural_networks.html">Neural Networks</a></li><li><a class="toctext" href="../analysis/dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/physical.html">Physical Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Chemical Reaction Models</a></li><li><a class="toctext" href="../models/external_modeling.html">External Modeling Packages</a></li></ul></li><li><span class="toctext">APIs</span><ul><li><a class="toctext" href="../apis/diffeqbio.html">DiffEqBiological.jl API</a></li></ul></li><li><span class="toctext">Extra Details</span><ul><li><a class="toctext" href="../extras/timestepping.html">Timestepping Method Descriptions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Additional Features</li><li><a href="linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/blob/master/docs/src/features/linear_nonlinear.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Specifying (Non)Linear Solvers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Specifying-(Non)Linear-Solvers-1" href="#Specifying-(Non)Linear-Solvers-1">Specifying (Non)Linear Solvers</a></h1><p>One of the key features of DifferentialEquations.jl is its flexibility. Keeping with this trend, many of the native Julia solvers provided by DifferentialEquations.jl allow you to choose the method for linear and nonlinear solving. This section details how to make that choice.</p><h2><a class="nav-anchor" id="Linear-Solvers:-linsolve-Specification-1" href="#Linear-Solvers:-linsolve-Specification-1">Linear Solvers: <code>linsolve</code> Specification</a></h2><p>For differential equation integrators which use linear solvers, an argument to the method <code>linsolve</code> determines the linear solver which is used. The signature is:</p><pre><code class="language-julia">linsolve! = linsolve(Val{:init},f,x;kwargs...)
linsolve!(x,A,b,matrix_updated=false;kwargs...)</code></pre><p>This is an in-place function which updates <code>x</code> by solving <code>Ax=b</code>. The user should specify the function <code>linsolve(Val{:init},f,x)</code> which returns a <code>linsolve!</code> function. The setting <code>matrix_updated</code> determines whether the matrix <code>A</code> has changed from the last call. This can be used to smartly cache factorizations.</p><p>Note that <code>linsolve!</code> needs to accept splatted keyword arguments. The possible arguments passed to the linear solver are as follows:</p><ul><li><code>Pl</code>, a pre-specified left preconditioner which utilizes the internal adaptive norm estimates</li><li><code>Pr</code>, a pre-specified right preconditioner which utilizes the internal adaptive norm estimates</li><li><code>tol</code>, a linear solver tolerance specified from the ODE solver&#39;s implicit handling</li></ul><h3><a class="nav-anchor" id="Pre-Built-Linear-Solver-Choices-1" href="#Pre-Built-Linear-Solver-Choices-1">Pre-Built Linear Solver Choices</a></h3><p>The following choices of pre-built linear solvers exist:</p><ul><li>DefaultLinSolve</li><li>LinSolveFactorize</li><li>LinSolveGPUFactorize</li><li>LinSolveGMRES</li><li>LinSolveCG</li><li>LinSolveBiCGStabl</li><li>LinSolveChebyshev</li><li>LinSolveMINRES</li><li>LinSolveIterativeSolvers</li></ul><h3><a class="nav-anchor" id="DefaultLinSolve-1" href="#DefaultLinSolve-1">DefaultLinSolve</a></h3><p>The default linear solver is <code>DefaultLinSolve</code>. This method is adaptive, and automatically chooses an LU factorization choose for dense and sparse arrays, and is compatible with GPU-based arrays. When the Jacobian is an <code>AbstractDiffEqOperator</code>, i.e. is matrix-free, <code>DefaultLinSolve</code> defaults to using a <code>gmres</code> iterative solver.</p><h3><a class="nav-anchor" id="Basic-linsolve-method-choice:-Factorization-by-LinSolveFactorize-1" href="#Basic-linsolve-method-choice:-Factorization-by-LinSolveFactorize-1">Basic linsolve method choice: Factorization by LinSolveFactorize</a></h3><p>The easiest way to specify a <code>linsolve</code> is by a <code>factorization</code> function which generates a type on which <code>\</code> (or <code>A_ldiv_B!</code>) is called.  This is done through the helper function <code>LinSolveFactorize</code> which makes the appropriate function. For example, the  <code>Rosenbrock23</code> takes in a <code>linsolve</code> function, which we can choose to be a  QR-factorization by:</p><pre><code class="language-julia">Rosenbrock23(linsolve=LinSolveFactorize(qrfact!))</code></pre><p>LinSolveFactorize takes in a function which returns an object that can <code>\</code>. Direct methods like <code>qrfact!</code> will automatically cache the factorization, making it efficient for small dense problems.</p><p>However, for large sparse problems, you can let <code>\</code> be an iterative method. For example, using PETSc.jl, we can define our factorization function to be:</p><pre><code class="language-julia">linsolve = LinSolveFactorize((A) -&gt; KSP(A, ksp_type=&quot;gmres&quot;, ksp_rtol=1e-6))</code></pre><p>This function creates a <code>KSP</code> type which makes <code>\</code> perform the GMRES iterative method provided by PETSc.jl. Thus if we pass this function into the algorithm as the factorization method, all internal linear solves will happen by PETSc.jl.</p><h3><a class="nav-anchor" id="GPU-offloading-of-factorization-with-LinSolveGPUFactorize-1" href="#GPU-offloading-of-factorization-with-LinSolveGPUFactorize-1">GPU offloading of factorization with LinSolveGPUFactorize</a></h3><p>If one has a problem with a sufficiently large Jacobian (~100x100) and a sufficiently powerful GPU, it can make sense to offload the factorization and backpropogation steps to the GPU. For this, the <code>LinSolveGPUFactorize</code> linear solver is provided. It works similarly to <code>LinSolveFactorize</code>, but the matrix is automatically sent to the GPU as a <code>CuArray</code> and the <code>ldiv!</code> is performed against a CUDA QR factorization of the matrix.</p><p>Note that this method requires that you have done <code>using CuArrays</code> in your script. A working installation of CuArrays.jl is required, which requires an installation of CUDA Toolkit.</p><h3><a class="nav-anchor" id="IterativeSolvers.jl-Based-Methods-1" href="#IterativeSolvers.jl-Based-Methods-1">IterativeSolvers.jl-Based Methods</a></h3><p>The signature for <code>LinSolveIterativeSolvers</code> is:</p><pre><code class="language-julia">LinSolveIterativeSolvers(generate_iterator,args...;
                         Pl=IterativeSolvers.Identity(),
                         Pr=IterativeSolvers.Identity(),
                         kwargs...)</code></pre><p>where <code>Pl</code> is the left preconditioner, <code>Pr</code> is the right preconditioner, and the other <code>args...</code> and <code>kwargs...</code> are passed into the iterative solver chosen in <code>generate_iterator</code> which designates the construction of an iterator from IterativeSolvers.jl. For example, using <code>gmres_iterable!</code> would make a version that uses <code>IterativeSolvers.gmres</code>. The following are aliases to common choices:</p><ul><li>LinSolveGMRES – GMRES</li><li>LinSolveCG – CG (Conjugate Gradient)</li><li>LinSolveBiCGStabl – BiCGStabl Stabilized Bi-Conjugate Gradient</li><li>LinSolveChebyshev – Chebyshev</li><li>LinSolveMINRES – MINRES</li></ul><p>which all have the same arguments as <code>LinSolveIterativeSolvers</code> except with <code>generate_iterator</code> pre-specified.</p><h3><a class="nav-anchor" id="Implementing-Your-Own-LinSolve:-How-LinSolveFactorize-Was-Created-1" href="#Implementing-Your-Own-LinSolve:-How-LinSolveFactorize-Was-Created-1">Implementing Your Own LinSolve: How LinSolveFactorize Was Created</a></h3><p>In order to make your own <code>linsolve</code> functions, let&#39;s look at how the <code>LinSolveFactorize</code> function is created. For example, for an LU-Factorization, we would like to use <code>lufact!</code> to do our linear solving. We can directly write this as:</p><pre><code class="language-julia">function linsolve!(::Type{Val{:init}},f,u0,kwargs...)
  function _linsolve!(x,A,b,update_matrix=false,kwargs...)
    _A = lufact!(A)
    ldiv!(x,_A,b)
  end
end</code></pre><p>This initialization function returns a linear solving function that always computes the LU-factorization and then does the solving. This method works fine and you can pass it to the methods like</p><pre><code class="language-julia">Rosenbrock23(linsolve=linsolve!)</code></pre><p>and it will work, but this method does not cache <code>_A</code>, the factorization. This means that, even if <code>A</code> has not changed, it will re-factorize the matrix.</p><p>To change this, we can instead create a call-overloaded type. The generalized form of this is:</p><pre><code class="language-julia">mutable struct LinSolveFactorize{F}
  factorization::F
  A
end
LinSolveFactorize(factorization) = LinSolveFactorize(factorization,nothing)
function (p::LinSolveFactorize)(x,A,b,matrix_updated=false)
  if matrix_updated
    p.A = p.factorization(A)
  end
  A_ldiv_B!(x,p.A,b)
end
function (p::LinSolveFactorize)(::Type{Val{:init}},f,u0_prototype)
  LinSolveFactorize(p.factorization,nothing)
end
linsolve = LinSolveFactorize(lufact!)</code></pre><p><code>LinSolveFactorize</code> is a type which holds the factorization method and the pre-factorized matrix. When <code>linsolve</code> is passed to the ODE/SDE/etc. solver, it will use the function <code>linsolve(Val{:init},f,u0_prototype)</code> to create a <code>LinSolveFactorize</code> object which holds the factorization method and a cache for holding a factorized matrix. Then</p><pre><code class="language-julia">function (p::LinSolveFactorize)(x,A,b,matrix_updated=false)
  if matrix_updated
    p.A = p.factorization(A)
  end
  A_ldiv_B!(x,p.A,b)
end</code></pre><p>is what&#39;s used in the solver&#39;s internal loop. If <code>matrix_updated</code> is true, it will re-compute the factorization. Otherwise it just solves the linear system with the cached factorization. This general idea of using a call-overloaded type can be employed to do many other things.</p><footer><hr/><a class="previous" href="noise_process.html"><span class="direction">Previous</span><span class="title">Noise Processes</span></a><a class="next" href="callback_functions.html"><span class="direction">Next</span><span class="title">Event Handling and Callback Functions</span></a></footer></article></body></html>
