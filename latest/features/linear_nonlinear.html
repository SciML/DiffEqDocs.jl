<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Specifying (Non)Linear Solvers · DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/fempoisson_example.html">Poisson Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femheat_example.html">Heat Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femstochastic_example.html">Stochastic Finite Element Method</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li><li><a class="toctext" href="../basics/integrator.html">Integrator Interface</a></li><li><a class="toctext" href="../basics/compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Problems</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Problems</a></li><li><a class="toctext" href="../types/dynamical_types.html">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../types/split_ode_types.html">Split ODE Problems</a></li><li><a class="toctext" href="../types/steady_state_types.html">Steady State Problems</a></li><li><a class="toctext" href="../types/bvp_types.html">BVP Problems</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Problems</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Problems</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Problems</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Problems</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Problems</a></li><li><a class="toctext" href="../types/fem_types.html">FEM Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../solvers/discrete_solve.html">Discrete Solvers</a></li><li><a class="toctext" href="../solvers/ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="../solvers/dynamical_solve.html">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="../solvers/split_ode_solve.html">Split ODE Solvers</a></li><li><a class="toctext" href="../solvers/steady_state_solve.html">Steady State Solvers</a></li><li><a class="toctext" href="../solvers/bvp_solve.html">BVP Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="../solvers/rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="../solvers/dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="../solvers/dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="../solvers/fempoisson_solve.html">FEM Poisson Solvers</a></li><li><a class="toctext" href="../solvers/femheat_solve.html">FEM Heat Solvers</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="performance_overloads.html">Performance Overloads</a></li><li><a class="toctext" href="diffeq_arrays.html">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="diffeq_operator.html">DiffEqOperators</a></li><li><a class="toctext" href="noise_process.html">Noise Processes</a></li><li class="current"><a class="toctext" href="linear_nonlinear.html">Specifying (Non)Linear Solvers</a><ul class="internal"><li><a class="toctext" href="#Linear-Solvers:-linsolve-Specification-1">Linear Solvers: <code>linsolve</code> Specification</a></li><li><a class="toctext" href="#Nonlinear-Solvers:-nlsolve-Specification-1">Nonlinear Solvers: <code>nlsolve</code> Specification</a></li></ul></li><li><a class="toctext" href="callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="callback_library.html">Callback Library</a></li><li><a class="toctext" href="monte_carlo.html">Parallel Monte Carlo Simulations</a></li><li><a class="toctext" href="io.html">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="mesh.html">Meshes</a></li><li><a class="toctext" href="progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../analysis/parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="../analysis/parameter_estimation.html">Parameter Estimation</a></li><li><a class="toctext" href="../analysis/bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="../analysis/sensitivity.html">Sensitivity Analysis</a></li><li><a class="toctext" href="../analysis/uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="../analysis/dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/physical.html">Physical Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Biological Models</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Additional Features</li><li><a href="linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/tree/74c2a5fa3238f793f15769776e0eebbec330089f/docs/src/features/linear_nonlinear.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Specifying (Non)Linear Solvers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Specifying-(Non)Linear-Solvers-1" href="#Specifying-(Non)Linear-Solvers-1">Specifying (Non)Linear Solvers</a></h1><p>One of the key features of DifferentialEquations.jl is its flexibility. Keeping with this trend, many of the native Julia solvers provided by DifferentialEquations.jl allow you to choose the method for linear and nonlinear solving. This section details how to make that choice.</p><h2><a class="nav-anchor" id="Linear-Solvers:-linsolve-Specification-1" href="#Linear-Solvers:-linsolve-Specification-1">Linear Solvers: <code>linsolve</code> Specification</a></h2><p>For differential equation integrators which use linear solvers, an argument to the method <code>linsolve</code> determines the linear solver which is used. The signature is:</p><pre><code class="language-julia">linsolve!(x,A,b,matrix_updated=false)</code></pre><p>This is an in-place function which updates <code>x</code> by solving <code>Ax=b</code>. <code>matrix_updated</code> determines whether the matrix <code>A</code> has changed from the last call. This can be used to smartly cache factorizations.</p><h3><a class="nav-anchor" id="Basic-linsolve-method:-Factorization-1" href="#Basic-linsolve-method:-Factorization-1">Basic linsolve method: Factorization</a></h3><p>The easiest way to specify a <code>linsolve</code> is by a <code>factorization</code> function which generates a type on which <code>\</code> (or <code>A_ldiv_B!</code>) is called.  This is done through the helper function <code>LinSolveFactorize</code> which makes the appropriate function. For example, the  <code>Rosenbrock23</code> takes in a <code>linsolve</code> function, which we can choose to be a  QR-factorization by:</p><pre><code class="language-julia">Rosenbrock23(linsolve=LinSolveFactorize(qrfact!))</code></pre><p>LinSolveFactorize takes in a function which returns an object that can <code>\</code>. Direct methods like <code>qrfact!</code> will automatically cache the factorization, making it efficient for small dense problems.</p><p>However, for large sparse problems, you can let <code>\</code> be an iterative method. For example, using PETSc.jl, we can define our factorization function to be:</p><pre><code class="language-julia">linsolve = LinSolveFactorize((A) -&gt; KSP(A, ksp_type=&quot;gmres&quot;, ksp_rtol=1e-6))</code></pre><p>This function creates a <code>KSP</code> type which makes <code>\</code> perform the GMRES iterative method provided by PETSc.jl. Thus if we pass this function into the algorithm as the factorization method, all internal linear solves will happen by PETSc.jl.</p><h3><a class="nav-anchor" id="How-LinSolveFactorize-Was-Created-1" href="#How-LinSolveFactorize-Was-Created-1">How LinSolveFactorize Was Created</a></h3><p>In order to make your own <code>linsolve</code> functions, let&#39;s look at how the <code>LinSolveFactorize</code> function is created. For example, for an LU-Factorization, we would like to use <code>lufact!</code> to do our linear solving. We can directly write this as:</p><pre><code class="language-julia">function linsolve!(x,A,b,update_matrix=false)
  _A = lufact!(A)
  A_ldiv_B!(x,_A,b)
end</code></pre><p>This method works fine and you can pass it to the methods like</p><pre><code class="language-julia">Rosenbrock23(linsolve=linsolve!)</code></pre><p>and it will work, but this method does not cache <code>_A</code>, the factorization. This means that, even if <code>A</code> has not changed, it will re-factorize the matrix.</p><p>To change this, we can instead create a call-overloaded type. The generalized form of this is:</p><pre><code class="language-julia">type LinSolveFactorize{F}
  factorization::F
  A
end
LinSolveFactorize(factorization) = LinSolveFactorize(factorization,nothing)
function (p::LinSolveFactorize)(x,A,b,matrix_updated=false)
  if matrix_updated
    p.A = p.factorization(A)
  end
  A_ldiv_B!(x,p.A,b)
end
linsolve = LinSolveFactorize(lufact!)</code></pre><p><code>LinSolveFactorize</code> is a type which holds the factorization method and the pre-factorized matrix. If <code>matrix_updated</code> is true, it will re-compute the factorization. Otherwise it just solves the linear system with the cached factorization. This general idea of using a call-overloaded type can be employed to do many other things.</p><h2><a class="nav-anchor" id="Nonlinear-Solvers:-nlsolve-Specification-1" href="#Nonlinear-Solvers:-nlsolve-Specification-1">Nonlinear Solvers: <code>nlsolve</code> Specification</a></h2><p>Nonlinear solvers can be chosen via the <code>nlsolve</code> option. An <code>nlsolve</code> function should have two dispatches:</p><ul><li><p><code>nlsolve(Val{init},f,u0_prototype)</code> : Does an initialization phase. Returns a type <code>init_f</code> for later use in the solver. <code>u0_prototype</code> is the expected type for the initial condition <code>u0</code>.</p></li><li><p><code>nlsolve(init_f,u0)</code> : Solves for the root units the initialized <code>f</code> and the initial condition <code>u0</code>. Returns the zeros of the equation.</p></li></ul><h3><a class="nav-anchor" id="Basic-nlsolve-mehtod:-NLSOLVEJL_SETUP-1" href="#Basic-nlsolve-mehtod:-NLSOLVEJL_SETUP-1">Basic nlsolve mehtod: <code>NLSOLVEJL_SETUP</code></a></h3><p>By default, a basic nonlinear solver setup is given as <code>NLSOLVEJL_SETUP</code>. For example, the default <code>nlsolve</code> in <code>Trapezoid</code> is</p><pre><code class="language-julia">Trapezoid(nlsolve=NLSOLVEJL_SETUP())</code></pre><p>This will use NLsolve.jl with autodifferentiation to solve the nonlinear systems. <code>NLSOLVEJL_SETUP</code> has two options:</p><ul><li><p><code>chunk_size</code> : The autodifferentiation chunk size. Integer. Defaults to ForwardDiff.jl&#39;s auto-detection.</p></li><li><p><code>autodiff</code> : Whether to use autodifferentiation. Defaults to true.</p></li></ul><p>For example, to turn off autodifferentiation, use</p><pre><code class="language-julia">Trapezoid(nlsolve=NLSOLVEJL_SETUP(autodiff=false))</code></pre><h3><a class="nav-anchor" id="How-NLSOLVEJL_SETUP-Was-Created-1" href="#How-NLSOLVEJL_SETUP-Was-Created-1">How NLSOLVEJL_SETUP Was Created</a></h3><p>To create a nonlinear solver, you need to define the two functions. Here we use a call-overloaded type so that way we can hold the chunk size and autodifferentiation information.</p><pre><code class="language-julia">immutable NLSOLVEJL_SETUP{CS,AD} end
Base.@pure NLSOLVEJL_SETUP(;chunk_size=0,autodiff=true) = NLSOLVEJL_SETUP{chunk_size,autodiff}()</code></pre><p>The solver function just calls NLsolve and returns the zeros</p><pre><code class="language-julia">(p::NLSOLVEJL_SETUP)(f,u0) = (res=NLsolve.nlsolve(f,u0); res.zero)</code></pre><p>while the initialization function has a different initialization for autodifferentiation or not:</p><pre><code class="language-julia">function (p::NLSOLVEJL_SETUP{CS,AD}){CS,AD}(::Type{Val{:init}},f,u0_prototype)
  if AD
    return non_autodiff_setup(f,u0_prototype)
  else
    return autodiff_setup(f,u0_prototype,Val{determine_chunksize(initial_x,CS)})
  end
end</code></pre><p>We need to declare the <code>get_chunksize</code> trait for the solver:</p><pre><code class="language-julia">get_chunksize{CS,AD}(x::NLSOLVEJL_SETUP{CS,AD}) = CS</code></pre><p>The initialization functions are directly for NLsolve. See the NLsolve.jl docs for the types of inputs it expects to see. This does exactly that:</p><pre><code class="language-julia">function autodiff_setup{CS}(f!, initial_x::Vector,chunk_size::Type{Val{CS}})

    permf! = (fx, x) -&gt; f!(x, fx)

    fx2 = copy(initial_x)
    jac_cfg = ForwardDiff.JacobianConfig{CS}(initial_x, initial_x)
    g! = (x, gx) -&gt; ForwardDiff.jacobian!(gx, permf!, fx2, x, jac_cfg)

    fg! = (x, fx, gx) -&gt; begin
        jac_res = DiffBase.DiffResult(fx, gx)
        ForwardDiff.jacobian!(jac_res, permf!, fx2, x, jac_cfg)
        DiffBase.value(jac_res)
    end

    return DifferentiableMultivariateFunction(f!, g!, fg!)
end

function non_autodiff_setup(f!, initial_x::Vector)
  DifferentiableMultivariateFunction(f!)
end</code></pre><footer><hr/><a class="previous" href="noise_process.html"><span class="direction">Previous</span><span class="title">Noise Processes</span></a><a class="next" href="callback_functions.html"><span class="direction">Next</span><span class="title">Event Handling and Callback Functions</span></a></footer></article></body></html>
