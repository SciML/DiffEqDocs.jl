<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Specifying (Non)Linear Solvers · DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/bvp_example.html">Boundary Value Problems</a></li><li><a class="toctext" href="../tutorials/additional.html">Additional Tutorials</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li><li><a class="toctext" href="../basics/integrator.html">Integrator Interface</a></li><li><a class="toctext" href="../basics/problem.html">Problem interface</a></li><li><a class="toctext" href="../basics/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../basics/compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Problems</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Problems</a></li><li><a class="toctext" href="../types/dynamical_types.html">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../types/split_ode_types.html">Split ODE Problems</a></li><li><a class="toctext" href="../types/steady_state_types.html">Steady State Problems</a></li><li><a class="toctext" href="../types/bvp_types.html">BVP Problems</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Problems</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Problems</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Problems</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Problems</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../solvers/discrete_solve.html">Discrete Solvers</a></li><li><a class="toctext" href="../solvers/ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="../solvers/dynamical_solve.html">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="../solvers/split_ode_solve.html">Split ODE Solvers</a></li><li><a class="toctext" href="../solvers/steady_state_solve.html">Steady State Solvers</a></li><li><a class="toctext" href="../solvers/bvp_solve.html">BVP Solvers</a></li><li><a class="toctext" href="../solvers/jump_solve.html">Jump Problem Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="../solvers/rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="../solvers/dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="../solvers/dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="../solvers/benchmarks.html">Solver Benchmarks</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="performance_overloads.html">DiffEqFunctions (Jacobians, Gradients, etc.) and Jacobian Types</a></li><li><a class="toctext" href="diffeq_arrays.html">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="diffeq_operator.html">DiffEqOperators</a></li><li><a class="toctext" href="noise_process.html">Noise Processes</a></li><li class="current"><a class="toctext" href="linear_nonlinear.html">Specifying (Non)Linear Solvers</a><ul class="internal"><li><a class="toctext" href="#Linear-Solvers:-linsolve-Specification-1">Linear Solvers: <code>linsolve</code> Specification</a></li><li><a class="toctext" href="#Nonlinear-Solvers:-nlsolve-Specification-1">Nonlinear Solvers: <code>nlsolve</code> Specification</a></li><li><a class="toctext" href="#Nonlinear-Solvers-for-Generic-Implicit-ODE-Solvers-1">Nonlinear Solvers for Generic Implicit ODE Solvers</a></li></ul></li><li><a class="toctext" href="callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="callback_library.html">Callback Library</a></li><li><a class="toctext" href="ensemble.html">Parallel Ensemble Simulations</a></li><li><a class="toctext" href="io.html">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../analysis/parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="../analysis/parameter_estimation.html">Parameter Estimation and Bayesian Analysis</a></li><li><a class="toctext" href="../analysis/bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="../analysis/sensitivity.html">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li><a class="toctext" href="../analysis/global_sensitivity.html">Global Sensitivity Analysis</a></li><li><a class="toctext" href="../analysis/uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="../analysis/neural_networks.html">Neural Networks</a></li><li><a class="toctext" href="../analysis/dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/physical.html">Physical Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Chemical Reaction Models</a></li><li><a class="toctext" href="../models/external_modeling.html">External Modeling Packages</a></li></ul></li><li><span class="toctext">APIs</span><ul><li><a class="toctext" href="../apis/diffeqbio.html">DiffEqBiological.jl API</a></li></ul></li><li><span class="toctext">Extra Details</span><ul><li><a class="toctext" href="../extras/timestepping.html">Timestepping Method Descriptions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Additional Features</li><li><a href="linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/blob/master/docs/src/features/linear_nonlinear.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Specifying (Non)Linear Solvers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Specifying-(Non)Linear-Solvers-1" href="#Specifying-(Non)Linear-Solvers-1">Specifying (Non)Linear Solvers</a></h1><p>One of the key features of DifferentialEquations.jl is its flexibility. Keeping with this trend, many of the native Julia solvers provided by DifferentialEquations.jl allow you to choose the method for linear and nonlinear solving. This section details how to make that choice.</p><h2><a class="nav-anchor" id="Linear-Solvers:-linsolve-Specification-1" href="#Linear-Solvers:-linsolve-Specification-1">Linear Solvers: <code>linsolve</code> Specification</a></h2><p>For differential equation integrators which use linear solvers, an argument to the method <code>linsolve</code> determines the linear solver which is used. The signature is:</p><pre><code class="language-julia">linsolve! = linsolve(Val{:init},f,x)
linsolve!(x,A,b,matrix_updated=false)</code></pre><p>This is an in-place function which updates <code>x</code> by solving <code>Ax=b</code>. The user should specify the function <code>linsolve(Val{:init},f,x)</code> which returns a <code>linsolve!</code> function. The setting <code>matrix_updated</code> determines whether the matrix <code>A</code> has changed from the last call. This can be used to smartly cache factorizations.</p><h3><a class="nav-anchor" id="Pre-Built-Linear-Solver-Choices-1" href="#Pre-Built-Linear-Solver-Choices-1">Pre-Built Linear Solver Choices</a></h3><p>The following choices of pre-built linear solvers exist:</p><ul><li>DefaultLinSolve</li><li>LinSolveFactorize</li><li>LinSolveGPUFactorize</li><li>LinSolveGMRES</li><li>LinSolveCG</li><li>LinSolveBiCGStabl</li><li>LinSolveChebyshev</li><li>LinSolveMINRES</li><li>LinSolveIterativeSolvers</li></ul><h3><a class="nav-anchor" id="DefaultLinSolve-1" href="#DefaultLinSolve-1">DefaultLinSolve</a></h3><p>The default linear solver is <code>DefaultLinSolve</code>. This method is adaptive, and automatically chooses an LU factorization choose for dense and sparse arrays, and is compatible with GPU-based arrays. When the Jacobian is an <code>AbstractDiffEqOperator</code>, i.e. is matrix-free, <code>DefaultLinSolve</code> defaults to using a <code>gmres</code> iterative solver.</p><h3><a class="nav-anchor" id="Basic-linsolve-method-choice:-Factorization-by-LinSolveFactorize-1" href="#Basic-linsolve-method-choice:-Factorization-by-LinSolveFactorize-1">Basic linsolve method choice: Factorization by LinSolveFactorize</a></h3><p>The easiest way to specify a <code>linsolve</code> is by a <code>factorization</code> function which generates a type on which <code>\</code> (or <code>A_ldiv_B!</code>) is called.  This is done through the helper function <code>LinSolveFactorize</code> which makes the appropriate function. For example, the  <code>Rosenbrock23</code> takes in a <code>linsolve</code> function, which we can choose to be a  QR-factorization by:</p><pre><code class="language-julia">Rosenbrock23(linsolve=LinSolveFactorize(qrfact!))</code></pre><p>LinSolveFactorize takes in a function which returns an object that can <code>\</code>. Direct methods like <code>qrfact!</code> will automatically cache the factorization, making it efficient for small dense problems.</p><p>However, for large sparse problems, you can let <code>\</code> be an iterative method. For example, using PETSc.jl, we can define our factorization function to be:</p><pre><code class="language-julia">linsolve = LinSolveFactorize((A) -&gt; KSP(A, ksp_type=&quot;gmres&quot;, ksp_rtol=1e-6))</code></pre><p>This function creates a <code>KSP</code> type which makes <code>\</code> perform the GMRES iterative method provided by PETSc.jl. Thus if we pass this function into the algorithm as the factorization method, all internal linear solves will happen by PETSc.jl.</p><h3><a class="nav-anchor" id="GPU-offloading-of-factorization-with-LinSolveGPUFactorize-1" href="#GPU-offloading-of-factorization-with-LinSolveGPUFactorize-1">GPU offloading of factorization with LinSolveGPUFactorize</a></h3><p>If one has a problem with a sufficiently large Jacobian (~100x100) and a sufficiently powerful GPU, it can make sense to offload the factorization and backpropogation steps to the GPU. For this, the <code>LinSolveGPUFactorize</code> linear solver is provided. It works similarly to <code>LinSolveFactorize</code>, but the matrix is automatically sent to the GPU as a <code>CuArray</code> and the <code>ldiv!</code> is performed against a CUDA QR factorization of the matrix.</p><p>Note that this method requires that you have done <code>using CuArrays</code> in your script. A working installation of CuArrays.jl is required, which requires an installation of CUDA Toolkit.</p><h3><a class="nav-anchor" id="IterativeSolvers.jl-Based-Methods-1" href="#IterativeSolvers.jl-Based-Methods-1">IterativeSolvers.jl-Based Methods</a></h3><p>The signature for <code>LinSolveIterativeSolvers</code> is:</p><pre><code class="language-julia">LinSolveIterativeSolvers(generate_iterator,args...;
                         Pl=IterativeSolvers.Identity(),
                         Pr=IterativeSolvers.Identity(),
                         kwargs...)</code></pre><p>where <code>Pl</code> is the left preconditioner, <code>Pr</code> is the right preconditioner, and the other <code>args...</code> and <code>kwargs...</code> are passed into the iterative solver chosen in <code>generate_iterator</code> which designates the construction of an iterator from IterativeSolvers.jl. For example, using <code>gmres_iterable!</code> would make a version that uses <code>IterativeSolvers.gmres</code>. The following are aliases to common choices:</p><ul><li>LinSolveGMRES – GMRES</li><li>LinSolveCG – CG (Conjugate Gradient)</li><li>LinSolveBiCGStabl – BiCGStabl Stabilized Bi-Conjugate Gradient</li><li>LinSolveChebyshev – Chebyshev</li><li>LinSolveMINRES – MINRES</li></ul><p>which all have the same arguments as <code>LinSolveIterativeSolvers</code> except with <code>generate_iterator</code> pre-specified.</p><h3><a class="nav-anchor" id="Implementing-Your-Own-LinSolve:-How-LinSolveFactorize-Was-Created-1" href="#Implementing-Your-Own-LinSolve:-How-LinSolveFactorize-Was-Created-1">Implementing Your Own LinSolve: How LinSolveFactorize Was Created</a></h3><p>In order to make your own <code>linsolve</code> functions, let&#39;s look at how the <code>LinSolveFactorize</code> function is created. For example, for an LU-Factorization, we would like to use <code>lufact!</code> to do our linear solving. We can directly write this as:</p><pre><code class="language-julia">function linsolve!(::Type{Val{:init}},f,u0)
  function _linsolve!(x,A,b,update_matrix=false)
    _A = lufact!(A)
    ldiv!(x,_A,b)
  end
end</code></pre><p>This initialization function returns a linear solving function that always computes the LU-factorization and then does the solving. This method works fine and you can pass it to the methods like</p><pre><code class="language-julia">Rosenbrock23(linsolve=linsolve!)</code></pre><p>and it will work, but this method does not cache <code>_A</code>, the factorization. This means that, even if <code>A</code> has not changed, it will re-factorize the matrix.</p><p>To change this, we can instead create a call-overloaded type. The generalized form of this is:</p><pre><code class="language-julia">mutable struct LinSolveFactorize{F}
  factorization::F
  A
end
LinSolveFactorize(factorization) = LinSolveFactorize(factorization,nothing)
function (p::LinSolveFactorize)(x,A,b,matrix_updated=false)
  if matrix_updated
    p.A = p.factorization(A)
  end
  A_ldiv_B!(x,p.A,b)
end
function (p::LinSolveFactorize)(::Type{Val{:init}},f,u0_prototype)
  LinSolveFactorize(p.factorization,nothing)
end
linsolve = LinSolveFactorize(lufact!)</code></pre><p><code>LinSolveFactorize</code> is a type which holds the factorization method and the pre-factorized matrix. When <code>linsolve</code> is passed to the ODE/SDE/etc. solver, it will use the function <code>linsolve(Val{:init},f,u0_prototype)</code> to create a <code>LinSolveFactorize</code> object which holds the factorization method and a cache for holding a factorized matrix. Then</p><pre><code class="language-julia">function (p::LinSolveFactorize)(x,A,b,matrix_updated=false)
  if matrix_updated
    p.A = p.factorization(A)
  end
  A_ldiv_B!(x,p.A,b)
end</code></pre><p>is what&#39;s used in the solver&#39;s internal loop. If <code>matrix_updated</code> is true, it will re-compute the factorization. Otherwise it just solves the linear system with the cached factorization. This general idea of using a call-overloaded type can be employed to do many other things.</p><h2><a class="nav-anchor" id="Nonlinear-Solvers:-nlsolve-Specification-1" href="#Nonlinear-Solvers:-nlsolve-Specification-1">Nonlinear Solvers: <code>nlsolve</code> Specification</a></h2><p>Nonlinear solvers can be chosen via the <code>nlsolve</code> option. Most algorithms use nonlinear solvers that are specialized for implicit ODE solvers. There are three pre-built <code>nlsolve</code>s:</p><ul><li><code>NLNewton()</code>: It is a modified Newton iteration solver, and it is the default <code>nlsolve</code> for most of the implicit ODE solvers. It converges the fastest, but requires more memory usage and linear system solve.</li><li><code>NLAnderson(n::Int)</code>: It is an Anderson acceleration solver. It converges faster than <code>NLFunctional</code> but slower than <code>NLNewton</code>. It does not require to solve a linear system. In development.</li><li><code>NLFunctional()</code>: It is a functional (Picard) iteration solver. It converges the slowest, but requires the least amount of memory.</li></ul><p>One can specify a nonlinear solver by</p><pre><code class="language-julia">ImplicitEuler(nlsolve = NLFunctional())</code></pre><h2><a class="nav-anchor" id="Nonlinear-Solvers-for-Generic-Implicit-ODE-Solvers-1" href="#Nonlinear-Solvers-for-Generic-Implicit-ODE-Solvers-1">Nonlinear Solvers for Generic Implicit ODE Solvers</a></h2><p>For ODE solvers with names that begin with <code>Generic</code>, they take more generic <code>nlsolve</code>. An <code>nlsolve</code> function should have two dispatches:</p><ul><li><code>nlsolve(Val{init},f,u0_prototype)</code> : Does an initialization phase. Returns a type <code>init_f</code> for later use in the solver. <code>u0_prototype</code> is the expected type for the initial condition <code>u0</code>.</li><li><code>nlsolve(init_f,u0)</code> : Solves for the root units the initialized <code>f</code> and the initial condition <code>u0</code>. Returns the zeros of the equation.</li></ul><h3><a class="nav-anchor" id="Basic-nlsolve-method:-NLSOLVEJL_SETUP-1" href="#Basic-nlsolve-method:-NLSOLVEJL_SETUP-1">Basic nlsolve method: <code>NLSOLVEJL_SETUP</code></a></h3><p>By default, a basic nonlinear solver setup is given as <code>NLSOLVEJL_SETUP</code>. For example, the default <code>nlsolve</code> in <code>GenericTrapezoid</code> is</p><pre><code class="language-julia">GenericTrapezoid(nlsolve=NLSOLVEJL_SETUP())</code></pre><p>This will use NLsolve.jl with autodifferentiation to solve the nonlinear systems. <code>NLSOLVEJL_SETUP</code> has two options:</p><ul><li><code>chunk_size</code> : The autodifferentiation chunk size. Integer. Defaults to ForwardDiff.jl&#39;s auto-detection.</li><li><code>autodiff</code> : Whether to use autodifferentiation. Defaults to true.</li></ul><p>For example, to turn off autodifferentiation, use</p><pre><code class="language-julia">Trapezoid(nlsolve=NLSOLVEJL_SETUP(autodiff=false))</code></pre><h4><a class="nav-anchor" id="How-NLSOLVEJL_SETUP-Was-Created-1" href="#How-NLSOLVEJL_SETUP-Was-Created-1">How NLSOLVEJL_SETUP Was Created</a></h4><p>To create a nonlinear solver, you need to define the two functions. Here we use a call-overloaded type so that way we can hold the chunk size and autodifferentiation information.</p><pre><code class="language-julia">struct NLSOLVEJL_SETUP{CS,AD} end
NLSOLVEJL_SETUP(;chunk_size=0,autodiff=true) = NLSOLVEJL_SETUP{chunk_size,autodiff}()</code></pre><p>The solver function just calls NLsolve and returns the zeros</p><pre><code class="language-julia">(p::NLSOLVEJL_SETUP)(f,u0) = (res=NLsolve.nlsolve(f,u0); res.zero)</code></pre><p>while the initialization function has a different initialization for autodifferentiation or not:</p><pre><code class="language-julia">function (p::NLSOLVEJL_SETUP{CS,AD})(::Type{Val{:init}},f,u0_prototype) where {CS,AD}
  if AD
    return non_autodiff_setup(f,u0_prototype)
  else
    return autodiff_setup(f,u0_prototype,Val{determine_chunksize(initial_x,CS)})
  end
end</code></pre><p>We need to declare the <code>get_chunksize</code> trait for the solver:</p><pre><code class="language-julia">get_chunksize(x::NLSOLVEJL_SETUP{CS,AD}) where {CS,AD} = CS</code></pre><p>The initialization functions are directly for NLsolve. See the NLsolve.jl docs for the types of inputs it expects to see. This does exactly that:</p><pre><code class="language-julia">function autodiff_setup(f!, initial_x::Vector,chunk_size::Type{Val{CS}}) where CS

    permf! = (fx, x) -&gt; f!(x, fx)

    fx2 = copy(initial_x)
    jac_cfg = ForwardDiff.JacobianConfig{CS}(initial_x, initial_x)
    g! = (x, gx) -&gt; ForwardDiff.jacobian!(gx, permf!, fx2, x, jac_cfg)

    fg! = (x, fx, gx) -&gt; begin
        jac_res = DiffBase.DiffResult(fx, gx)
        ForwardDiff.jacobian!(jac_res, permf!, fx2, x, jac_cfg)
        DiffBase.value(jac_res)
    end

    return DifferentiableMultivariateFunction(f!, g!, fg!)
end

function non_autodiff_setup(f!, initial_x::Vector)
  DifferentiableMultivariateFunction(f!)
end</code></pre><footer><hr/><a class="previous" href="noise_process.html"><span class="direction">Previous</span><span class="title">Noise Processes</span></a><a class="next" href="callback_functions.html"><span class="direction">Next</span><span class="title">Event Handling and Callback Functions</span></a></footer></article></body></html>
