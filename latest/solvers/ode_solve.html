<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ordinary Differential Equation Solvers · DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script></head><body><nav class="toc"><h1>DifferentialEquations.jl</h1><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations (ODE)</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations (SDE)</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations (DAE)</a></li><li><a class="toctext" href="../tutorials/fempoisson_example.html">Poisson Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femheat_example.html">Heat Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femstochastic_example.html">Stochastic Finite Element Method</a></li></ul></li><li><span class="toctext">Solver Options</span><ul><li class="current"><a class="toctext" href="ode_solve.html">Ordinary Differential Equation Solvers</a><ul class="internal"><li><a class="toctext" href="#Recommended-Methods-1">Recommended Methods</a></li><li><a class="toctext" href="#Full-List-of-Methods-1">Full List of Methods</a></li><li><a class="toctext" href="#List-of-Supplied-Tableaus-1">List of Supplied Tableaus</a></li><li><a class="toctext" href="#Analysis-of-Methods-1">Analysis of Methods</a></li></ul></li><li><a class="toctext" href="sde_solve.html">Stochastic Differential Equation Solvers</a></li><li><a class="toctext" href="dae_solve.html">Differential Algebraic Equation Solvers</a></li><li><a class="toctext" href="fempoisson_solve.html">Finite Element Method Poisson Equation Solvers</a></li><li><a class="toctext" href="femheat_solve.html">Finite Element Method Heat Equation Solvers</a></li><li><a class="toctext" href="fdmstokes_solve.html">Finite Difference Method Stokes Equation Solvers</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../man/ODEProblem.html">Defining an ODE Problem</a></li><li><a class="toctext" href="../man/SDEProblem.html">Defining a SDE Problem</a></li><li><a class="toctext" href="../man/FEMProblem.html">Defining a FEM Problem</a></li><li><a class="toctext" href="../man/StokesProblem.html">Defining a Stokes Problem</a></li><li><a class="toctext" href="../man/mesh.html">Meshes</a></li><li><a class="toctext" href="../man/solution.html">The Solution Type</a></li><li><a class="toctext" href="../man/output_specification.html">Output Specification</a></li><li><a class="toctext" href="../man/callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="../man/plot.html">Plot Functions</a></li><li><a class="toctext" href="../man/parameter_estimation.html">Parameter Estimation</a></li><li><a class="toctext" href="../man/function_definition_macros.html">Function Definition Macros</a></li><li><a class="toctext" href="../man/benchmarks.html">Benchmark Suite</a></li><li><a class="toctext" href="../man/convergence.html">Convergence Simulations</a></li><li><a class="toctext" href="../man/conditional_dependencies.html">Conditional Dependencies</a></li><li><a class="toctext" href="../man/progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Internal Documentation</span><ul><li><a class="toctext" href="../internals/contributors_guide.html">Contributor&#39;s Guide</a></li><li><a class="toctext" href="../internals/fem_tools.html">Internal Finite Element Tools</a></li><li><a class="toctext" href="../internals/extras.html">Extra Functions</a></li><li><a class="toctext" href="../internals/solver_helpers.html">Solver Helpers</a></li><li><a class="toctext" href="../internals/notes_on_algorithms.html">Notes on Algorithms</a></li><li><a class="toctext" href="../internals/function_index.html">Function Index</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver Options</li><li><a href="ode_solve.html">Ordinary Differential Equation Solvers</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/tree/c3c2ecb90c091f318bf6520338fd591a62518d9f/docs/src/solvers/ode_solve.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Ordinary-Differential-Equation-Solvers-1" href="#Ordinary-Differential-Equation-Solvers-1">Ordinary Differential Equation Solvers</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.solve-Tuple{DiffEqBase.AbstractODEProblem,AbstractArray}" href="#DiffEqBase.solve-Tuple{DiffEqBase.AbstractODEProblem,AbstractArray}"><code>DiffEqBase.solve</code></a> — <span class="docstring-category">Method</span>.</div><div><p><code>solve(prob::ODEProblem,tspan)</code></p><p>Solves the ODE defined by prob on the interval tspan. If not given, tspan defaults to [0,1].</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>Δt</code>: Sets the initial stepsize. Defaults to an automatic choice.</p></li><li><p><code>save_timeseries</code>: Saves the result at every timeseries_steps steps. Default is true.</p></li><li><p><code>timeseries_steps</code>: Denotes how many steps between saving a value for the timeseries. Defaults to 1.</p></li><li><p><code>tableau</code>: The tableau for an <code>:ExplicitRK</code> algorithm. Defaults to a Dormand-Prince 4/5 method.</p></li><li><p><code>adaptive</code> - Turns on adaptive timestepping for appropriate methods. Default is true.</p></li><li><p><code>γ</code> - The risk-factor γ in the q equation for adaptive timestepping. Default is .9.</p></li><li><p><code>timechoicealg</code> - Chooses the method which is used for making the adaptive timestep choices. Default is <code>:Lund</code> for Lund stabilization (PI stepsize control). The other option is <code>:Simple</code> for the standard simple error-based rejection</p></li><li><p><code>β</code> - The Lund stabilization β parameter. Defaults are algorithm-dependent.</p></li><li><p><code>qmax</code> - Defines the maximum value possible for the adaptive q. Default is 10.</p></li><li><p><code>abstol</code> - Absolute tolerance in adaptive timestepping. Defaults to 1e-3.</p></li><li><p><code>reltol</code> - Relative tolerance in adaptive timestepping. Defaults to 1e-6.</p></li><li><p><code>maxiters</code> - Maximum number of iterations before stopping. Defaults to 1e9.</p></li><li><p><code>Δtmax</code> - Maximum Δt for adaptive timestepping. Defaults to half the timespan.</p></li><li><p><code>Δtmin</code> - Minimum Δt for adaptive timestepping. Defaults to 1e-10.</p></li><li><p><code>autodiff</code> - Turns on/off the use of autodifferentiation (via ForwardDiff) in the implicit solvers which use <code>NLsolve</code>. Default is true.</p></li><li><p><code>internalnorm</code> - The norm for which error estimates are calculated. Default is 2.</p></li><li><p><code>progressbar</code> - Turns on/off the Juno progressbar. Defualt is false.</p></li><li><p><code>progress_steps</code> - Numbers of steps between updates of the progress bar. Default is 1000.</p></li><li><p><code>alg</code>: The solver algorithm. Defult is <code>:DP5</code>. Note that any keyword argument available in the external solvers are accessible via keyword arguemnts. For example, for the ODEInterface.jl algorithms, one can specify <code>SSBETA=0.03</code> as a keyword argument and it will do as it states in the ODEInterface.jl documentation. Common options such as <code>MAXSS</code> (max stepsize) are aliased to one can use the DifferentialEquations.jl syntax <code>Δtmax</code> or <code>MAXSS</code>. The possibilities for the solvers are:</p></li></ul><p>For a full list of algorithms, please see the solver documentation.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiffEq/OrdinaryDiffEq.jl/tree/31f81c4012ca8cd05bd7ed243feb084d971268ec/src/solve/ode_solve.jl#L1-L37">source</a><br/></section><h2><a class="nav-anchor" id="Recommended-Methods-1" href="#Recommended-Methods-1">Recommended Methods</a></h2><p>Currently, over 100 algorithm choices are available. This guide is to help you choose the right one.</p><h3><a class="nav-anchor" id="Non-Stiff-Problems-1" href="#Non-Stiff-Problems-1">Non-Stiff Problems</a></h3><p>For non-stiff problems, the native DifferentialEquations.jl algorithms are vastly more efficient than the other choices (ODEInterface and ODE.jl). For most non-stiff problems, we recommend <code>:DP5</code> (this is the default algorithm). When more robust error control is required, <code>:BS5</code> is a good choice. For fast solving at lower tolerances, we recommend <code>:BS3</code>. For tolerances which are at about the truncation error of Float64 (1e-16), we recommend <code>:DP8</code> as a robust choice and <code>:Vern6</code>, <code>:Vern7</code>, or <code>:Vern8</code> as an efficient choice.</p><p>For high accuracy non-stiff solving, we recommend the <code>:Feagin12</code> or <code>:Feagin14</code> methods. These are more robust than Adams-Bashforth methods to discontinuities and achieve very high precision, and are much more efficient than the extrapolation methods. Note that the Feagin methods are the only high-order optimized methods which do not include a high-order interpolant (they do include a 3rd order Hermite interpolation if needed). If a high-order method is needed with a high order interpolant, then you should choose <code>:Vern9</code> which is Order 9 with an Order 9 interpolant.</p><h3><a class="nav-anchor" id="Stiff-Problems-1" href="#Stiff-Problems-1">Stiff Problems</a></h3><p>For mildly stiff problems which are not oscillatory, <code>:Rosenbrock32</code> is a good choice. If there exist large oscillations, then this form (local extrapolated) is not L-stable, and thus it is recommended that you use <code>:Rosenbrock23</code> which is L-stable (but Order 2 instead of 3). As a native DifferentialEquations.jl solver, Julia-defined numbers will work. This method uses ForwardDiff to automatically guess the Jacobian. For faster solving when the Jacobian is known, use <code>radau</code>. For highly stiff problems where Julia-defined numbers need to be used (SIUnits, Arbs), <code>:Trapezoid</code> is the current best choice. However, for the most efficient highly stiff solvers, use <code>:radau</code> or <code>:cvode_BDF</code> provided by wrappers to the ODEInterface and Sundials packages respectively (<a href="http://juliadiffeq.github.io/DifferentialEquations.jl/latest/man/conditional_dependencies.html">see the conditional dependencies documentation</a>)</p><h2><a class="nav-anchor" id="Full-List-of-Methods-1" href="#Full-List-of-Methods-1">Full List of Methods</a></h2><p>Choose one of these methods with the <code>alg</code> keyword in <code>solve</code>.</p><ul><li><p>DifferentialEquations.jl</p></li></ul><p>Unless otherwise specified, the DifferentialEquations algorithms all come with a 3rd order Hermite polynomial interpolation. The algorithms denoted as having a &quot;free&quot; interpolation means that no extra steps are required for the interpolation. For the non-free higher order interpolating functions, the extra steps are computed lazily (i.e. not during the solve).</p><ul><li><p><code>:Euler</code>- The canonical forward Euler method.</p></li><li><p><code>:Midpoint</code> - The second order midpoint method.</p></li><li><p><code>:RK4</code> - The canonical Runge-Kutta Order 4 method.</p></li><li><p><code>:BS3</code> - Bogacki-Shampine 3/2 method.</p></li><li><p><code>:DP5</code> - Dormand-Prince&#39;s 5/4 Runge-Kutta method. (free 4th order interpolant)</p></li><li><p><code>Tsit5</code> - Tsitouras 5/4 Runge-Kutta method. (free 4th order interpolant)</p></li><li><p><code>BS5</code> - Bogacki-Shampine 5/4 Runge-Kutta method. (5th order interpolant)</p></li><li><p><code>Vern6</code> - Verner&#39;s &quot;Most Efficient&quot; 6/5 Runge-Kutta method. (6th order interpolant)</p></li><li><p><code>Vern7</code> - Verner&#39;s &quot;Most Efficient&quot; 7/6 Runge-Kutta method. (7th order interpolant)</p></li><li><p><code>TanYam7</code> - Tanaka-Yamashita 7 Runge-Kutta method.</p></li><li><p><code>DP8</code> - Hairer&#39;s 8/5/3 adaption of the Dormand-Prince 8 method Runge-Kutta method. (7th order interpolant)</p></li><li><p><code>TsitPap8</code> - Tsitouras-Papakostas 8/7 Runge-Kutta method.</p></li><li><p><code>Vern8</code> - Verner&#39;s &quot;Most Efficient&quot; 8/7 Runge-Kutta method. (8th order interpolant)</p></li><li><p><code>Vern9</code> - Verner&#39;s &quot;Most Efficient&quot; 9/8 Runge-Kutta method. (9th order interpolant)</p></li><li><p><code>:Feagin10</code> - Feagin&#39;s 10th-order Runge-Kutta method.</p></li><li><p><code>:Feagin12</code> - Feagin&#39;s 12th-order Runge-Kutta method.</p></li><li><p><code>:Feagin14</code> - Feagin&#39;s 14th-order Runge-Kutta method.</p></li><li><p><code>:ExplicitRK</code> - A general Runge-Kutta solver which takes in a tableau. Can be adaptive. Tableaus are specified via the keyword argument <code>tab=tableau</code>. The default tableau is for Dormand-Prince 4/5. Other supplied tableaus can be found in the Supplied Tableaus section.</p></li><li><p><code>:ImplicitEuler</code> - A 1st order implicit solver. Unconditionally stable.</p></li><li><p><code>:Trapezoid</code> - A second order unconditionally stable implicit solver. Good for highly stiff.</p></li><li><p><code>:Rosenbrock23</code> - An Order 2/3 L-Stable fast solver which is good for mildy stiff equations with oscillations.</p></li><li><p><code>:Rosenbrock32</code> - An Order 3/2 A-Stable fast solver which is good for mildy stiff equations without oscillations.</p></li><li><p>ODEInterface.jl</p></li><li><p><code>:dopri5</code> - Hairer&#39;s classic implementation of the Dormand-Prince 4/5 method.</p></li><li><p><code>:dop853</code> - Explicit Runge-Kutta 8(5,3) by Dormand-Prince</p></li><li><p><code>:odex</code> - GBS extrapolation-algorithm based on the midpoint rule</p></li><li><p><code>:seulex</code> - extrapolation-algorithm based on the linear implicit Euler method</p></li><li><p><code>:radau</code> - implicit Runge-Kutta (Radau IIA) of variable order between 5 and 13</p></li><li><p><code>:radau5</code> - implicit Runge-Kutta method (Radau IIA) of order 5</p></li><li><p>ODE.jl</p></li></ul><p>The ODE.jl algorithms all come with a 3rd order Hermite polynomial interpolation.</p><ul><li><p><code>:ode23</code> - Bogakai-Shampine&#39;s 2/3 method</p></li><li><p><code>:ode45</code> - Dormand-Prince&#39;s 4/5 method</p></li><li><p><code>:ode78</code> - Runge-Kutta-Fehlberg 7/8 method</p></li><li><p><code>:ode23s</code> - Rosenbrock&#39;s 2/3 method</p></li><li><p><code>:ode1</code> - Forward Euler</p></li><li><p><code>:ode2_midpoint</code> - Midpoint Method</p></li><li><p><code>:ode2_heun</code> - Heun&#39;s Method</p></li><li><p><code>:ode4</code> - RK4</p></li><li><p><code>:ode45_fe</code> - Runge-Kutta-Fehlberg 4/5 method</p></li><li><p>Sundials.jl</p></li><li><p><code>:cvode_BDF</code> - CVode Backward Differentiation Formula (BDF) solver.</p></li><li><p><code>:cvode_Adams</code> - CVode Adams-Moulton solver</p></li></ul><h2><a class="nav-anchor" id="List-of-Supplied-Tableaus-1" href="#List-of-Supplied-Tableaus-1">List of Supplied Tableaus</a></h2><p>A large variety of tableaus have been supplied by default. For the most useful and common algorithms, a hand-optimized version is supplied and is recommended for general uses (i.e. use <code>:DP5</code> instead of <code>:ExplicitRK</code> with <code>tableau=constructDormandPrince()</code>). However, these serve as a good method for comparing between tableaus and understanding the pros/cons of the methods. Implemented are every published tableau (that I know exist). Note that user-defined tableaus also are accepted. To see how to define a tableau, checkout the <a href="https://github.com/JuliaDiffEq/DifferentialEquations.jl/blob/master/src/ode/ode_tableaus.jl">premade tableau source code</a>. Tableau docstrings should have appropriate citations (if not, file an issue).</p><p>A plot recipes is provided which will plot the stability region for a given tableau.</p><h3><a class="nav-anchor" id="Explicit-Runge-Kutta-Methods-1" href="#Explicit-Runge-Kutta-Methods-1">Explicit Runge-Kutta Methods</a></h3><ul><li><p><code>constructEuler</code> - Euler&#39;s 1st order method.</p></li><li><p><code>constructHuen()</code> Huen&#39;s order 2 method.</p></li><li><p><code>constructRalston()</code> - Ralston&#39;s order 2 method.</p></li><li><p><code>constructKutta3</code> - Kutta&#39;s classic 3rd order method</p></li><li><p><code>constructRK4</code> - The classic 4th order &quot;Runge-Kutta&quot; method</p></li><li><p><code>constructRK438Rule</code> - The classic 4th order &quot;3/8th&#39;s Rule&quot; method</p></li><li><p><code>constructBogakiShampine3()</code> - Bogakai-Shampine&#39;s 2/3 method.</p></li><li><p><code>constructRKF4()</code> - Runge-Kutta-Fehlberg 3/4.</p></li><li><p><code>constructRKF5()</code> - Runge-Kutta-Fehlberg 4/5.</p></li><li><p><code>constructRungeFirst5()</code> - Runge&#39;s first 5th order method.</p></li><li><p><code>constructCassity5()</code> - Cassity&#39;s 5th order method.</p></li><li><p><code>constructLawson5()</code> - Lawson&#39;s 5th order method.</p></li><li><p><code>constructLutherKonen5</code> - Luther-Konen&#39;s first 5th order method.</p></li><li><p><code>constructLutherKonen52()</code> - Luther-Konen&#39;s second 5th order method.</p></li><li><p><code>constructLutherKonen53()</code> - Luther-Konen&#39;s third 5th order method.</p></li><li><p><code>constructPapakostasPapaGeorgiou5()</code> - Papakostas and PapaGeorgiou more stable order 5 method.</p></li><li><p><code>constructPapakostasPapaGeorgiou52()</code> - Papakostas and PapaGeorgiou more efficient order 5 method.</p></li><li><p><code>constructTsitouras5()</code> - Tsitouras&#39;s order 5 method.</p></li><li><p><code>constructBogakiShampine5()</code> - Bogaki and Shampine&#39;s Order 5 method.</p></li><li><p><code>constructSharpSmart5()</code> - Sharp and Smart&#39;s Order 5 method.</p></li><li><p><code>constructCashKarp()</code> - Cash-Karp method 4/5.</p></li><li><p><code>constructDormandPrince()</code> - Dormand-Prince 4/5.</p></li><li><p><code>constructButcher6()</code> - Butcher&#39;s first order 6 method.</p></li><li><p><code>constructButcher62()</code> - Butcher&#39;s second order 6 method.</p></li><li><p><code>constructButcher63()</code> - Butcher&#39;s third order 6 method.</p></li><li><p><code>constructDormandPrince6()</code> - Dormand-Prince&#39;s 5/6 method.</p></li><li><p><code>constructSharpVerner6()</code> Sharp-Verner&#39;s 5/6 method.</p></li><li><p><code>constructVerner916()</code> - Verner&#39;s more efficient order 6 method (1991).</p></li><li><p><code>constructVerner9162()</code> - Verner&#39;s second more efficient order 6 method (1991).</p></li><li><p><code>constructVernerRobust6()</code> - Verner&#39;s &quot;most robust&quot; order 6 method.</p></li><li><p><code>constructVernerEfficient6()</code> - Verner&#39;s &quot;most efficient&quot; order 6 method.</p></li><li><p><code>constructPapakostas6()</code> - Papakostas&#39;s order 6 method.</p></li><li><p><code>constructLawson6()</code> - Lawson&#39;s order 6 method.</p></li><li><p><code>constructTsitourasPapakostas6()</code> - Tsitouras and Papakostas&#39;s order 6 method.</p></li><li><p><code>constructDormandLockyerMcCorriganPrince6()</code> - the Dormand-Lockyer-McCorrigan-Prince order 6 method.</p></li><li><p><code>constructTanakaKasugaYamashitaYazaki6A()</code> - Tanaka-Kasuga-Yamashita-Yazaki order 6 method A.</p></li><li><p><code>constructTanakaKasugaYamashitaYazaki6B()</code> - Tanaka-Kasuga-Yamashita-Yazaki order 6 method B.</p></li><li><p><code>constructTanakaKasugaYamashitaYazaki6C()</code> - Tanaka-Kasuga-Yamashita-Yazaki order 6 method C.</p></li><li><p><code>constructTanakaKasugaYamashitaYazaki6D()</code> - Tanaka-Kasuga-Yamashita-Yazaki order 6 method D.</p></li><li><p><code>constructMikkawyEisa()</code> - Mikkawy and Eisa&#39;s order 6 method.</p></li><li><p><code>constructChummund6()</code> - Chummund&#39;s first order 6 method.</p></li><li><p><code>constructChummund62()</code> - Chummund&#39;s second order 6 method.</p></li><li><p><code>constructHuta6()</code> - Huta&#39;s first order 6 method.</p></li><li><p><code>constructHuta62()</code> - Huta&#39;s second order 6 method.</p></li><li><p><code>constructVerner6()</code> - An old order 6 method attributed to Verner.</p></li><li><p><code>constructDverk()</code> - The classic DVERK algorithm attributed to Verner.</p></li><li><p><code>constructClassicVerner6()</code> - A classic Verner order 6 algorithm (1978).</p></li><li><p><code>constructButcher7()</code> - Butcher&#39;s order 7 algorithm.</p></li><li><p><code>constructClassicVerner7()</code>- A classic Verner order 7 algorithm (1978).</p></li><li><p><code>constructVernerRobust7()</code> - Verner&#39;s &quot;most robust&quot; order 7 algorithm.</p></li><li><p><code>constructTanakaYamashitaStable7()</code> - Tanaka-Yamashita more stable order 7 algorithm.</p></li><li><p><code>constructTanakaYamashitaEfficient7()</code> - Tanaka-Yamashita more efficient order 7 algorithm.</p></li><li><p><code>constructSharpSmart7()</code> - Sharp-Smart&#39;s order 7 algorithm.</p></li><li><p><code>constructSharpVerner7()</code> - Sharp-Verner&#39;s order 7 algorithm.</p></li><li><p><code>constructVerner7()</code> - Verner&#39;s &quot;most efficient&quot; order 7 algorithm.</p></li><li><p><code>constructVernerEfficient7()</code> - Verner&#39;s &quot;most efficient&quot; order 7 algorithm.</p></li><li><p><code>constructClassicVerner8()</code> - A classic Verner order 8 algorithm (1978).</p></li><li><p><code>constructCooperVerner8()</code> - Cooper-Verner&#39;s first order 8 algorithm.</p></li><li><p><code>constructCooperVerner82()</code> - Cooper-Verner&#39;s second order 8 algorithm.</p></li><li><p><code>constructTsitourasPapakostas8()</code> - Tsitouras-Papakostas order 8 algorithm.</p></li><li><p><code>constructdverk78()</code> - The classic order 8 DVERK algorithm.</p></li><li><p><code>constructEnrightVerner8()</code> - Enright-Verner order 8 algorithm.</p></li><li><p><code>constructCurtis8()</code> - Curtis&#39; order 8 algorithm.</p></li><li><p><code>constructVerner8()</code> - Verner&#39;s &quot;most efficient&quot; order 8 algorithm.</p></li><li><p><code>constructRKF8()</code> - Runge-Kutta-Fehlberg Order 7/8 method.</p></li><li><p><code>constructDormandPrice8()</code> - Dormand-Prince Order 7/8 method.</p></li><li><p><code>constructDormandPrince8_64bit()</code> - Dormand-Prince Order 7/8 method. Coefficients are rational approximations good for 64 bits.</p></li><li><p><code>constructVernerRobust9()</code> - Verner&#39;s &quot;most robust&quot; order 9 method.</p></li><li><p><code>constructVernerEfficient9()</code> - Verner&#39;s &quot;most efficient&quot; order 9 method.</p></li><li><p><code>constructSharp9()</code> - Sharp&#39;s order 9 method.</p></li><li><p><code>constructTsitouras9()</code> - Tsitouras&#39;s first order 9 method.</p></li><li><p><code>constructTsitouras92()</code> - Tsitouras&#39;s second order 9 method.</p></li><li><p><code>constructCurtis10()</code> - Curtis&#39; order 10 method.</p></li><li><p><code>constructOno10()</code> - Ono&#39;s order 10 method.</p></li><li><p><code>constructFeagin10Tableau()</code> - Feagin&#39;s order 10 method.</p></li><li><p><code>constructCurtis10()</code> - Curtis&#39; order 10 method.</p></li><li><p><code>constructBaker10()</code> - Baker&#39;s order 10 method.</p></li><li><p><code>constructHairer10()</code> Hairer&#39;s order 10 method.</p></li><li><p><code>constructFeagin12Tableau()</code> - Feagin&#39;s order 12 method.</p></li><li><p><code>constructOno12()</code> - Ono&#39;s order 12 method.</p></li><li><p><code>constructFeagin14Tableau()</code> Feagin&#39;s order 14 method.</p></li></ul><h3><a class="nav-anchor" id="Implicit-Runge-Kutta-Methods-1" href="#Implicit-Runge-Kutta-Methods-1">Implicit Runge-Kutta Methods</a></h3><ul><li><p><code>constructImplicitEuler</code> - The 1st order Implicit Euler method.</p></li><li><p><code>constructMidpointRule</code> - The 2nd order Midpoint method.</p></li><li><p><code>constructTrapezoidalRule</code> - The 2nd order Trapezoidal rule (2nd order LobattoIIIA)</p></li><li><p><code>constructLobattoIIIA4</code> - The 4th order LobattoIIIA</p></li><li><p><code>constructLobattoIIIB2</code> - The 2nd order LobattoIIIB</p></li><li><p><code>constructLobattoIIIB4</code> - The 4th order LobattoIIIB</p></li><li><p><code>constructLobattoIIIC2</code> - The 2nd order LobattoIIIC</p></li><li><p><code>constructLobattoIIIC4</code> - The 4th order LobattoIIIC</p></li><li><p><code>constructLobattoIIICStar2</code> - The 2nd order LobattoIIIC*</p></li><li><p><code>constructLobattoIIICStar4</code> - The 4th order LobattoIIIC*</p></li><li><p><code>constructLobattoIIID2</code> - The 2nd order LobattoIIID</p></li><li><p><code>constructLobattoIIID4</code> - The 4th order LobattoIIID</p></li><li><p><code>constructRadauIA3</code> - The 3rd order RadauIA</p></li><li><p><code>constructRadauIA5</code> - The 5th order RadauIA</p></li><li><p><code>constructRadauIIA3</code> - The 3rd order RadauIIA</p></li><li><p><code>constructRadauIIA5</code> - The 5th order RadauIIA</p></li></ul><h2><a class="nav-anchor" id="Analysis-of-Methods-1" href="#Analysis-of-Methods-1">Analysis of Methods</a></h2><p>For an in-depth walkthrough of the various method pros/cons, see <a href="http://juliadiffeq.github.io/DifferentialEquations.jl/latest/internals/notes_on_algorithms.html">notes on algorithms</a></p><footer><hr/><a class="previous" href="../tutorials/femstochastic_example.html"><span class="direction">Previous</span><span class="title">Stochastic Finite Element Method</span></a><a class="next" href="sde_solve.html"><span class="direction">Next</span><span class="title">Stochastic Differential Equation Solvers</span></a></footer></article></body></html>
