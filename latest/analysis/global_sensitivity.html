<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Global Sensitivity Analysis · DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/bvp_example.html">Boundary Value Problems</a></li><li><a class="toctext" href="../tutorials/additional.html">Additional Tutorials</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li><li><a class="toctext" href="../basics/integrator.html">Integrator Interface</a></li><li><a class="toctext" href="../basics/problem.html">Problem interface</a></li><li><a class="toctext" href="../basics/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../basics/compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Problems</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Problems</a></li><li><a class="toctext" href="../types/dynamical_types.html">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../types/split_ode_types.html">Split ODE Problems</a></li><li><a class="toctext" href="../types/steady_state_types.html">Steady State Problems</a></li><li><a class="toctext" href="../types/bvp_types.html">BVP Problems</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Problems</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Problems</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Problems</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Problems</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../solvers/discrete_solve.html">Discrete Solvers</a></li><li><a class="toctext" href="../solvers/ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="../solvers/dynamical_solve.html">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="../solvers/split_ode_solve.html">Split ODE Solvers</a></li><li><a class="toctext" href="../solvers/steady_state_solve.html">Steady State Solvers</a></li><li><a class="toctext" href="../solvers/bvp_solve.html">BVP Solvers</a></li><li><a class="toctext" href="../solvers/jump_solve.html">Jump Problem Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="../solvers/rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="../solvers/dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="../solvers/dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="../solvers/benchmarks.html">Solver Benchmarks</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="../features/performance_overloads.html">DiffEqFunctions (Jacobians, Gradients, etc.) and Jacobian Types</a></li><li><a class="toctext" href="../features/diffeq_arrays.html">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="../features/diffeq_operator.html">DiffEqOperators</a></li><li><a class="toctext" href="../features/noise_process.html">Noise Processes</a></li><li><a class="toctext" href="../features/linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="../features/callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="../features/callback_library.html">Callback Library</a></li><li><a class="toctext" href="../features/monte_carlo.html">Parallel Monte Carlo Simulations</a></li><li><a class="toctext" href="../features/io.html">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="../features/low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="../features/progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="parameter_estimation.html">Parameter Estimation and Bayesian Analysis</a></li><li><a class="toctext" href="bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="sensitivity.html">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li class="current"><a class="toctext" href="global_sensitivity.html">Global Sensitivity Analysis</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Morris-Method-1">Morris Method</a></li><li><a class="toctext" href="#Sobol-Method-1">Sobol Method</a></li><li><a class="toctext" href="#Regression-Method-1">Regression Method</a></li><li><a class="toctext" href="#GSA-example-1">GSA example</a></li></ul></li><li><a class="toctext" href="uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="neural_networks.html">Neural Networks</a></li><li><a class="toctext" href="dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/physical.html">Physical Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Chemical Reaction Models</a></li><li><a class="toctext" href="../models/external_modeling.html">External Modeling Packages</a></li></ul></li><li><span class="toctext">APIs</span><ul><li><a class="toctext" href="../apis/diffeqbio.html">DiffEqBiological.jl API</a></li></ul></li><li><span class="toctext">Extra Details</span><ul><li><a class="toctext" href="../extras/timestepping.html">Timestepping Method Descriptions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Analysis Tools</li><li><a href="global_sensitivity.html">Global Sensitivity Analysis</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/blob/master/docs/src/analysis/global_sensitivity.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Global Sensitivity Analysis</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Global-Sensitivity-Analysis-1" href="#Global-Sensitivity-Analysis-1">Global Sensitivity Analysis</a></h1><p>Global Sensitivity Analysis (GSA) methods are used to quantify the uncertainty in output of a model w.r.t. the parameters, their individual contributions, or the contribution of their interactions. The type of GSA method to use depends on the interest of the user, below we describe the methods available in the suite at the moment (some more are already in development) and explain what is the output of each of the methods and what it represents.</p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>This functionality does not come standard with DifferentialEquations.jl. To use this functionality, you must install DiffEqSensitivty.jl:</p><pre><code class="language-julia">]add DiffEqSensitivity
using DiffEqSensitivty</code></pre><h2><a class="nav-anchor" id="Morris-Method-1" href="#Morris-Method-1">Morris Method</a></h2><p>The Morris method also known as Morris’s OAT method where OAT stands for One At a Time can be described in the following steps:</p><p>We calculate local sensitivity measures known as “elementary effects”, which are calculated by measuring the perturbation in the output of the model on changing one parameter.</p><p><span>$EE_i = \frac{f(x_1,x_2,..x_i+ \Delta,..x_k) - y}{\Delta}$</span></p><p>These are evaluated at various points in the input chosen such that a wide “spread” of the parameter space is explored and considered in the analysis, to provide an approximate global importance measure. The mean and variance of these elementary effects is computed. A high value of the mean implies that a parameter is important, a high variance implies that its effects are non-linear or the result of interactions with other inputs. This method does not evaluate separately the contribution from the interaction and the contribution of the parameters individually and gives the effects for each parameter which takes into cpnsideration all the interactions and its individual contribution.</p><p><code>morris_effects = morris_sensitivity(f,param_range,param_steps;relative_scale=false,kwargs...)</code></p><p><code>morris_effects = morris_sensitivity(prob::DiffEqBase.DEProblem,alg,t,param_range,param_steps;kwargs...)</code></p><p>Here, <code>f</code> is just the model (as a julia function or a <code>DEProblem</code>) you want to run the analysis on, <code>param_range</code> requires an array of 2-tuples with the lower bound and the upper bound, <code>param_steps</code> decides the value of <span>$\Delta$</span> in the equation above and <code>relative_scale</code>, the above equation takes the assumption that the parameters lie in the range <code>[0,1]</code> but as this is not always the case scaling is used to get more informative, scaled effects.</p><h2><a class="nav-anchor" id="Sobol-Method-1" href="#Sobol-Method-1">Sobol Method</a></h2><p>Sobol is a variance-based method and it decomposes the variance of the output of the model or system into fractions which can be attributed to inputs or sets of inputs. This helps to get not just the individual parameter&#39;s sensitivities but also gives a way to quantify the affect and sensitivity from the interaction between the parameters.</p><div>\[ Y = f_0+ \sum_{i=1}^d f_i(X_i)+ \sum_{i &lt; j}^d f_{ij}(X_i,X_j) ... + f_{1,2...d}(X_1,X_2,..X_d)\]</div><div>\[ Var(Y) = \sum_{i=1}^d V_i + \sum_{i &lt; j}^d V_{ij} + ... + V_{1,2...,d}\]</div><p>The Sobol Indices are &quot;order&quot;ed, the first order indices given by <span>$S_i = \frac{V_i}{Var(Y)}$</span> the contribution to the output variance of the main effect of <span>$X_i$</span>, therefore it measures the effect of varying <span>$X_i$</span> alone, but averaged over variations in other input parameters. It is standardised by the total variance to provide a fractional contribution. Higher-order interaction indices <span>$S_{i,j}, S_{i,j,k}$</span> and so on can be formed by dividing other terms in the variance decomposition by <span>$Var(Y)$</span>.</p><p><code>sobol_second_order = sobol_sensitivity(f,param_range,N,order=2)</code></p><p><code>sobol_second_order = sobol_sensitivity(prob::DiffEqBase.DEProblem,alg,t,param_range,N,order=2)</code></p><p>Here <code>f</code> and <code>param_range</code> are the same as Morris&#39;s, providing a uniform interface.</p><h2><a class="nav-anchor" id="Regression-Method-1" href="#Regression-Method-1">Regression Method</a></h2><p>If a sample of inputs and outputs <span>$(X^n, Y^n) = 􏰀(X^{i}_1, . . . , X^{i}_d, Y_i)_{i=1..n}$</span>􏰁 is available, it is possible to fit a linear model explaining the behavior of Y given the values of X, provided that the sample size n is sufficiently large (at least n &gt; d).</p><p>The measures provided for this analysis by us in DiffEqSensitivity.jl are</p><p>a) Pearson Correlation Coefficient:</p><div>\[r = \frac{\sum_{i=1}^{n} (x_i - \overline{x})(y_i - \overline{y})}{\sqrt{\sum_{i=1}^{n} (x_i - \overline{x})^2(y_i - \overline{y})^2}}\]</div><p>b) Standard Regression Coefficient (SRC):</p><div>\[SRC_j = \beta_{j} \sqrt{\frac{Var(X_j)}{Var(Y)}}\]</div><p>where <span>$\beta_j$</span> is the linear regression coefficient associated to <span>$X_j$</span>.</p><p>c) Partial Correlation Coefficient (PCC):</p><div>\[PCC_j = \rho(X_j - \hat{X_{-j}},Y_j - \hat{Y_{-j}})\]</div><p>where <span>$\hat{X_{-j}}$</span>􏰈 is the prediction of the linear model, expressing <span>$X_{j}$</span>   with respect to the other inputs and <span>$\hat{Y􏰈_{-j}}$</span> is the prediction of the   linear model where <span>$X_j$</span> is absent. PCC measures the sensitivity of <span>$Y$</span> to   <span>$X_j$</span> when the effects of the other inputs have been canceled.</p><p><code>regre_sensitivity = regression_sensitivity(f,param_range,param_fixed,n;coeffs=:rank)</code></p><p><code>regre_sensitivity = regression_sensitivity(prob::DiffEqBase.DEProblem,alg,t,param_range,param_fixed,n;coeffs=:rank)</code></p><p>Again, <code>f</code> and <code>param_range</code> are the same as above. An array of the true parameter values that lie within the <code>param_range</code> bounds are passed through the <code>param_fixed</code> argument. <code>n</code> determines the number of simulations of the model run to generate the data points of the solution and parameter values and the <code>coeffs</code> kwarg lets you decide the coefficients you want.</p><h2><a class="nav-anchor" id="GSA-example-1" href="#GSA-example-1">GSA example</a></h2><p>Let&#39;s create the ODE problem to run our GSA on.</p><pre><code class="language-julia">function f(du,u,p,t)
  dx = p[1]*u[1] - p[2]*u[1]*u[2]
  dy = -3*u[2] + u[1]*u[2]
end
u0 = [1.0;1.0]
tspan = (0.0,10.0)
p = [1.5,1.0]
prob = ODEProblem(f,u0,tspan,p)
t = collect(range(0, stop=10, length=200))</code></pre><p>For Morris Method</p><pre><code class="language-julia">m = DiffEqSensitivity.morris_sensitivity(prob,Tsit5(),t,[[1,5],[0.5,5]],[10,10],len_trajectory=1500,total_num_trajectory=1000,num_trajectory=150)</code></pre><p>Let&#39;s get the means and variances from the <code>MorrisSensitivity</code> struct.</p><pre><code class="language-julia">m.means

Out[9]: 2-element Array{Array{Float64,2},1}:
 [0.0 0.0513678 … 7.91336 7.93783; 0.0 0.00115769 … 3.66156 3.67284]
 [0.0 0.0488899 … 2.50728 2.359; 0.0 0.00112006 … 2.23431 2.44946]

m.variances

Out[10]: 2-element Array{Array{Float64,2},1}:
 [0.0 1.94672e-5 … 26.4223 24.8513; 0.0 4.81347e-9 … 37.4061 30.3068]
 [0.0 1.77615e-5 … 17.9555 14.9231; 0.0 4.47931e-9 … 48.074 51.9312]</code></pre><p>This gives the means of the effects and it&#39;s variances over the entire timespan and thus we get 200-length arrays for each paramter and dependent variable pair.</p><p>We can plot the trajectory of the sensitivity with the standard deviation bars.</p><pre><code class="language-julia"># For the first parameter (a)
stdv1 = sqrt.(m.variances[1])
p = plot(m.means[1]&#39;, yerror=stdv1)</code></pre><p><img src="../assets/morris1.png" alt="morrisparameter1"/></p><pre><code class="language-julia"># For the second parameter (b)
stdv2 = sqrt.(m.variances[2])
p = plot(m.means[2]&#39;, yerror=stdv2)</code></pre><p><img src="../assets/morris2.png" alt="morrisparameter2"/></p><p>For Sobol Method</p><pre><code class="language-julia">
s0 = sobol_sensitivity(prob,Tsit5(),t,[[1,5],[0.5,5]],N,0)
Out[8]: 2-element Array{Array{Float64,2},1}:
 [NaN 0.507831 … 1.00731 1.00436; NaN 1.92336 … 0.732384 0.730945]
 [NaN 0.47214 … 0.676224 0.681525; NaN -1.68656 … 0.879557 0.877603]

s1 = sobol_sensitivity(prob,Tsit5(),t,[[1,5],[0.5,5]],N,1)
Out[9]: 2-element Array{Array{Float64,2},1}:
 [NaN 0.39537 … 0.341697 0.343645; NaN -2.06101 … 0.10922 0.106976]
 [NaN 0.652815 … 0.00910675 0.00815206; NaN 5.24832 … 0.296978 0.296639]

s2 = sobol_sensitivity(prob,Tsit5(),t,[[1,5],[0.5,5]],N,2)
Out[10]: 1-element Array{Array{Float64,2},1}:
 [NaN -0.0596478 … 0.652303 0.657847; NaN -1.84504 … 0.645139 0.620036]</code></pre><p>We can decide which order of Sobol Indices we are interested in my passing an argument for it, by default it gives the second order indices. Again the result is obtained over the entire <code>timespan</code></p><p>We plot the first order and total order Sobol Indices for some timepoints for each of the parameters (<code>a</code> and <code>b</code>).</p><pre><code class="language-julia">
p1 = bar([&quot;a&quot;,&quot;b&quot;],[s0[1][end-2],s0[2][end-2]],color=[:red,:blue],title=&quot;Total Order Indices at t=9.949748743718592&quot;,legend=false)
p2 = bar([&quot;a&quot;,&quot;b&quot;],[s1[1][end-2],s1[2][end-2]],color=[:red,:blue],title=&quot;First Order Indices at t=9.949748743718592&quot;,legend=false)
p3 = bar([&quot;a&quot;,&quot;b&quot;],[s0[1][3],s0[2][3]],color=[:red,:blue],title=&quot;Total Order Indices at t=0.05025125628140704&quot;,legend=false)
p4 = bar([&quot;a&quot;,&quot;b&quot;],[s1[1][3],s1[2][3]],color=[:red,:blue],title=&quot;First Order Indices at t=0.05025125628140704&quot;,legend=false)
plo = plot(p1,p2,p3,p4,layout=(4,1),size=(600,500))
</code></pre><p><img src="../assets/sobolbars.png" alt="sobolplot"/></p><p>Here we plot the Sobol indices of first order and the total Sobol indices for the parameters <code>a</code> and <code>b</code>. The plots are obtained by getting the Sobol Indices at the <code>t = 9.949748743718592</code> and the <code>t = 0.05025125628140704</code> time point of the first dependent variable <code>x(t)</code> from the 200-length sensitivities over the entire time span. The length of the bar represents the quantification of the sensitivity of the output to that parameter and hence for the 199th time point you can say that <code>x(t)</code> is more sensitive to <code>b</code>, also you can observe how the relative difference between <code>a</code> and <code>b</code> is larger in the first order than the total order indices, this tells us that most of the contribution of <code>a</code> to <code>x(t)</code> arises from interactions and it&#39;s individual non-interaction contribution is significantly lesser than <code>b</code> and vice-versa for <code>b</code> as it&#39;s first order plot indicates quite high value.</p><footer><hr/><a class="previous" href="sensitivity.html"><span class="direction">Previous</span><span class="title">Local Sensitivity Analysis (Automatic Differentiation)</span></a><a class="next" href="uncertainty_quantification.html"><span class="direction">Next</span><span class="title">Uncertainty Quantification</span></a></footer></article></body></html>
