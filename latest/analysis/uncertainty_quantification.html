<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Uncertainty Quantification · DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/fempoisson_example.html">Poisson Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femheat_example.html">Heat Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femstochastic_example.html">Stochastic Finite Element Method</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li><li><a class="toctext" href="../basics/integrator.html">Integrator Interface</a></li><li><a class="toctext" href="../basics/compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Problems</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Problems</a></li><li><a class="toctext" href="../types/dynamical_types.html">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../types/split_ode_types.html">Split ODE Problems</a></li><li><a class="toctext" href="../types/steady_state_types.html">Steady State Problems</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Problems</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Problems</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Problems</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Problems</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Problems</a></li><li><a class="toctext" href="../types/fem_types.html">FEM Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../solvers/discrete_solve.html">Discrete Solvers</a></li><li><a class="toctext" href="../solvers/ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="../solvers/dynamical_solve.html">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="../solvers/split_ode_solve.html">Split ODE Solvers</a></li><li><a class="toctext" href="../solvers/steady_state_solve.html">Steady State Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="../solvers/rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="../solvers/dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="../solvers/dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="../solvers/fempoisson_solve.html">FEM Poisson Solvers</a></li><li><a class="toctext" href="../solvers/femheat_solve.html">FEM Heat Solvers</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="../features/performance_overloads.html">Performance Overloads</a></li><li><a class="toctext" href="../features/diffeq_arrays.html">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="../features/diffeq_operator.html">DiffEqOperators</a></li><li><a class="toctext" href="../features/noise_process.html">Noise Processes</a></li><li><a class="toctext" href="../features/linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="../features/callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="../features/callback_library.html">Callback Library</a></li><li><a class="toctext" href="../features/monte_carlo.html">Parallel Monte Carlo Simulations</a></li><li><a class="toctext" href="../features/io.html">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="../features/low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="../features/mesh.html">Meshes</a></li><li><a class="toctext" href="../features/progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="parameter_estimation.html">Parameter Estimation</a></li><li><a class="toctext" href="bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="sensitivity.html">Sensitivity Analysis</a></li><li class="current"><a class="toctext" href="uncertainty_quantification.html">Uncertainty Quantification</a><ul class="internal"><li><a class="toctext" href="#ProbInts-1">ProbInts</a></li><li><a class="toctext" href="#Example-1:-FitzHugh-Nagumo-1">Example 1: FitzHugh-Nagumo</a></li><li><a class="toctext" href="#Example-2:-Adaptive-ProbInts-on-FitzHugh-Nagumo-1">Example 2: Adaptive ProbInts on FitzHugh-Nagumo</a></li><li><a class="toctext" href="#Example-3:-Adaptive-ProbInts-on-the-Lorenz-Attractor-1">Example 3: Adaptive ProbInts on the Lorenz Attractor</a></li></ul></li><li><a class="toctext" href="dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/physical.html">Physical Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Biological Models</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Analysis Tools</li><li><a href="uncertainty_quantification.html">Uncertainty Quantification</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/tree/519ce7142039cb9f5c415f1547318186aefb2bbc/docs/src/analysis/uncertainty_quantification.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Uncertainty Quantification</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Uncertainty-Quantification-1" href="#Uncertainty-Quantification-1">Uncertainty Quantification</a></h1><p>Uncertainty quantification allows a user to identify the uncertainty associated with the numerical approximation given by DifferentialEquations.jl. This page describes the different methods available for quantifying such uncertainties.</p><h2><a class="nav-anchor" id="ProbInts-1" href="#ProbInts-1">ProbInts</a></h2><p>The <a href="http://www2.warwick.ac.uk/fac/sci/statistics/staff/academic-research/girolami/probints">ProbInts</a> method for uncertainty quantification involves the transformation of an ODE into an associated SDE where the noise is related to the timesteps and the order of the algorithm. This is implemented into the DiffEq system via a callback function. The first form is:</p><pre><code class="language-julia">ProbIntsUncertainty(σ,order,save=true)</code></pre><p><code>σ</code> is the noise scaling factor and <code>order</code> is the order of the algorithm. <code>save</code> is for choosing whether this callback should control the saving behavior. Generally this is true unless one is stacking callbacks in a <code>CallbackSet</code>. It is recommended that <code>σ</code> is representative of the size of the errors in a single step of the equation.</p><p>If you are using an adaptive algorithm, the callback</p><pre><code class="language-julia">AdaptiveProbIntsUncertainty(order,save=true)</code></pre><p>determines the noise scaling automatically using an internal error estimate.</p><h2><a class="nav-anchor" id="Example-1:-FitzHugh-Nagumo-1" href="#Example-1:-FitzHugh-Nagumo-1">Example 1: FitzHugh-Nagumo</a></h2><p>In this example we will determine our uncertainty when solving the FitzHugh-Nagumo model with the <code>Euler()</code> method. We define the FitzHugh-Nagumo model using the <code>@ode_def</code> macro:</p><pre><code class="language-julia">fitz = @ode_def_nohes FitzhughNagumo begin
  dV = c*(V - V^3/3 + R)
  dR = -(1/c)*(V -  a - b*R)
end a=0.2 b=0.2 c=3.0
u0 = [-1.0;1.0]
tspan = (0.0,20.0)
prob = ODEProblem(fitz,u0,tspan)</code></pre><p>Now we define the <code>ProbInts</code> callback. In this case, our method is the <code>Euler</code> method and thus it is order 1. For the noise scaling, we will try a few different values and see how it changes. For <code>σ=0.2</code>, we define the callback as:</p><pre><code class="language-julia">cb = ProbIntsUncertainty(0.2,1)</code></pre><p>This is akin to having an error of approximately 0.2 at each step. We now build and solve a <a href="../features/monte_carlo.html">MonteCarloProblem</a> for 100 trajectories:</p><pre><code class="language-julia">monte_prob = MonteCarloProblem(prob)
sim = solve(monte_prob,Euler(),num_monte=100,callback=cb,dt=1/10)</code></pre><p>Now we can plot the resulting Monte Carlo solution:</p><pre><code class="language-julia">using Plots; plotly(); plot(sim,vars=(0,1),linealpha=0.4)</code></pre><p><img src="../assets/uncertainty_02.png" alt="uncertainty_02"/></p><p>If we increase the amount of error, we see that some parts of the equation have less uncertainty than others. For example, at <code>σ=0.5</code>:</p><pre><code class="language-julia">cb = ProbIntsUncertainty(0.5,1)
monte_prob = MonteCarloProblem(prob)
sim = solve(monte_prob,Euler(),num_monte=100,callback=cb,dt=1/10)
using Plots; plotly(); plot(sim,vars=(0,1),linealpha=0.4)</code></pre><p><img src="../assets/uncertainty_05.png" alt="uncertainty_05"/></p><p>But at this amount of noise, we can see how we contract to the true solution by decreasing <code>dt</code>:</p><pre><code class="language-julia">cb = ProbIntsUncertainty(0.5,1)
monte_prob = MonteCarloProblem(prob)
sim = solve(monte_prob,Euler(),num_monte=100,callback=cb,dt=1/100)
using Plots; plotly(); plot(sim,vars=(0,1),linealpha=0.4)</code></pre><p><img src="../assets/uncertainty_lowh.png" alt="uncertainty_lowh"/></p><h2><a class="nav-anchor" id="Example-2:-Adaptive-ProbInts-on-FitzHugh-Nagumo-1" href="#Example-2:-Adaptive-ProbInts-on-FitzHugh-Nagumo-1">Example 2: Adaptive ProbInts on FitzHugh-Nagumo</a></h2><p>While the first example is academic and shows how the ProbInts method scales, the fact that one should have some idea of the error in order to calibrate <code>σ</code> can lead to complications. Thus the more useful method in many cases is the <code>AdaptiveProbIntsUncertainty</code> version. In this version, no <code>σ</code> is required since this is calculated using an internal error estimate. Thus this gives an accurate representation of the possible error without user input.</p><p>Let&#39;s try this with the order 5 <code>Tsit5()</code> method on the same problem as before:</p><pre><code class="language-julia">cb = AdaptiveProbIntsUncertainty(5)
sol = solve(prob,Tsit5())
monte_prob = MonteCarloProblem(prob)
sim = solve(monte_prob,Tsit5(),num_monte=100,callback=cb)
using Plots; plotly(); plot(sim,vars=(0,1),linealpha=0.4)</code></pre><p><img src="../assets/uncertainty_adaptive_default.png" alt="uncertainty_adaptive_default"/></p><p>In this case, we see that the default tolerances give us a very good solution. However, if we increase the tolerance a lot:</p><pre><code class="language-julia">cb = AdaptiveProbIntsUncertainty(5)
sol = solve(prob,Tsit5())
monte_prob = MonteCarloProblem(prob)
sim = solve(monte_prob,Tsit5(),num_monte=100,callback=cb,abstol=1e-3,reltol=1e-1)
using Plots; plotly(); plot(sim,vars=(0,1),linealpha=0.4)</code></pre><p><img src="../assets/uncertainty_high_tolerance.png" alt="uncertainty_adaptive_default"/></p><p>we can see that the moments just after the rise can be uncertain.</p><h2><a class="nav-anchor" id="Example-3:-Adaptive-ProbInts-on-the-Lorenz-Attractor-1" href="#Example-3:-Adaptive-ProbInts-on-the-Lorenz-Attractor-1">Example 3: Adaptive ProbInts on the Lorenz Attractor</a></h2><p>One very good use of uncertainty quantification is on chaotic models. Chaotic equations diverge from the true solution according to the error exponentially. This means that as time goes on, you get further and further from the solution. The <code>ProbInts</code> method can help diagnose how much of the timeseries is reliable.</p><p>As in the previous example, we first define the model:</p><pre><code class="language-julia">g = @ode_def_bare LorenzExample begin
  dx = σ*(y-x)
  dy = x*(ρ-z) - y
  dz = x*y - β*z
end σ=&gt;10.0 ρ=&gt;28.0 β=(8/3)
u0 = [1.0;0.0;0.0]
tspan = (0.0,30.0)
prob = ODEProblem(g,u0,tspan)</code></pre><p>and then we build the <code>ProbInts</code> type. Let&#39;s use the order 5 <code>Tsit5</code> again.</p><pre><code class="language-julia">cb = AdaptiveProbIntsUncertainty(5)</code></pre><p>Then we solve the <code>MonteCarloProblem</code></p><pre><code class="language-julia">monte_prob = MonteCarloProblem(prob)
sim = solve(monte_prob,Tsit5(),num_monte=100,callback=cb)
using Plots; plotly(); plot(sim,vars=(0,1),linealpha=0.4)</code></pre><p><img src="../assets/uncertainty_chaos.png" alt="uncertainty_chaos"/></p><p>Here we see that by <code>t</code> about 22 we start to receive junk. We can increase the amount of time before error explosion by using a higher order method with stricter tolerances:</p><pre><code class="language-julia">tspan = (0.0,40.0)
prob = ODEProblem(g,u0,tspan)
cb = AdaptiveProbIntsUncertainty(7)
monte_prob = MonteCarloProblem(prob)
sim = solve(monte_prob,Vern7(),num_monte=100,callback=cb,reltol=1e-6)
using Plots; plotly(); plot(sim,vars=(0,1),linealpha=0.4)</code></pre><p><img src="../assets/uncertainty_high_order.png" alt="uncertainty_high_order"/></p><p>we see that we can extend the amount of time until we recieve junk.</p><footer><hr/><a class="previous" href="sensitivity.html"><span class="direction">Previous</span><span class="title">Sensitivity Analysis</span></a><a class="next" href="dev_and_test.html"><span class="direction">Next</span><span class="title">Algorithm Development and Testing</span></a></footer></article></body></html>
