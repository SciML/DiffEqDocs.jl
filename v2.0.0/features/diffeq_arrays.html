<!DOCTYPE html>

<html lang="en"><head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>DiffEq-Specific Array Types · DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="https://docs.juliadiffeq.org/stable/features/diffeq_arrays/index.html" rel="canonical"/></head><body><nav class="toc"><a href="../index.html"><img alt="DifferentialEquations.jl logo" class="logo" src="../assets/logo.png"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search.html" class="search"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/fempoisson_example.html">Poisson Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femheat_example.html">Heat Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femstochastic_example.html">Stochastic Finite Element Method</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li><li><a class="toctext" href="../basics/integrator.html">Integrator Interface</a></li><li><a class="toctext" href="../basics/compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Equation Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Types</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Types</a></li><li><a class="toctext" href="../types/refined_ode_types.html">Refined ODE Types</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Types</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Types</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Types</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Types</a></li><li><a class="toctext" href="../types/refined_dae_types.html">Refined DAE Types</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Types</a></li><li><a class="toctext" href="../types/fem_types.html">FEM Types</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../solvers/discrete_solve.html">Discrete Solvers</a></li><li><a class="toctext" href="../solvers/ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="../solvers/refined_ode_solve.html">Refined ODE Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="../solvers/rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="../solvers/dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="../solvers/dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="../solvers/fempoisson_solve.html">FEM Poisson Solvers</a></li><li><a class="toctext" href="../solvers/femheat_solve.html">FEM Heat Solvers</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="performance_overloads.html">Performance Overloads</a></li><li class="current"><a class="toctext" href="diffeq_arrays.html">DiffEq-Specific Array Types</a><ul class="internal"><li><a class="toctext" href="#ArrayPartitions-1">ArrayPartitions</a></li><li><a class="toctext" href="#MultiScaleArrays-1">MultiScaleArrays</a></li><li><a class="toctext" href="#DEDataArrays-1">DEDataArrays</a></li></ul></li><li><a class="toctext" href="noise_process.html">Noise Processes</a></li><li><a class="toctext" href="linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="callback_library.html">Callback Library</a></li><li><a class="toctext" href="monte_carlo.html">Parallel Monte Carlo Simulations</a></li><li><a class="toctext" href="low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="mesh.html">Meshes</a></li><li><a class="toctext" href="progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../analysis/parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="../analysis/parameter_estimation.html">Parameter Estimation</a></li><li><a class="toctext" href="../analysis/bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="../analysis/sensitivity.html">Sensitivity Analysis</a></li><li><a class="toctext" href="../analysis/uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="../analysis/dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Biological Models</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Additional Features</li><li><a href="diffeq_arrays.html">DiffEq-Specific Array Types</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/tree/185ba8daade2c430074650d2045c66e01e6322ef/docs/src/features/diffeq_arrays.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" href="#DiffEq-Specific-Array-Types-1" id="DiffEq-Specific-Array-Types-1">DiffEq-Specific Array Types</a></h1><p>In many cases, a standard array may not be enough to fully hold the data for a model. Many of the solvers in DifferentialEquations.jl allow you to solve problems on <code>AbstractArray</code> types which allow you to extend the meaning of an array. This page describes some of the <code>AbstractArray</code> types which can be helpful for modeling differential equations problems.</p><h2><a class="nav-anchor" href="#ArrayPartitions-1" id="ArrayPartitions-1">ArrayPartitions</a></h2><p>ArrayPartitions in DiffEq are used for heterogeneous arrays. For example, <code>PartitionedODEProblem</code> solvers use them internally to turn the separate parts into a single array. You can construct an <code>ArrayPartition</code> using RecursiveArrayTools.jl:</p><pre><code class="language-julia">using RecursiveArrayTools
A = ArrayPartition(x::AbstractArray...)</code></pre><p>where is a list of arrays. The resulting <code>A</code> will act like a single array, and its broadcast will be type stable, allowing for it to be used inside of the native Julia DiffEq solvers in an efficient way. This is a good way to generate an array which has different units for different parts, or different amounts of precision.</p><h3><a class="nav-anchor" href="#Usage-1" id="Usage-1">Usage</a></h3><p>An <code>ArrayPartition</code> acts like a single array. <code>A[i]</code> indexes through the first array, then the second, etc. all linearly. But <code>A.x</code> is where the arrays are stored. Thus for</p><pre><code class="language-julia">using RecursiveArrayTools
A = ArrayPartition(y,z)</code></pre><p>We would have <code>A.x[1]==y</code> and <code>A.x[2]==z</code>. Broadcasting like <code>f.(A)</code> is efficient.</p><h3><a class="nav-anchor" href="#Example:-Dynamics-Equations-1" id="Example:-Dynamics-Equations-1">Example: Dynamics Equations</a></h3><p>In this example we will show using heterogeneous units in dynamics equations. Our arrays will be:</p><pre><code class="language-julia">using Unitful, RecursiveArrayTools, DiffEqBase, OrdinaryDiffEq

r0 = [1131.340, -2282.343, 6672.423]u"km"
v0 = [-5.64305, 4.30333, 2.42879]u"km/s"
Δt = 86400.0*365u"s"
mu = 398600.4418u"km^3/s^2"
rv0 = ArrayPartition(r0,v0)</code></pre><p>Here, <code>r0</code> is the initial positions, and <code>v0</code> are the initial velocities. <code>rv0</code> is the <code>ArrayPartition</code> initial condition. We now write our update function in terms of the <code>ArrayPartition</code>:</p><pre><code class="language-julia">function f(t, y, dy, μ)
    r = norm(y.x[1])
    dy.x[1] .= y.x[2]
    dy.x[2] .= -μ .* y.x[1] / r^3
end</code></pre><p>Notice that <code>y.x[1]</code> is the <code>r</code> part of <code>y</code>, and <code>y.x[2]</code> is the <code>v</code> part of <code>y</code>. Using this kind of indexing is type stable, even though the array itself is heterogeneous. Note that one can also use things like <code>2y</code> or <code>y.+x</code> and the broadcasting will be efficient.</p><p>Now to solve our equations, we do the same thing as always in DiffEq:</p><pre><code class="language-julia">prob = ODEProblem((t, y, dy) -&gt; f(t, y, dy, mu), rv0, (0.0u"s", Δt))
sol = solve(prob, Vern8())</code></pre><h2><a class="nav-anchor" href="#MultiScaleArrays-1" id="MultiScaleArrays-1">MultiScaleArrays</a></h2><p>The multi-scale modeling functionality is provided by MultiScaleArrays.jl. It allows for designing a multi-scale model as an extension of an array, which in turn can be directly used in the native Julia solvers of DifferentialEquations.jl.</p><p>For more information, please see <a href="https://github.com/JuliaDiffEq/MultiScaleArrays.jl">the MultiScaleArrays.jl README</a>.</p><h2><a class="nav-anchor" href="#DEDataArrays-1" id="DEDataArrays-1">DEDataArrays</a></h2><p>The <code>DEDataArray{T}</code> type allows one to add other "non-continuous" variables to an array, which can be useful in many modeling situations involving lots of events. To define an <code>DEDataArray</code>, make a type which subtypes <code>DEDataArray{T}</code> with a field <code>x</code> for the "array of continuous variables" for which you would like the differential equation to treat directly. For example:</p><pre><code class="language-julia">type MyDataArray{T} &lt;: DEDataArray{T}
    x::Array{T,1}
    a::T
    b::Symbol
end</code></pre><p>In this example, our resultant array is a <code>SimType</code>, and its data which is presented to the differential equation solver will be the array <code>x</code>. Any array which the differential equation solver can use is allowed to be made as the field <code>x</code>, including other <code>DEDataArray</code>s. Other than that, you can add whatever fields you please, and let them be whatever type you please. These extra fields are carried along in the differential equation solver that the user can use in their <code>f</code> equation and modify via callbacks.</p><h3><a class="nav-anchor" href="#Example:-A-Control-Problem-1" id="Example:-A-Control-Problem-1">Example: A Control Problem</a></h3><p>In this example we will use a <code>DEDataArray</code> to solve a problem where control parameters change at various timepoints. First we will build</p><pre><code class="language-julia">type SimType{T} &lt;: DEDataArray{T}
    x::Array{T,1}
    f1::T
end</code></pre><p>as our <code>DEDataArray</code>. It has an extra field <code>f1</code> which we will use as our control variable. Our ODE function will use this field as follows:</p><pre><code class="language-julia">function f(t,u,du)
    du[1] = -0.5*u[1] + u.f1
    du[2] = -0.5*u[2]
end</code></pre><p>Now we will setup our control mechanism. It will be a simple setup which uses set timepoints at which we will change <code>f1</code>. At <code>t=5.0</code> we will want to increase the value of <code>f1</code>, and at <code>t=8.0</code> we will want to decrease the value of <code>f1</code>. Using the <a href="callback_functions.html"><code>DiscreteCallback</code> interface</a>, we code these conditions as follows:</p><pre><code class="language-julia">const tstop1 = [5.]
const tstop2 = [8.]


function condition(t,u,integrator)
  t in tstop1
end

function condition2(t,u,integrator)
  t in tstop2
end</code></pre><p>Now we have to apply an affect when these conditions are reached. When <code>condition</code> is hit (at <code>t=5.0</code>), we will increase <code>f1</code> to 1.5. When <code>condition2</code> is reached, we will decrease <code>f1</code> to <code>-1.5</code>. This is done via the affects:</p><pre><code class="language-julia">function affect!(integrator)
  for c in user_cache(integrator)
    c.f1 = 1.5
  end
end

function affect2!(integrator)
  for c in user_cache(integrator)
    c.f1 = -1.5
  end
end</code></pre><p>Notice that we have to loop through the <code>user_cache</code> array (provided by the integrator interface) to ensure that all internal caches are also updated. With these functions we can build our callbacks:</p><pre><code class="language-julia">save_positions = (true,true)

cb = DiscreteCallback(condition, affect!, save_positions=save_positions)

save_positions = (false,true)

cb2 = DiscreteCallback(condition2, affect2!, save_positions=save_positions)

cbs = CallbackSet(cb,cb2)</code></pre><p>Now we define our initial condition. We will start at <code>[10.0;10.0]</code> with <code>f1=0.0</code>.</p><pre><code class="language-julia">u0 = SimType([10.0;10.0], 0.0)
prob = ODEProblem(f,u0,(0.0,10.0))</code></pre><p>Lastly we solve the problem. Note that we must pass <code>tstop</code> values of <code>5.0</code> and <code>8.0</code> to ensure the solver hits those timepoints exactly:</p><pre><code class="language-julia">const tstop = [5.;8.]
sol = solve(prob,Tsit5(),callback = cbs, tstops=tstop)</code></pre><p><img alt="data_array_plot" src="../assets/data_array.png"/></p><p>It's clear from the plot how the controls affected the outcome.</p><h3><a class="nav-anchor" href="#Data-Arrays-vs-ParameterizedFunctions-1" id="Data-Arrays-vs-ParameterizedFunctions-1">Data Arrays vs ParameterizedFunctions</a></h3><p>The reason for using a <code>DEDataArray</code> is because the solution will then save the control parameters. For example, we can see what the control parameter was at every timepoint by checking:</p><pre><code class="language-julia">[sol[i].f1 for i in 1:length(sol)]</code></pre><p>A similar solution can be achieved using a <code>ParameterizedFunction</code>. We could have instead created our function as:</p><pre><code class="language-julia">function f(t,u,param,du)
    du[1] = -0.5*u[1] + param
    du[2] = -0.5*u[2]
end
pf = ParameterizedFunction(f,0.0)
u0 = SimType([10.0;10.0], 0.0)
prob = ODEProblem(f,u0,(0.0,10.0))
const tstop = [5.;8.]
sol = solve(prob,Tsit5(),callback = cbs, tstops=tstop)</code></pre><p>where we now change the callbacks to changing the parameter in the function:</p><pre><code class="language-julia">function affect!(integrator)
  integrator.f.params = 1.5
end

function affect2!(integrator)
  integrator.f.params = -1.5
end</code></pre><p>This will also solve the equation and get a similar result. It will also be slightly faster in some cases. However, if the equation is solved in this manner, there will be no record of what the parameter was at each timepoint. That is the tradeoff between <code>DEDataArray</code>s and <code>ParameterizedFunction</code>s.</p><footer><hr/><a class="previous" href="performance_overloads.html"><span class="direction">Previous</span><span class="title">Performance Overloads</span></a><a class="next" href="noise_process.html"><span class="direction">Next</span><span class="title">Noise Processes</span></a></footer></article></body></html>
