<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mass Matrix and Fully Implicit DAE Solvers · DifferentialEquations.jl</title><meta name="title" content="Mass Matrix and Fully Implicit DAE Solvers · DifferentialEquations.jl"/><meta property="og:title" content="Mass Matrix and Fully Implicit DAE Solvers · DifferentialEquations.jl"/><meta property="twitter:title" content="Mass Matrix and Fully Implicit DAE Solvers · DifferentialEquations.jl"/><meta name="description" content="Documentation for DifferentialEquations.jl."/><meta property="og:description" content="Documentation for DifferentialEquations.jl."/><meta property="twitter:description" content="Documentation for DifferentialEquations.jl."/><meta property="og:url" content="https://docs.sciml.ai/DiffEqDocs/stable/solvers/dae_solve/"/><meta property="twitter:url" content="https://docs.sciml.ai/DiffEqDocs/stable/solvers/dae_solve/"/><link rel="canonical" href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/dae_solve/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DifferentialEquations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">DifferentialEquations.jl: Efficient Differential Equation Solving in Julia</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started with Differential Equations in Julia</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/faster_ode_example/">Code Optimization for Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/advanced_ode_example/">Solving Large Stiff Equations</a></li><li><a class="tocitem" href="../../tutorials/sde_example/">Stochastic Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/rode_example/">Random Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dde_example/">Delay Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dae_example/">Differential Algebraic Equations</a></li><li><a class="tocitem" href="../../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="tocitem" href="../../tutorials/bvp_example/">Boundary Value Problems</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Beginner</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/classical_physics/">Classical Physics Models</a></li><li><a class="tocitem" href="../../examples/conditional_dosing/">Conditional Dosing in Pharmacometrics</a></li><li><a class="tocitem" href="../../examples/kepler_problem/">The Kepler Problem</a></li><li><a class="tocitem" href="../../examples/outer_solar_system/">Simulating the Outer Solar System</a></li><li><a class="tocitem" href="../../examples/min_and_max/">Finding Maxima and Minima of ODEs Solutions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Advanced</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/spiking_neural_systems/">Spiking Neural Systems</a></li><li><a class="tocitem" href="../../examples/beeler_reuter/">An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model</a></li><li><a class="tocitem" href="../../examples/diffusion_implicit_heat_equation/">Solving the heat equation with diffusion-implicit time-stepping</a></li></ul></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../basics/common_solver_opts/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../basics/solution/">Solution Handling</a></li><li><a class="tocitem" href="../../basics/plot/">Plot Functions</a></li><li><a class="tocitem" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="tocitem" href="../../basics/problem/">Problem Interface</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="tocitem">Problem Types</span><ul><li><a class="tocitem" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="tocitem" href="../../types/ode_types/">ODE Problems</a></li><li><a class="tocitem" href="../../types/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group Problems</a></li><li><a class="tocitem" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="tocitem" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="tocitem" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="tocitem" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="tocitem" href="../../types/sde_types/">SDE Problems</a></li><li><a class="tocitem" href="../../types/sdae_types/">SDAE Problems</a></li><li><a class="tocitem" href="../../types/rode_types/">RODE Problems</a></li><li><a class="tocitem" href="../../types/dde_types/">DDE Problems</a></li><li><a class="tocitem" href="../../types/sdde_types/">SDDE Problems</a></li><li><a class="tocitem" href="../../types/dae_types/">DAE Problems</a></li></ul></li><li><span class="tocitem">Solver Algorithms</span><ul><li><a class="tocitem" href="../discrete_solve/">Discrete Solvers</a></li><li><a class="tocitem" href="../ode_solve/">ODE Solvers</a></li><li><a class="tocitem" href="../nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group ODE Solvers</a></li><li><a class="tocitem" href="../dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="tocitem" href="../split_ode_solve/">Split ODE Solvers</a></li><li><a class="tocitem" href="../steady_state_solve/">Steady State Solvers</a></li><li><a class="tocitem" href="../bvp_solve/">BVP Solvers</a></li><li><a class="tocitem" href="../sde_solve/">SDE Solvers</a></li><li><a class="tocitem" href="../sdae_solve/">SDAE Solvers</a></li><li><a class="tocitem" href="../rode_solve/">RODE Solvers</a></li><li><a class="tocitem" href="../dde_solve/">DDE Solvers</a></li><li><a class="tocitem" href="../sdde_solve/">SDDE Solvers</a></li><li class="is-active"><a class="tocitem" href>Mass Matrix and Fully Implicit DAE Solvers</a><ul class="internal"><li><a class="tocitem" href="#Recommended-Methods"><span>Recommended Methods</span></a></li><li><a class="tocitem" href="#dae_solve_full"><span>Full List of Methods</span></a></li></ul></li><li><a class="tocitem" href="../benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="tocitem">Additional Features</span><ul><li><a class="tocitem" href="../../features/performance_overloads/">Jacobians, Gradients, etc.</a></li><li><a class="tocitem" href="../../features/diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="tocitem" href="../../features/diffeq_operator/">DiffEqOperators</a></li><li><a class="tocitem" href="../../features/noise_process/">Noise Processes</a></li><li><a class="tocitem" href="../../features/linear_nonlinear/">Specifying (Non)Linear Solvers and Preconditioners</a></li><li><a class="tocitem" href="../../features/callback_functions/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../features/callback_library/">Callback Library</a></li><li><a class="tocitem" href="../../features/ensemble/">Parallel Ensemble Simulations</a></li><li><a class="tocitem" href="../../features/io/">I/O: Saving and Loading Solution Data</a></li><li><a class="tocitem" href="../../features/low_dep/">Reduced Compile Time, Optimizing Runtime, and Low Dependency Usage</a></li><li><a class="tocitem" href="../../features/progress_bar/">Progress Bar Integration</a></li></ul></li><li><span class="tocitem">Detailed Solver APIs</span><ul><li><a class="tocitem" href="../../api/sundials/">Sundials.jl</a></li><li><a class="tocitem" href="../../api/daskr/">DASKR.jl</a></li></ul></li><li><span class="tocitem">Extra Details</span><ul><li><a class="tocitem" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solver Algorithms</a></li><li class="is-active"><a href>Mass Matrix and Fully Implicit DAE Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mass Matrix and Fully Implicit DAE Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/DiffEqDocs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/DiffEqDocs.jl/blob/master/docs/src/solvers/dae_solve.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Mass-Matrix-and-Fully-Implicit-DAE-Solvers"><a class="docs-heading-anchor" href="#Mass-Matrix-and-Fully-Implicit-DAE-Solvers">Mass Matrix and Fully Implicit DAE Solvers</a><a id="Mass-Matrix-and-Fully-Implicit-DAE-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Mass-Matrix-and-Fully-Implicit-DAE-Solvers" title="Permalink"></a></h1><h2 id="Recommended-Methods"><a class="docs-heading-anchor" href="#Recommended-Methods">Recommended Methods</a><a id="Recommended-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Recommended-Methods" title="Permalink"></a></h2><p>For medium to low accuracy small numbers of DAEs in constant mass matrix form, the  <code>Rosenbrock23</code> and <code>Rodas4</code> methods are good choices which will get good efficiency if the mass matrix is constant. <code>Rosenbrock23</code> is better for low accuracy (error tolerance <code>&lt;1e-4</code>) and <code>Rodas4</code> is better for high accuracy. Another choice at high accuracy is <code>Rodas5P</code> and <code>RadauIIA5</code>.</p><p>Non-constant mass matrices are not directly supported: users are advised to transform their problem through substitution to a DAE with constant mass matrices.</p><p>If the problem cannot be defined in mass matrix form, the recommended method for performance is <code>IDA</code> from the Sundials.jl package if you are solving problems with <code>Float64</code>. If Julia types are required, currently <code>DFBDF</code> is the best method but still needs more optimizations.</p><h2 id="dae_solve_full"><a class="docs-heading-anchor" href="#dae_solve_full">Full List of Methods</a><a id="dae_solve_full-1"></a><a class="docs-heading-anchor-permalink" href="#dae_solve_full" title="Permalink"></a></h2><h4 id="Initialization-Schemes"><a class="docs-heading-anchor" href="#Initialization-Schemes">Initialization Schemes</a><a id="Initialization-Schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization-Schemes" title="Permalink"></a></h4><p>For all OrdinaryDiffEq.jl methods, an initialization scheme can be set with a common keyword argument <code>initializealg</code>. The choices are:</p><ul><li><code>BrownFullBasicInit</code>: For Index-1 DAEs implicit DAEs and semi-explicit DAEs in mass matrix form. Keeps the differential variables constant. Requires <code>du0</code> when used on a <code>DAEProblem</code>.</li><li><code>ShampineCollocationInit</code>: For Index-1 DAEs implicit DAEs and semi-explicit DAEs in mass matrix form. Changes both the differential and algebraic variables.</li><li><code>NoInit</code>: Explicitly opts-out of DAE initialization.</li></ul><h3 id="OrdinaryDiffEq.jl-(Implicit-ODE)"><a class="docs-heading-anchor" href="#OrdinaryDiffEq.jl-(Implicit-ODE)">OrdinaryDiffEq.jl (Implicit ODE)</a><a id="OrdinaryDiffEq.jl-(Implicit-ODE)-1"></a><a class="docs-heading-anchor-permalink" href="#OrdinaryDiffEq.jl-(Implicit-ODE)" title="Permalink"></a></h3><p>These methods from OrdinaryDiffEq are for <code>DAEProblem</code> specifications.</p><ul><li><code>DImplicitEuler</code> - 1st order A-L and stiffly stable adaptive implicit Euler</li><li><code>DABDF2</code> - 2nd order A-L stable adaptive BDF method.</li><li><code>DFBDF</code> - A fixed-leading coefficient adaptive-order adaptive-time BDF method, similar to <code>ode15i</code> or <code>IDA</code> in divided differences form.</li></ul><h3 id="OrdinaryDiffEq.jl-(Mass-Matrix)"><a class="docs-heading-anchor" href="#OrdinaryDiffEq.jl-(Mass-Matrix)">OrdinaryDiffEq.jl (Mass Matrix)</a><a id="OrdinaryDiffEq.jl-(Mass-Matrix)-1"></a><a class="docs-heading-anchor-permalink" href="#OrdinaryDiffEq.jl-(Mass-Matrix)" title="Permalink"></a></h3><p>These methods require the DAE to be an <code>ODEProblem</code> in mass matrix form. For extra options for the solvers, see the ODE solver page.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The standard Hermite interpolation used for ODE methods in OrdinaryDiffEq.jl falls back to a linear interpolation on the differential variables. If the mass matrix is non-diagonal, the Hermite interpolation does not have a fallback and will error.</p></div></div><h4 id="Rosenbrock-Methods"><a class="docs-heading-anchor" href="#Rosenbrock-Methods">Rosenbrock Methods</a><a id="Rosenbrock-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Rosenbrock-Methods" title="Permalink"></a></h4><ul><li><code>ROS3P</code> - 3rd order A-stable and stiffly stable Rosenbrock method. Keeps high accuracy on discretizations of nonlinear parabolic PDEs.</li><li><code>Rodas3</code> - 3rd order A-stable and stiffly stable Rosenbrock method.</li><li><code>RosShamp4</code>- An A-stable 4th order Rosenbrock method.</li><li><code>Veldd4</code> - A 4th order D-stable Rosenbrock method.</li><li><code>Velds4</code> - A 4th order A-stable Rosenbrock method.</li><li><code>GRK4T</code> - An efficient 4th order Rosenbrock method.</li><li><code>GRK4A</code> - An A-stable 4th order Rosenbrock method. Essentially &quot;anti-L-stable&quot; but efficient.</li><li><code>Ros4LStab</code> - A 4th order L-stable Rosenbrock method.</li><li><code>Rodas4</code> - A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant</li><li><code>Rodas42</code> - A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant</li><li><code>Rodas4P</code> - A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems (as opposed to lower if not corrected).</li><li><code>Rodas4P2</code> - A 4th order L-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems. It is an improvement of Roadas4P and in case of inexact Jacobians a second order W method.</li><li><code>Rodas5</code> - A 5th order A-stable stiffly stable Rosenbrock method with a stiff-aware 4th order interpolant.</li><li><code>Rodas5P</code> - A 5th order A-stable stiffly stable Rosenbrock method with a stiff-aware 4th order interpolant. Has improved stability in the adaptive time stepping embedding.</li></ul><h4 id="Rosenbrock-W-Methods"><a class="docs-heading-anchor" href="#Rosenbrock-W-Methods">Rosenbrock-W Methods</a><a id="Rosenbrock-W-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Rosenbrock-W-Methods" title="Permalink"></a></h4><ul><li><code>Rosenbrock23</code> - An Order 2/3 L-Stable Rosenbrock-W method which is good for very stiff equations with oscillations at low tolerances. 2nd order stiff-aware interpolation.</li><li><code>Rosenbrock32</code> - An Order 3/2 A-Stable Rosenbrock-W method which is good for mildly stiff equations without oscillations at low tolerances. Note that this method is prone to instability in the presence of oscillations, so use with caution. 2nd order stiff-aware interpolation.</li><li><code>RosenbrockW6S4OS</code> - A 4th order L-stable Rosenbrock-W method (fixed step only).</li><li><code>ROS34PW1a</code> - A 4th order L-stable Rosenbrock-W method.</li><li><code>ROS34PW1b</code> - A 4th order L-stable Rosenbrock-W method.</li><li><code>ROS34PW2</code> - A 4th order stiffy accurate Rosenbrock-W method for PDAEs.</li><li><code>ROS34PW3</code> - A 4th order strongly A-stable (Rinf~0.63) Rosenbrock-W method.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>Rosenbrock23</code> and <code>Rosenbrock32</code> have a stiff-aware interpolation but this interpolation is not safe for the algebraic variables. Thus use the interpolation (and therefore <code>saveat</code>) with caution if the default Hermite interpolation is used.</p></div></div><h4 id="FIRK-Methods"><a class="docs-heading-anchor" href="#FIRK-Methods">FIRK Methods</a><a id="FIRK-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#FIRK-Methods" title="Permalink"></a></h4><ul><li><code>RadauIIA5</code> - An A-B-L stable fully implicit Runge-Kutta method with internal tableau complex basis transform for efficiency.</li></ul><h4 id="SDIRK-Methods"><a class="docs-heading-anchor" href="#SDIRK-Methods">SDIRK Methods</a><a id="SDIRK-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#SDIRK-Methods" title="Permalink"></a></h4><ul><li><code>ImplicitEuler</code> - Stage order 1. A-B-L-stable. Adaptive timestepping through a divided differences estimate via memory. Strong-stability preserving (SSP).</li><li><code>ImplicitMidpoint</code> - Stage order 1. Symplectic. Good for when symplectic integration is required.</li><li><code>Trapezoid</code> - A second order A-stable symmetric ESDIRK method. &quot;Almost symplectic&quot; without numerical dampening. Also known as Crank-Nicolson when applied to PDEs. Adaptive timestepping via divided differences on the memory. Good for highly stiff equations which are non-oscillatory.</li></ul><h4 id="Multistep-Methods"><a class="docs-heading-anchor" href="#Multistep-Methods">Multistep Methods</a><a id="Multistep-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Multistep-Methods" title="Permalink"></a></h4><p>Quasi-constant stepping is the time stepping strategy which matches the classic GEAR, LSODE,  and <code>ode15s</code> integrators. The variable-coefficient methods match the ideas of the classic EPISODE integrator and early VODE designs. The Fixed Leading Coefficient (FLC) methods match the behavior of the classic VODE and Sundials CVODE integrator.</p><ul><li><code>QNDF1</code> - An adaptive order 1 quasi-constant timestep L-stable numerical differentiation function (NDF) method. Optional parameter <code>kappa</code> defaults to Shampine&#39;s accuracy-optimal <code>-0.1850</code>.</li><li><code>QBDF1</code> - An adaptive order 1 L-stable BDF method. This is equivalent to implicit Euler but using the BDF error estimator.</li><li><code>ABDF2</code> - An adaptive order 2 L-stable fixed leading coefficient multistep BDF method.</li><li><code>QNDF2</code> - An adaptive order 2 quasi-constant timestep L-stable numerical differentiation function (NDF) method.</li><li><code>QBDF2</code> - An adaptive order 2 L-stable BDF method using quasi-constant timesteps.</li><li><code>QNDF</code> - An adaptive order quasi-constant timestep NDF method. Utilizes Shampine&#39;s accuracy-optimal <code>kappa</code> values as defaults (has a keyword argument for a tuple of <code>kappa</code> coefficients).</li><li><code>QBDF</code> - An adaptive order quasi-constant timestep BDF method.</li><li><code>FBDF</code> - A fixed-leading coefficient adaptive-order adaptive-time BDF method, similar to <code>ode15i</code> or <code>CVODE_BDF</code> in divided differences form.</li></ul><h3 id="dae_solve_sundials"><a class="docs-heading-anchor" href="#dae_solve_sundials">Sundials.jl</a><a id="dae_solve_sundials-1"></a><a class="docs-heading-anchor-permalink" href="#dae_solve_sundials" title="Permalink"></a></h3><p>Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use Sundials.jl:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;Sundials&quot;)
using Sundials</code></pre><ul><li><code>IDA</code>: A fixed-leading coefficient fully implicit BDF method. Efficient for large systems.</li></ul><p>For more details on controlling the Sundials.jl solvers, see the <a href="../../api/sundials/#sundials">Sundials detailed solver API page</a></p><h3 id="DASKR.jl"><a class="docs-heading-anchor" href="#DASKR.jl">DASKR.jl</a><a id="DASKR.jl-1"></a><a class="docs-heading-anchor-permalink" href="#DASKR.jl" title="Permalink"></a></h3><p>DASKR.jl is not automatically included by DifferentialEquations.jl. To use this algorithm, you will need to install and use the package:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;DASKR&quot;)
using DASKR</code></pre><ul><li><code>daskr</code> - This is a wrapper for the well-known DASKR algorithm.</li></ul><p>For more details on controlling the DASKR.jl solvers, see the <a href="../../api/daskr/#daskr">DASKR detailed solver API page</a></p><h3 id="DASSL.jl"><a class="docs-heading-anchor" href="#DASSL.jl">DASSL.jl</a><a id="DASSL.jl-1"></a><a class="docs-heading-anchor-permalink" href="#DASSL.jl" title="Permalink"></a></h3><ul><li><code>dassl</code> - A native Julia implementation of the DASSL algorithm.</li></ul><h3 id="ODEInterfaceDiffEq.jl"><a class="docs-heading-anchor" href="#ODEInterfaceDiffEq.jl">ODEInterfaceDiffEq.jl</a><a id="ODEInterfaceDiffEq.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ODEInterfaceDiffEq.jl" title="Permalink"></a></h3><p>These methods require the DAE to be an <code>ODEProblem</code> in mass matrix form. For extra options for the solvers, see the ODE solver page.</p><ul><li><code>seulex</code> - Extrapolation-algorithm based on the linear implicit Euler method.</li><li><code>radau</code> - Implicit Runge-Kutta (Radau IIA) of variable order between 5 and 13.</li><li><code>radau5</code> - Implicit Runge-Kutta method (Radau IIA) of order 5.</li><li><code>rodas</code> - Rosenbrock 4(3) method.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sdde_solve/">« SDDE Solvers</a><a class="docs-footer-nextpage" href="../benchmarks/">Solver Benchmarks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Sunday 19 May 2024 20:31">Sunday 19 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
