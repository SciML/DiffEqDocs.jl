<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Global Sensitivity Analysis · DifferentialEquations.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-90474609-3', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://diffeq.sciml.ai/stable/analysis/global_sensitivity/" rel="canonical"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script data-main="../../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" href="../../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><script data-is-old-version="">document.addEventListener("DOMContentLoaded", function(){
    const div = document.createElement('div');
    div.setAttribute('style', 'position: fixed; bottom: 1em; right: 1em; z-index: 999; background-color: #ffaf9c; color: rgba(0, 0, 0, 0.7); border: 1px solid #d54625; border-radius: 4px; padding: 2em; text-align: center');
    const closer = document.createElement('div');
    closer.setAttribute('style', 'position: absolute; top: 0; right: 5px; padding: 5px; cursor: pointer; width: 12px; height: 12px;')
    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', () => {
        document.body.removeChild(div)
    })
    const href = documenterBaseURL + '/../stable'
    div.innerHTML = 'This is an old version of the documentation. <br> Click <a href="' + href + '">here</a> to go to the newest version.';
    div.appendChild(closer)
    document.body.appendChild(div);
});
</script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img alt="DifferentialEquations.jl logo" src="../../assets/logo.png"/></a><div class="docs-package-name"><span class="docs-autofit">DifferentialEquations.jl</span></div><form action="../../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">DifferentialEquations.jl: Scientific Machine Learning (SciML) Enabled Simulation and Estimation</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/ode_example/">Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/advanced_ode_example/">Solving Stiff Equations</a></li><li><a class="tocitem" href="../../tutorials/sde_example/">Stochastic Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/rode_example/">Random Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dde_example/">Delay Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dae_example/">Differential Algebraic Equations</a></li><li><a class="tocitem" href="../../tutorials/discrete_stochastic_example/">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="tocitem" href="../../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="tocitem" href="../../tutorials/bvp_example/">Boundary Value Problems</a></li><li><a class="tocitem" href="../../tutorials/additional/">Additional Tutorials</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../basics/common_solver_opts/">Common Solver Options</a></li><li><a class="tocitem" href="../../basics/solution/">Solution Handling</a></li><li><a class="tocitem" href="../../basics/plot/">Plot Functions</a></li><li><a class="tocitem" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="tocitem" href="../../basics/problem/">Problem Interface</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="tocitem">Problem Types</span><ul><li><a class="tocitem" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="tocitem" href="../../types/ode_types/">ODE Problems</a></li><li><a class="tocitem" href="../../types/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group Problems</a></li><li><a class="tocitem" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="tocitem" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="tocitem" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="tocitem" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="tocitem" href="../../types/sde_types/">SDE Problems</a></li><li><a class="tocitem" href="../../types/rode_types/">RODE Problems</a></li><li><a class="tocitem" href="../../types/dde_types/">DDE Problems</a></li><li><a class="tocitem" href="../../types/sdde_types/">SDDE Problems</a></li><li><a class="tocitem" href="../../types/dae_types/">DAE Problems</a></li><li><a class="tocitem" href="../../types/jump_types/">Jump Problems</a></li></ul></li><li><span class="tocitem">Solver Algorithms</span><ul><li><a class="tocitem" href="../../solvers/discrete_solve/">Discrete Solvers</a></li><li><a class="tocitem" href="../../solvers/ode_solve/">ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/split_ode_solve/">Split ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/steady_state_solve/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/bvp_solve/">BVP Solvers</a></li><li><a class="tocitem" href="../../solvers/jump_solve/">Jump Problem and Jump Diffusion Solvers</a></li><li><a class="tocitem" href="../../solvers/sde_solve/">SDE Solvers</a></li><li><a class="tocitem" href="../../solvers/rode_solve/">RODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dde_solve/">SDDE Solvers</a></li><li><a class="tocitem" href="../../solvers/sdde_solve/">SDDE Solvers</a></li><li><a class="tocitem" href="../../solvers/dae_solve/">DAE Solvers</a></li><li><a class="tocitem" href="../../solvers/benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="tocitem">Additional Features</span><ul><li><a class="tocitem" href="../../features/performance_overloads/">DiffEqFunctions (Jacobians, Gradients, etc.) and Jacobian Types</a></li><li><a class="tocitem" href="../../features/diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="tocitem" href="../../features/diffeq_operator/">DiffEqOperators</a></li><li><a class="tocitem" href="../../features/noise_process/">Noise Processes</a></li><li><a class="tocitem" href="../../features/linear_nonlinear/">Specifying (Non)Linear Solvers</a></li><li><a class="tocitem" href="../../features/callback_functions/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../features/callback_library/">Callback Library</a></li><li><a class="tocitem" href="../../features/ensemble/">Parallel Ensemble Simulations</a></li><li><a class="tocitem" href="../../features/io/">I/O: Saving and Loading Solution Data</a></li><li><a class="tocitem" href="../../features/low_dep/">Low Dependency Usage</a></li><li><a class="tocitem" href="../../features/progress_bar/">Progress Bar Integration</a></li></ul></li><li><span class="tocitem">Analysis Tools</span><ul><li><a class="tocitem" href="../parameterized_functions/">ParameterizedFunctions</a></li><li><a class="tocitem" href="../parameter_estimation/">Parameter Estimation and Bayesian Analysis</a></li><li><a class="tocitem" href="../bifurcation/">Bifurcation Analysis</a></li><li><a class="tocitem" href="../sensitivity/">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li class="is-active"><a class="tocitem" href="">Global Sensitivity Analysis</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#General-Interface"><span>General Interface</span></a></li><li><a class="tocitem" href="#GSA-examples"><span>GSA examples</span></a></li></ul></li><li><a class="tocitem" href="../uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="tocitem" href="../neural_networks/">Neural Networks</a></li><li><a class="tocitem" href="../dev_and_test/">Algorithm Development and Testing</a></li></ul></li><li><span class="tocitem">Domain Modeling Tools</span><ul><li><a class="tocitem" href="../../models/multiscale/">Multi-Scale Models</a></li><li><a class="tocitem" href="../../models/physical/">Physical Models</a></li><li><a class="tocitem" href="../../models/financial/">Financial Models</a></li><li><a class="tocitem" href="../../models/chemical_reactions/">Chemical Reactions</a></li><li><a class="tocitem" href="../../models/external_modeling/">External Modeling Packages</a></li></ul></li><li><span class="tocitem">Extra Details</span><ul><li><a class="tocitem" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li><li><a class="tocitem" href="../../extras/sensitivity_math/">Mathematics of Sensitivity Analysis</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Analysis Tools</a></li><li class="is-active"><a href="">Global Sensitivity Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Global Sensitivity Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/DiffEqDocs.jl/blob/master/docs/src/analysis/global_sensitivity.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="gsa"><a class="docs-heading-anchor" href="#gsa">Global Sensitivity Analysis</a><a id="gsa-1"></a><a class="docs-heading-anchor-permalink" href="#gsa" title="Permalink"></a></h1><p>Global Sensitivity Analysis (GSA) methods are used to quantify the uncertainty in output of a model w.r.t. the parameters, their individual contributions, or the contribution of their interactions. The GSA interface allows for utilizing batched functions for parallel computation of GSA quantities.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>This functionality does not come standard with DifferentialEquations.jl. To use this functionality, you must install DiffEqSensitivity.jl:</p><pre><code class="language-julia">]add DiffEqSensitivity
using DiffEqSensitivity</code></pre><h2 id="General-Interface"><a class="docs-heading-anchor" href="#General-Interface">General Interface</a><a id="General-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#General-Interface" title="Permalink"></a></h2><p>The general interface for calling a global sensitivity analysis is either:</p><pre><code class="language-julia">effects = gsa(f, method, param_range; N, batch=false)</code></pre><p>where:</p><ul><li><code>y=f(x)</code> is a function that takes in a single vector and spits out a single vector or scalar. If <code>batch=true</code>, then <code>f</code> takes in a matrix where each row is a set of parameters, and returns a matrix where each row is a the output for the corresponding row of parameters.</li><li><code>method</code> is one of the GSA methods below.</li><li><code>param_range</code> is a vector of tuples for the upper and lower bound for the given parameter <code>i</code>.</li><li><code>N</code> is a required keyword argument for the number of samples to take in the trajectories/design.</li></ul><p>Note that for some methods there is a second interface where one can directly pass the design matrices:</p><pre><code class="language-julia">effects = gsa(f, method, A, B; batch=false)</code></pre><p>where <code>A</code> and <code>B</code> are design matrices with each row being a set of parameters. Note that <code>generate_design_matrices</code> from <a href="https://github.com/JuliaDiffEq/QuasiMonteCarlo.jl">QuasiMonteCarlo.jl</a> can be used to generate the design matrices.</p><h3 id="Morris-Method"><a class="docs-heading-anchor" href="#Morris-Method">Morris Method</a><a id="Morris-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Morris-Method" title="Permalink"></a></h3><p><code>Morris</code> has the following keyword arguments:</p><ul><li><code>p_steps</code> - Vector of <span>$\Delta$</span> for the step sizes in each direction. Required.</li><li><code>relative_scale</code> - The elementary effects are calculated with the assumption that the parameters lie in the range <code>[0,1]</code> but as this is not always the case scaling is used to get more informative, scaled effects. Defaults to <code>false</code>.</li><li><code>total_num_trajectory</code>, <code>num_trajectory</code> - The total number of design matrices that are generated out of which <code>num_trajectory</code> matrices with the highest spread are used in calculation.</li><li>len<em>design</em>mat` - The size of a design matrix.</li></ul><h4 id="Morris-Method-Details"><a class="docs-heading-anchor" href="#Morris-Method-Details">Morris Method Details</a><a id="Morris-Method-Details-1"></a><a class="docs-heading-anchor-permalink" href="#Morris-Method-Details" title="Permalink"></a></h4><p>The Morris method also known as Morris’s OAT method where OAT stands for One At a Time can be described in the following steps:</p><p>We calculate local sensitivity measures known as “elementary effects”, which are calculated by measuring the perturbation in the output of the model on changing one parameter.</p><p><span>$EE_i = \frac{f(x_1,x_2,..x_i+ \Delta,..x_k) - y}{\Delta}$</span></p><p>These are evaluated at various points in the input chosen such that a wide “spread” of the parameter space is explored and considered in the analysis, to provide an approximate global importance measure. The mean and variance of these elementary effects is computed. A high value of the mean implies that a parameter is important, a high variance implies that its effects are non-linear or the result of interactions with other inputs. This method does not evaluate separately the contribution from the interaction and the contribution of the parameters individually and gives the effects for each parameter which takes into consideration all the interactions and its individual contribution.</p><h3 id="Sobol-Method"><a class="docs-heading-anchor" href="#Sobol-Method">Sobol Method</a><a id="Sobol-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Sobol-Method" title="Permalink"></a></h3><p>The <code>Sobol</code> object has as its fields the <code>order</code> of the indices to be estimated.</p><ul><li><code>order</code> - the order of the indices to calculate. Defaults to <code>[0,1]</code>, which means the Total and First order indices. Passing <code>2</code> enables calculation of the Second order indices as well.</li><li><code>Ei_estimator</code> - Can take <code>:Homma1996</code>, <code>:Sobol2007</code> and <code>:Jansen1999</code> for which Monte Carlo estimator is used for the Ei term. Defaults to <code>:Jansen1999</code>.</li></ul><h4 id="Sobol-Method-Details"><a class="docs-heading-anchor" href="#Sobol-Method-Details">Sobol Method Details</a><a id="Sobol-Method-Details-1"></a><a class="docs-heading-anchor-permalink" href="#Sobol-Method-Details" title="Permalink"></a></h4><p>Sobol is a variance-based method and it decomposes the variance of the output of the model or system into fractions which can be attributed to inputs or sets of inputs. This helps to get not just the individual parameter's sensitivities but also gives a way to quantify the affect and sensitivity from the interaction between the parameters.</p><div>\[ Y = f_0+ \sum_{i=1}^d f_i(X_i)+ \sum_{i &lt; j}^d f_{ij}(X_i,X_j) ... + f_{1,2...d}(X_1,X_2,..X_d)\]</div><div>\[ Var(Y) = \sum_{i=1}^d V_i + \sum_{i &lt; j}^d V_{ij} + ... + V_{1,2...,d}\]</div><p>The Sobol Indices are "order"ed, the first order indices given by <span>$S_i = \frac{V_i}{Var(Y)}$</span> the contribution to the output variance of the main effect of <span>$X_i$</span>, therefore it measures the effect of varying <span>$X_i$</span> alone, but averaged over variations in other input parameters. It is standardised by the total variance to provide a fractional contribution. Higher-order interaction indices <span>$S_{i,j}, S_{i,j,k}$</span> and so on can be formed by dividing other terms in the variance decomposition by <span>$Var(Y)$</span>.</p><h3 id="eFAST-Method"><a class="docs-heading-anchor" href="#eFAST-Method">eFAST Method</a><a id="eFAST-Method-1"></a><a class="docs-heading-anchor-permalink" href="#eFAST-Method" title="Permalink"></a></h3><p><code>eFAST</code> has <code>num_harmonics</code> as the only argument, it is the number of harmonics to sum in  the Fourier series decomposition and defaults to 4.</p><h4 id="eFAST-Method-Details"><a class="docs-heading-anchor" href="#eFAST-Method-Details">eFAST Method Details</a><a id="eFAST-Method-Details-1"></a><a class="docs-heading-anchor-permalink" href="#eFAST-Method-Details" title="Permalink"></a></h4><p>eFAST offers a robust, especially at low sample size, and computationally efficient procedure to  get the first and total order indices as discussed in Sobol. It utilizes monodimensional Fourier decomposition along a curve exploring the parameter space. The curve is defined by a set of parametric equations,</p><div>\[x_{i}(s) = G_{i}(sin ω_{i}s), ∀ i=1,2 ,..., n,\]</div><p>where s is a scalar variable varying over the range <span>$-∞ &lt; s &lt; +∞$</span>, <span>$G_{i}$</span> are transformation functions and <span>${ω_{i}}, ∀ i=1,2,...,n$</span> is a set of different (angular) frequencies, to be properly selected, associated with each factor. For more details on the transformation used and other implementation details you can go through <a href="http://dx.doi.org/10.1080/00401706.1999.10485594"> A. Saltelli et al.</a>.</p><h3 id="Regression-Method"><a class="docs-heading-anchor" href="#Regression-Method">Regression Method</a><a id="Regression-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Regression-Method" title="Permalink"></a></h3><p><code>RegressionGSA</code> has the following keyword arguments:</p><ul><li><code>rank</code>: flag which determines whether to calculate the rank coefficients. Defaults to <code>false</code>.</li></ul><p>It returns a <code>RegressionGSAResult</code>, which contains the <code>pearson</code>, <code>standard_regression</code>, and <code>partial_correlation</code> coefficients, described below. If <code>rank</code> is true, then it also contains the ranked versions of these coefficients. Note that the ranked version of the <code>pearson</code> coefficient is also known as the Spearman coefficient, which is returned here as the <code>pearson_rank</code> coefficient.</p><p>For multi-variable models, the coefficient for the <span>$X_i$</span> input variable relating to the <span>$Y_j$</span> output variable is given as the <code>[i, j]</code> entry in the corresponding returned matrix.</p><h4 id="Regression-Details"><a class="docs-heading-anchor" href="#Regression-Details">Regression Details</a><a id="Regression-Details-1"></a><a class="docs-heading-anchor-permalink" href="#Regression-Details" title="Permalink"></a></h4><p>It is possible to fit a linear model explaining the behavior of Y given the values of X, provided that the sample size n is sufficiently large (at least n &gt; d).</p><p>The measures provided for this analysis by us in DiffEqSensitivity.jl are</p><p>a) Pearson Correlation Coefficient:</p><div>\[r = \frac{\sum_{i=1}^{n} (x_i - \overline{x})(y_i - \overline{y})}{\sqrt{\sum_{i=1}^{n} (x_i - \overline{x})^2(y_i - \overline{y})^2}}\]</div><p>b) Standard Regression Coefficient (SRC):</p><div>\[SRC_j = \beta_{j} \sqrt{\frac{Var(X_j)}{Var(Y)}}\]</div><p>where <span>$\beta_j$</span> is the linear regression coefficient associated to <span>$X_j$</span>. This is also known as a sigma-normalized derivative.</p><p>c) Partial Correlation Coefficient (PCC):</p><div>\[PCC_j = \rho(X_j - \hat{X_{-j}},Y_j - \hat{Y_{-j}})\]</div><p>where <span>$\hat{X_{-j}}$</span> is the prediction of the linear model, expressing <span>$X_{j}$</span> with respect to the other inputs and <span>$\hat{Y_{-j}}$</span> is the prediction of the linear model where <span>$X_j$</span> is absent. PCC measures the sensitivity of <span>$Y$</span> to <span>$X_j$</span> when the effects of the other inputs have been canceled.</p><p>If <code>rank</code> is set to <code>true</code>, then the rank coefficients are also calculated.</p><h2 id="GSA-examples"><a class="docs-heading-anchor" href="#GSA-examples">GSA examples</a><a id="GSA-examples-1"></a><a class="docs-heading-anchor-permalink" href="#GSA-examples" title="Permalink"></a></h2><h3 id="Lotka-Volterra-Global-Sensitivities"><a class="docs-heading-anchor" href="#Lotka-Volterra-Global-Sensitivities">Lotka-Volterra Global Sensitivities</a><a id="Lotka-Volterra-Global-Sensitivities-1"></a><a class="docs-heading-anchor-permalink" href="#Lotka-Volterra-Global-Sensitivities" title="Permalink"></a></h3><p>Let's run GSA on the Lotka-Volterra model to and study the sensitivity of the maximum of predator population and the average prey population.</p><pre><code class="language-julia">using DiffEqSensitivity, Statistics, OrdinaryDiffEq #load packages</code></pre><p>First let's define our model:</p><pre><code class="language-julia">function f(du,u,p,t)
  du[1] = p[1]*u[1] - p[2]*u[1]*u[2] #prey
  du[2] = -p[3]*u[2] + p[4]*u[1]*u[2] #predator
end
u0 = [1.0;1.0]
tspan = (0.0,10.0)
p = [1.5,1.0,3.0,1.0]
prob = ODEProblem(f,u0,tspan,p)
t = collect(range(0, stop=10, length=200))</code></pre><p>Now let's create a function that takes in a parameter set and calculates the maximum of the predator population and the average of the prey population for those parameter values. To do this, we will make use of the <code>remake</code> function which creates a new <code>ODEProblem</code>, and use the <code>p</code> keyword argument to set the new parameters:</p><pre><code class="language-julia">f1 = function (p)
  prob1 = remake(prob;p=p)
  sol = solve(prob1,Tsit5();saveat=t)
  [mean(sol[1,:]), maximum(sol[2,:])]
end</code></pre><p>Now let's perform a Morris global sensitivity analysis on this model. We specify that the parameter range is <code>[1,5]</code> for each of the parameters, and thus call:</p><pre><code class="language-julia">m = gsa(f1,Morris(total_num_trajectory=1000,num_trajectory=150),[[1,5],[1,5],[1,5],[1,5]])</code></pre><p>Let's get the means and variances from the <code>MorrisResult</code> struct.</p><pre><code class="language-julia">m.means
2×2 Array{Float64,2}:
 0.474053  0.114922
 1.38542   5.26094

m.variances
2×2 Array{Float64,2}:
 0.208271    0.0317397
 3.07475   118.103    </code></pre><p>Let's plot the result</p><pre><code class="language-julia">scatter(m.means[1,:], m.variances[1,:],series_annotations=[:a,:b,:c,:d],color=:gray)
scatter(m.means[2,:], m.variances[2,:],series_annotations=[:a,:b,:c,:d],color=:gray)</code></pre><p>For the Sobol method we can similarly do:</p><pre><code class="language-julia">m = gsa(f1,Sobol(),[[1,5],[1,5],[1,5],[1,5]],N=1000)</code></pre><h3 id="Design-Matrices"><a class="docs-heading-anchor" href="#Design-Matrices">Design Matrices</a><a id="Design-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Design-Matrices" title="Permalink"></a></h3><p>For the Sobol Method, we can have more control over the sampled points by generating design matrices. Doing it in this manner lets us directly specify a quasi-Monte Carlo sampling method for the parameter space. Here we use <a href="https://github.com/JuliaDiffEq/QuasiMonteCarlo.jl">QuasiMonteCarlo.jl</a> to generate the design matrices as follows:</p><pre><code class="language-julia">N = 10000
lb = [1.0, 1.0, 1.0, 1.0]
ub = [5.0, 5.0, 5.0, 5.0]
sampler = SobolSample()
A,B = QuasiMonteCarlo.generate_design_matrices(N,lb,ub,sampler)</code></pre><p>and now we tell it to calculate the Sobol indices on these designs:</p><pre><code class="language-julia">sobol_result = gsa(f1,Sobol(),A,B)</code></pre><p>We plot the first order and total order Sobol Indices for the parameters (<code>a</code> and <code>b</code>).</p><pre><code class="language-julia">
p1 = bar(["a","b","c","d"],sobol_result.ST[1,:],title="Total Order Indices prey",legend=false)
p2 = bar(["a","b","c","d"],sobol_result.S1[1,:],title="First Order Indices prey",legend=false)
p1_ = bar(["a","b","c","d"],sobol_result.ST[2,:],title="Total Order Indices predator",legend=false)
p2_ = bar(["a","b","c","d"],sobol_result.S1[2,:],title="First Order Indices predator",legend=false)
plot(p1,p2,p1_,p2_)</code></pre><p><img alt="sobolplot" src="../../assets/sobolbars.png"/></p><h3 id="Parallelized-GSA-Example"><a class="docs-heading-anchor" href="#Parallelized-GSA-Example">Parallelized GSA Example</a><a id="Parallelized-GSA-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Parallelized-GSA-Example" title="Permalink"></a></h3><p>In all of the previous examples, <code>f(p)</code> was calculated serially. However, we can parallelize our computations by using the batch interface. In the batch interface, each column <code>p[:,i]</code> is a set of parameters, and we output a column for each set of parameters. Here we showcase using the <a href="../../features/ensemble/#ensemble">Ensemble Interface</a> to use <code>EnsembleGPUArray</code> to perform automatic multithreaded-parallelization of the ODE solves.</p><pre><code class="language-julia">f1 = function (p)
  prob_func(prob,i,repeat) = remake(prob;p=p[:,i])
  ensemble_prob = EnsembleProblem(prob,prob_func=prob_func)
  sol = solve(ensemble_prob,Tsit5(),EnsembleThreads();saveat=t,trajectories=size(p,2))
  # Now sol[i] is the solution for the ith set of parameters
  out = zeros(2,size(p,2))
  for i in 1:size(p,2)
    out[1,i] = mean(sol[i][1,:])
    out[2,i] = maximum(sol[i][2,:])
  end
  out
end</code></pre><p>And now to do the parallelized calls we simply add the <code>batch=true</code> keyword argument:</p><pre><code class="language-julia">sobol_result = gsa(f1,Sobol(),A,B,batch=true)</code></pre><p>This user-side parallelism thus allows you to take control, and thus for example you can use <a href="https://github.com/JuliaDiffEq/DiffEqGPU.jl">DiffEqGPU.jl</a> for automated GPU-parallelism of the ODE-based global sensitivity analysis!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sensitivity/">« Local Sensitivity Analysis (Automatic Differentiation)</a><a class="docs-footer-nextpage" href="../uncertainty_quantification/">Uncertainty Quantification »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 12 August 2020 03:39">Wednesday 12 August 2020</span>. Using Julia version 1.5.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>