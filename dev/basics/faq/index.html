<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Frequently Asked Questions · DifferentialEquations.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-90474609-3', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://diffeq.sciml.ai/stable/basics/faq/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DifferentialEquations.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">DifferentialEquations.jl: Scientific Machine Learning (SciML) Enabled Simulation and Estimation</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/ode_example/">Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/advanced_ode_example/">Solving Stiff Equations</a></li><li><a class="tocitem" href="../../tutorials/sde_example/">Stochastic Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/rode_example/">Random Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dde_example/">Delay Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dae_example/">Differential Algebraic Equations</a></li><li><a class="tocitem" href="../../tutorials/discrete_stochastic_example/">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="tocitem" href="../../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="tocitem" href="../../tutorials/bvp_example/">Boundary Value Problems</a></li><li><a class="tocitem" href="../../tutorials/additional/">Additional Tutorials</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../overview/">Overview of DifferentialEquations.jl</a></li><li><a class="tocitem" href="../common_solver_opts/">Common Solver Options</a></li><li><a class="tocitem" href="../solution/">Solution Handling</a></li><li><a class="tocitem" href="../plot/">Plot Functions</a></li><li><a class="tocitem" href="../integrator/">Integrator Interface</a></li><li><a class="tocitem" href="../problem/">Problem Interface</a></li><li class="is-active"><a class="tocitem" href>Frequently Asked Questions</a><ul class="internal"><li><a class="tocitem" href="#faq_performance-1"><span>Performance</span></a></li><li><a class="tocitem" href="#Complicated-Models-1"><span>Complicated Models</span></a></li><li><a class="tocitem" href="#Numerical-Error-1"><span>Numerical Error</span></a></li><li><a class="tocitem" href="#Autodifferentiation-and-Dual-Numbers-1"><span>Autodifferentiation and Dual Numbers</span></a></li></ul></li><li><a class="tocitem" href="../compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="tocitem">Problem Types</span><ul><li><a class="tocitem" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="tocitem" href="../../types/ode_types/">ODE Problems</a></li><li><a class="tocitem" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="tocitem" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="tocitem" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="tocitem" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="tocitem" href="../../types/sde_types/">SDE Problems</a></li><li><a class="tocitem" href="../../types/rode_types/">RODE Problems</a></li><li><a class="tocitem" href="../../types/dde_types/">DDE Problems</a></li><li><a class="tocitem" href="../../types/dae_types/">DAE Problems</a></li><li><a class="tocitem" href="../../types/jump_types/">Jump Problems</a></li></ul></li><li><span class="tocitem">Solver Algorithms</span><ul><li><a class="tocitem" href="../../solvers/discrete_solve/">Discrete Solvers</a></li><li><a class="tocitem" href="../../solvers/ode_solve/">ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/split_ode_solve/">Split ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/steady_state_solve/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/bvp_solve/">BVP Solvers</a></li><li><a class="tocitem" href="../../solvers/jump_solve/">Jump Problem and Jump Diffusion Solvers</a></li><li><a class="tocitem" href="../../solvers/sde_solve/">SDE Solvers</a></li><li><a class="tocitem" href="../../solvers/rode_solve/">RODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dde_solve/">DDE Solvers</a></li><li><a class="tocitem" href="../../solvers/dae_solve/">DAE Solvers</a></li><li><a class="tocitem" href="../../solvers/benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="tocitem">Additional Features</span><ul><li><a class="tocitem" href="../../features/performance_overloads/">DiffEqFunctions (Jacobians, Gradients, etc.) and Jacobian Types</a></li><li><a class="tocitem" href="../../features/diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="tocitem" href="../../features/diffeq_operator/">DiffEqOperators</a></li><li><a class="tocitem" href="../../features/noise_process/">Noise Processes</a></li><li><a class="tocitem" href="../../features/linear_nonlinear/">Specifying (Non)Linear Solvers</a></li><li><a class="tocitem" href="../../features/callback_functions/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../features/callback_library/">Callback Library</a></li><li><a class="tocitem" href="../../features/ensemble/">Parallel Ensemble Simulations</a></li><li><a class="tocitem" href="../../features/io/">I/O: Saving and Loading Solution Data</a></li><li><a class="tocitem" href="../../features/low_dep/">Low Dependency Usage</a></li><li><a class="tocitem" href="../../features/progress_bar/">Progress Bar Integration</a></li></ul></li><li><span class="tocitem">Analysis Tools</span><ul><li><a class="tocitem" href="../../analysis/parameterized_functions/">ParameterizedFunctions</a></li><li><a class="tocitem" href="../../analysis/parameter_estimation/">Parameter Estimation and Bayesian Analysis</a></li><li><a class="tocitem" href="../../analysis/bifurcation/">Bifurcation Analysis</a></li><li><a class="tocitem" href="../../analysis/sensitivity/">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li><a class="tocitem" href="../../analysis/global_sensitivity/">Global Sensitivity Analysis</a></li><li><a class="tocitem" href="../../analysis/uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="tocitem" href="../../analysis/neural_networks/">Neural Networks</a></li><li><a class="tocitem" href="../../analysis/dev_and_test/">Algorithm Development and Testing</a></li></ul></li><li><span class="tocitem">Domain Modeling Tools</span><ul><li><a class="tocitem" href="../../models/multiscale/">Multi-Scale Models</a></li><li><a class="tocitem" href="../../models/physical/">Physical Models</a></li><li><a class="tocitem" href="../../models/financial/">Financial Models</a></li><li><a class="tocitem" href="../../models/biological/">Chemical Reaction Models</a></li><li><a class="tocitem" href="../../models/external_modeling/">External Modeling Packages</a></li></ul></li><li><span class="tocitem">APIs</span><ul><li><a class="tocitem" href="../../apis/diffeqbio/">DiffEqBiological.jl API</a></li></ul></li><li><span class="tocitem">Extra Details</span><ul><li><a class="tocitem" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li><li><a class="tocitem" href="../../extras/sensitivity_math/">Mathematics of Sensitivity Analysis</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Basics</a></li><li class="is-active"><a href>Frequently Asked Questions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Frequently Asked Questions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/DiffEqDocs.jl/blob/master/docs/src/basics/faq.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="faq-1"><a class="docs-heading-anchor" href="#faq-1">Frequently Asked Questions</a><a class="docs-heading-anchor-permalink" href="#faq-1" title="Permalink"></a></h1><p>This page is a compilation of frequently asked questions and answers.</p><h2 id="faq_performance-1"><a class="docs-heading-anchor" href="#faq_performance-1">Performance</a><a class="docs-heading-anchor-permalink" href="#faq_performance-1" title="Permalink"></a></h2><h4 id="GPUs,-multithreading-and-distributed-computation-support-1"><a class="docs-heading-anchor" href="#GPUs,-multithreading-and-distributed-computation-support-1">GPUs, multithreading and distributed computation support</a><a class="docs-heading-anchor-permalink" href="#GPUs,-multithreading-and-distributed-computation-support-1" title="Permalink"></a></h4><p>Yes. The <code>*</code>DiffEq.jl libraries (OrdinaryDiffEq.jl, StochasticDiffEq.jl, and DelayDiffEq.jl) are all written to be generic to the array and number types. This means they will adopt the implementation that is given by the array type. The in-place algorithms internally utilize Julia&#39;s broadcast (with some exceptions due to a Julia bug for now, see <a href="https://github.com/JuliaDiffEq/OrdinaryDiffEq.jl/issues/106">this issue</a>) and Julia&#39;s <code>mul!</code> in-place matrix multiplication function. The out-of-place algorithms utilize standard arithmetical functions. Both additionally utilize the user&#39;s norm specified via the common interface options and, if a stiff solver, ForwardDiff/DiffEqDiffTools for the Jacobian calculation, and Base linear factorizations for the linear solve. For your type, you may likely need to give a <a href="../common_solver_opts/#advanced_adaptive_stepsize_control-1">better form of the norm</a>, <a href="../../features/performance_overloads/#performance_overloads-1">Jacobian</a>, or <a href="../../features/linear_nonlinear/#linear_nonlinear-1">linear solve calculations</a> to fully utilize parallelism.</p><p>GPUArrays.jl (CuArrays.jl), ArrayFire.jl, DistributedArrays.jl have been tested and work in various forms, where the last one is still not recommended for common use yet.</p><p>The next question is whether it matters. Generally, your system has to be large for parallelism to matter. Using a multithreaded array for broadcast we find helpful around <code>N&gt;1000</code>, though the Sundials manual says <code>N&gt;100,000</code>. For high order Runge-Kutta methods it&#39;s likely lower than the Sundials estimate because of more operations packed into each internal step, but as always that will need more benchmarks to be precise and will depend on the problem being solved. GPUs generally require some intensive parallel operation in the user&#39;s <code>f</code> function to be viable, for example a matrix multiplication for a stencil computation in a PDE. If you&#39;re simply solving some ODE element-wise on a big array it likely won&#39;t do much or it will slow things down just due to how GPUs work. DistributedArrays require parallel linear solves to really matter, and thus are only recommended when you have a problem that cannot fit into memory or are using a stiff solver with a Krylov method for the linear solves.</p><h4 id="My-ODE-is-solving-really-slow-1"><a class="docs-heading-anchor" href="#My-ODE-is-solving-really-slow-1">My ODE is solving really slow</a><a class="docs-heading-anchor-permalink" href="#My-ODE-is-solving-really-slow-1" title="Permalink"></a></h4><p>First, check for bugs. These solvers go through a ton of convergence tests and so if there&#39;s a solver issue, it&#39;s either just something to do with how numerical methods work or it&#39;s a user-error (generally the latter, though check the later part of the FAQ on normal numerical errors). User-errors in the <code>f</code> function causing a divergence of the solution is the most common reason for reported slow codes.</p><p>If you have no bugs, great! The standard tricks for optimizing Julia code then apply. What you want to do first is make sure your function does not allocate. If your system is small (<code>&lt;=100</code> ODEs/SDEs/DDEs/DAEs?), then you should set your system up to use <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a>. This is demonstrated <a href="../../tutorials/ode_example/#ode_other_types-1">in the ODE tutorial</a> with static matrices. Static vectors/arrays are stack-allocated, and thus creating new arrays is free and the compiler doesn&#39;t have to heap-allocate any of the temporaries (that&#39;s the expensive part!). These have specialized super fast dispatches for arithmetic operations and extra things like LU-factorizations, and thus they are preferred when possible. However, they lose efficiency if they grow too large.</p><p>For anything larger, you should use the <code>in-place</code> syntax <code>f(du,u,p,t)</code> and make sure that your function doesn&#39;t allocate. Assuming you know of a <code>u0</code>, you should be able to do:</p><pre><code class="language-julia">du = similar(u0)
@time f(du,u0,p,t)</code></pre><p>and see close to zero allocations and close to zero memory allocated. If you see more, then you might have a type-instability or have temporary arrays. To find type-instabilities, you should do:</p><pre><code class="language-julia">@code_warntype f(du,u,p,t)</code></pre><p>and read the printout to see if there&#39;s any types that aren&#39;t inferred by the compiler, and fix them. If you have any global variables, you should make them <code>const</code>. As for allocations, some common things that allocate are:</p><ul><li>Array slicing, like <code>u[1:5]</code>. Instead, use <code>@view u[1:5]</code></li><li>Matrix multiplication with <code>*</code>. Instead of <code>A*b</code>, use <code>A_mul_B!(c,A,b)</code> for some pre-allocated cache vector <code>c</code>.</li><li>Non-broadcasted expressions. Every expression on arrays should <code>.=</code> into another array, or it should be re-written to loop and do computations with scalar (or static array) values.</li></ul><p>For an example of optimizing a function resulting from a PDE discretization, see <a href="http://www.stochasticlifestyle.com/solving-systems-stochastic-pdes-using-gpus-julia/">this blog post</a>.</p><h4 id="The-stiff-solver-takes-forever-to-take-steps-for-my-PDE-discretization-1"><a class="docs-heading-anchor" href="#The-stiff-solver-takes-forever-to-take-steps-for-my-PDE-discretization-1">The stiff solver takes forever to take steps for my PDE discretization</a><a class="docs-heading-anchor-permalink" href="#The-stiff-solver-takes-forever-to-take-steps-for-my-PDE-discretization-1" title="Permalink"></a></h4><p>The solvers for stiff solvers require solving a nonlinear equation each step. In order to do so, they have to do a few Newton steps. By default, these methods assume that the Jacobian is dense, automatically calculate the Jacobian for you, and do a dense factorization. However, in many cases you may want to use alternatives that are more tuned for your problem.</p><p>First of all, when available, it&#39;s recommended that you pass a function for computing your Jacobian. This is discussed in the <a href="../../features/performance_overloads/#ode_explicit_jac-1">performance overloads</a> section. Jacobians are especially helpful for Rosenbrock methods.</p><p>Secondly, if your Jacobian isn&#39;t dense, you shouldn&#39;t use a dense Jacobian! In the Sundials algorithm you can set <code>linear_solver=:Band</code> for banded Jacobians for example. More support is coming for this soon.</p><p>But lastly, you shouldn&#39;t use a dense factorization for large sparse matrices. Instead, if you&#39;re using  a <code>*DiffEq</code> library you should <a href="../../features/linear_nonlinear/#linear_nonlinear-1">specify a linear solver</a>. For Sundials.jl, you should change the <code>linear_solver</code> option. See <a href="../../solvers/ode_solve/#ode_solve_sundials-1">the ODE solve Sundials portion</a> for details on that. Right now, Sundials.jl is the recommended method for stiff problems with large sparse Jacobians. <code>linear_solver=:Band</code> should be used if your Jacobian is banded and you can specify the band sizes. If you only know the Jacobian is sparse, <code>linear_solver=:GMRES</code> is a good option. Once again, a good reference for how to handle PDE discretizations can be found <a href="http://www.stochasticlifestyle.com/solving-systems-stochastic-pdes-using-gpus-julia/">at this blog post</a>.</p><h4 id="My-Problem-Has-Discontinuities-and-is-Unstable-/-Slow-1"><a class="docs-heading-anchor" href="#My-Problem-Has-Discontinuities-and-is-Unstable-/-Slow-1">My Problem Has Discontinuities and is Unstable / Slow</a><a class="docs-heading-anchor-permalink" href="#My-Problem-Has-Discontinuities-and-is-Unstable-/-Slow-1" title="Permalink"></a></h4><p><a href="https://discourse.julialang.org/t/handling-instability-when-solving-ode-problems/9019/5">This Discourse post</a> goes into detail for how to handle discontinuities in your ODE function and how to use that extra information to speed up the solver.</p><h2 id="Complicated-Models-1"><a class="docs-heading-anchor" href="#Complicated-Models-1">Complicated Models</a><a class="docs-heading-anchor-permalink" href="#Complicated-Models-1" title="Permalink"></a></h2><h4 id="Switching-ODE-functions-in-the-middle-of-integration-1"><a class="docs-heading-anchor" href="#Switching-ODE-functions-in-the-middle-of-integration-1">Switching ODE functions in the middle of integration</a><a class="docs-heading-anchor-permalink" href="#Switching-ODE-functions-in-the-middle-of-integration-1" title="Permalink"></a></h4><p>There are a few ways to do this. The simplest way is to just have a parameter to switch between the two. For example:</p><pre><code class="language-julia">function f(du,u,p,t)
  if p == 0
    du[1] = 2u[1]
  else
    du[1] = -2u[1]
  end
  du[2] = -u[2]
end</code></pre><p>Then in a callback you can make the <code>affect!</code> function modify <code>integrator.prob.p</code>. For example, we can make it change when <code>u[2]&lt;0.5</code> via:</p><pre><code class="language-julia">condition(t,u,integrator) = u[2] - 0.5
affect!(integrator) = integrator.prob.p = 1</code></pre><p>Then it will change betweeen the two ODE choices for <code>du1</code> at that moment. Another way to do this is to make the ODE functions all be the same type via FunctionWrappers.jl, but that is unnecessary. With the way that modern processors work, there exists branch prediction and thus execution of a conditional is free if it&#39;s predictable which branch will be taken. In this case, almost every call to <code>f</code> takes the <code>p==0</code> route until the callback, at which point it is almost always the <code>else</code> route. Therefore the processor will effectively get rid of the computational cost associated with this, so you&#39;re likely over-optimizing if you&#39;re going further (unless this change happens every step, but even then this is probably the cheapest part of the computation...).</p><h2 id="Numerical-Error-1"><a class="docs-heading-anchor" href="#Numerical-Error-1">Numerical Error</a><a class="docs-heading-anchor-permalink" href="#Numerical-Error-1" title="Permalink"></a></h2><h4 id="What-does-tolerance-mean-and-how-much-error-should-I-expect-1"><a class="docs-heading-anchor" href="#What-does-tolerance-mean-and-how-much-error-should-I-expect-1">What does tolerance mean and how much error should I expect</a><a class="docs-heading-anchor-permalink" href="#What-does-tolerance-mean-and-how-much-error-should-I-expect-1" title="Permalink"></a></h4><p>The most useful options are the tolerances <code>abstol</code> and <code>reltol</code>. These tell the  internal adaptive time stepping engine how precise of a solution you want.  Generally, <code>reltol</code> is the relative accuracy while <code>abstol</code> is the accuracy when  <code>u</code> is near zero. <em>These tolerances are local tolerances and thus are not global  guarantees</em>. However, a good rule of thumb is that the total solution accuracy  is 1-2 digits less than the relative tolerances. Thus for the defaults  <code>abstol=1e-6</code> and <code>reltol=1e-3</code>, you can expect a global accuracy of about 1-2  digits. This is standard across the board and applies to the native Julia methods,  the wrapped Fortran and C++ methods, the calls to MATLAB/Python/R, etc.</p><h4 id="The-solver-doesn&#39;t-obey-physical-law-X-(e.g.-conservation-of-energy)-1"><a class="docs-heading-anchor" href="#The-solver-doesn&#39;t-obey-physical-law-X-(e.g.-conservation-of-energy)-1">The solver doesn&#39;t obey physical law X (e.g. conservation of energy)</a><a class="docs-heading-anchor-permalink" href="#The-solver-doesn&#39;t-obey-physical-law-X-(e.g.-conservation-of-energy)-1" title="Permalink"></a></h4><p>Yes, this is because the numerical solution of the ODE is not the exact solution. There are a few ways that you can handle this problem. One way is to get a more exact solution. Thus instead of</p><pre><code class="language-julia">sol = solve(prob,alg)</code></pre><p>use</p><pre><code class="language-julia">sol = solve(prob,alg,abstol=1e-10,reltol=1e-10)</code></pre><p>Of course, there&#39;s always a tradeoff between accuracy and efficiency, so play around to find out what&#39;s right for your problem.</p><p>Another thing you can do is use a callback. There are some <a href="../../features/callback_library/#callback_library-1">premade callbacks in the callback library</a> which handle these sorts of things like projecting to manifolds and preserving positivity.</p><h5 id="Symplectic-integrators-don&#39;t-conserve-energy-1"><a class="docs-heading-anchor" href="#Symplectic-integrators-don&#39;t-conserve-energy-1">Symplectic integrators don&#39;t conserve energy</a><a class="docs-heading-anchor-permalink" href="#Symplectic-integrators-don&#39;t-conserve-energy-1" title="Permalink"></a></h5><p>Yes, symplectic integrators do not exactly conserve energy. It is a common misconception that they do. What symplectic integrators actually do is solve for a trajectory which rests on a symplectic manifold that is perturbed from the true solution&#39;s manifold by the truncation error. This means that symplectic integrators do not experience (very much) long time drift, but their orbit is not exactly the same as the true solution in phase space and thus you will see differences in energy that tend to look periodic. There is a small drift which grows linearly and is related to floating point error, but this drift is much less than standard methods. This is why symplectic methods are recommended for long time integration.</p><p>For conserving energy, there are a few things you can do. First of all, the energy error is related to the integration error, so simply solving with higher accuracy will reduce the error. The results in the <a href="https://github.com/JuliaDiffEq/DiffEqBenchmarks.jl">DiffEqBenchmarks</a> show that using a <code>DPRKN</code> method with low tolerance can be a great choice. Another thing you can do is use <a href="../../features/callback_library/#callback_library-1">the ManifoldProjection callback from the callback library</a>.</p><h4 id="How-to-get-to-zero-error-1"><a class="docs-heading-anchor" href="#How-to-get-to-zero-error-1">How to get to zero error</a><a class="docs-heading-anchor-permalink" href="#How-to-get-to-zero-error-1" title="Permalink"></a></h4><p>You can&#39;t. For floating point numbers, you shouldn&#39;t use below <code>abstol=1e-14</code> and <code>reltol=1e-14</code>. If you need lower than that, use arbitrary precision numbers like BigFloats or <a href="https://github.com/JuliaArbTypes/ArbFloats.jl">ArbFloats.jl</a>.</p><h2 id="Autodifferentiation-and-Dual-Numbers-1"><a class="docs-heading-anchor" href="#Autodifferentiation-and-Dual-Numbers-1">Autodifferentiation and Dual Numbers</a><a class="docs-heading-anchor-permalink" href="#Autodifferentiation-and-Dual-Numbers-1" title="Permalink"></a></h2><h4 id="Native-Julia-solvers-compatibility-with-autodifferentiation-1"><a class="docs-heading-anchor" href="#Native-Julia-solvers-compatibility-with-autodifferentiation-1">Native Julia solvers compatibility with autodifferentiation</a><a class="docs-heading-anchor-permalink" href="#Native-Julia-solvers-compatibility-with-autodifferentiation-1" title="Permalink"></a></h4><p>Yes, they are compatible with automatic differentiation! Take a look at the <a href="../../analysis/sensitivity/#sensitivity-1">sensitivity analysis</a> page for more details.</p><p>If the algorithm does not have differentiation of parameter-depedendent events, then you simply need to make the initial condition have elements of Dual numbers. If the algorithm uses Dual numbers, you need to make sure that time is also given by Dual numbers.</p><p>To show this in action, let&#39;s say we want to find the Jacobian of solution of the Lotka-Volterra equation at <code>t=10</code> with respect to the parameters.</p><pre><code class="language-julia">function func(du,u,p,t)
  du[1] = p[1] * u[1] - p[2] * u[1]*u[2]
  du[2] = -3 * u[2] + u[1]*u[2]
end
function f(p)
  prob = ODEProblem(func,eltype(p).([1.0,1.0]),(0.0,10.0),p)
  # Lower tolerances to show the methods converge to the same value
  solve(prob,Tsit5(),save_everystep=false,abstol=1e-12,reltol=1e-12)[end]
end</code></pre><p>This function takes in new parameters and spits out the solution at the end. We make the inital condition <code>eltype(p).([1.0,1.0])</code> so that way it&#39;s typed to be Dual numbers whenever <code>p</code> is an array of <code>Dual</code> numbers, and we do the same for the timespan just to show what you&#39;d do if there was parameters-dependent events. Then we can take the Jacobian via ForwardDiff.jl:</p><pre><code class="language-julia">using ForwardDiff
ForwardDiff.jacobian(f,[1.5,1.0])

2×2 Array{Float64,2}:
  2.16056   0.188569
 -6.25677  -0.697978</code></pre><p>and compare it to Calculus.jl:</p><pre><code class="language-julia">Calculus.jacobian(f,[1.5,1.0],:central)

2×2 Array{Float64,2}:
  2.16056   0.188569
 -6.25677  -0.697978</code></pre><h4 id="I-get-Dual-number-errors-when-I-solve-my-ODE-with-Rosenbrock-or-SDIRK-methods-1"><a class="docs-heading-anchor" href="#I-get-Dual-number-errors-when-I-solve-my-ODE-with-Rosenbrock-or-SDIRK-methods-1">I get Dual number errors when I solve my ODE with Rosenbrock or SDIRK methods</a><a class="docs-heading-anchor-permalink" href="#I-get-Dual-number-errors-when-I-solve-my-ODE-with-Rosenbrock-or-SDIRK-methods-1" title="Permalink"></a></h4><p>This is because you&#39;re using a cache which is not compatible with autodifferentiaion via ForwardDiff.jl. For example, if we use the ODE function:</p><pre><code class="language-julia">using LinearAlgebra, OrdinaryDiffEq
function foo(du, u, (A, tmp), t)
    mul!(tmp, A, u)
    @. du = u + tmp
    nothing
end
prob = ODEProblem(foo, ones(5, 5), (0., 1.0), (ones(5,5), zeros(5,5)))
solve(prob, Rosenbrock23())</code></pre><p>Here we use a cached temporary array in order to avoid the allocations of matrix multiplication. When autodifferentiation occurs, the element type of <code>u</code> is <code>Dual</code> numbers, so <code>A*u</code> produces <code>Dual</code> numbers, so the error arises when it tries to write into <code>tmp</code>. There are two ways to avoid this. The first way, the easy way, is to just turn off autodifferentiation with the <code>autodiff=false</code> option in the solver. Every solver which uses autodifferentiation has this option. Thus we&#39;d solve this with:</p><pre><code class="language-julia">prob = ODEProblem(f,rand(4),(0.0,1.0))
sol = solve(prob,Rosenbrock23(autodiff=false))</code></pre><p>and it will use a numerical differentiation fallback (DiffEqDiffTools.jl) to calculate Jacobians.</p><p>We could use <code>get_tmp</code> and <code>dualcache</code> functions from <code>DiffEqBase</code> to solve this issue, e.g.,</p><pre><code class="language-julia">using LinearAlgebra, OrdinaryDiffEq
using DiffEqBase: get_tmp, dualcache
function foo(du, u, (A, tmp), t)
    tmp = DiffEqBase.get_tmp(tmp, u)
    mul!(tmp, A, u)
    @. du = u + tmp
    nothing
end
chunk_size = 5
prob = ODEProblem(foo, ones(5, 5), (0., 1.0), (ones(5,5), DiffEqBase.dualcache(zeros(5,5), Val{chunk_size})))
solve(prob, TRBDF2(chunk_size=chunk_size))</code></pre><p>Note that one can adjust the chunk size by <code>DiffEqBase.dualcache(du, Val{N})</code>, where <code>N</code> is the chunk size.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../problem/">« Problem Interface</a><a class="docs-footer-nextpage" href="../compatibility_chart/">Solver Compatibility Chart »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 27 July 2020 00:57">Monday 27 July 2020</span>. Using Julia version 1.1.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
