<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DiffEqCallbacks.jl · DifferentialEquations.jl</title><meta name="title" content="DiffEqCallbacks.jl · DifferentialEquations.jl"/><meta property="og:title" content="DiffEqCallbacks.jl · DifferentialEquations.jl"/><meta property="twitter:title" content="DiffEqCallbacks.jl · DifferentialEquations.jl"/><meta name="description" content="Documentation for DifferentialEquations.jl."/><meta property="og:description" content="Documentation for DifferentialEquations.jl."/><meta property="twitter:description" content="Documentation for DifferentialEquations.jl."/><meta property="og:url" content="https://docs.sciml.ai/DiffEqDocs/stable/api/diffeqcallbacks/"/><meta property="twitter:url" content="https://docs.sciml.ai/DiffEqDocs/stable/api/diffeqcallbacks/"/><link rel="canonical" href="https://docs.sciml.ai/DiffEqDocs/stable/api/diffeqcallbacks/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DifferentialEquations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">DifferentialEquations.jl: Efficient Differential Equation Solving in Julia</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started with Differential Equations in Julia</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/faster_ode_example/">Code Optimization for Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/advanced_ode_example/">Solving Large Stiff Equations</a></li><li><a class="tocitem" href="../../tutorials/sde_example/">Stochastic Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/rode_example/">Random Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dde_example/">Delay Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dae_example/">Differential Algebraic Equations</a></li><li><a class="tocitem" href="../../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="tocitem" href="../../tutorials/bvp_example/">Boundary Value Problems</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Beginner</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/classical_physics/">Classical Physics Models</a></li><li><a class="tocitem" href="../../examples/conditional_dosing/">Conditional Dosing in Pharmacometrics</a></li><li><a class="tocitem" href="../../examples/kepler_problem/">The Kepler Problem</a></li><li><a class="tocitem" href="../../examples/outer_solar_system/">Simulating the Outer Solar System</a></li><li><a class="tocitem" href="../../examples/min_and_max/">Finding Maxima and Minima of ODEs Solutions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Advanced</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/spiking_neural_systems/">Spiking Neural Systems</a></li><li><a class="tocitem" href="../../examples/beeler_reuter/">An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model</a></li><li><a class="tocitem" href="../../examples/diffusion_implicit_heat_equation/">Solving the heat equation with diffusion-implicit time-stepping</a></li></ul></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../basics/common_solver_opts/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../basics/solution/">Solution Handling</a></li><li><a class="tocitem" href="../../basics/plot/">Plot Functions</a></li><li><a class="tocitem" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="tocitem" href="../../basics/problem/">Problem Interface</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="tocitem">Problem Types</span><ul><li><a class="tocitem" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="tocitem" href="../../types/ode_types/">ODE Problems</a></li><li><a class="tocitem" href="../../types/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group Problems</a></li><li><a class="tocitem" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="tocitem" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="tocitem" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="tocitem" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="tocitem" href="../../types/sde_types/">SDE Problems</a></li><li><a class="tocitem" href="../../types/sdae_types/">SDAE Problems</a></li><li><a class="tocitem" href="../../types/rode_types/">RODE Problems</a></li><li><a class="tocitem" href="../../types/dde_types/">DDE Problems</a></li><li><a class="tocitem" href="../../types/sdde_types/">SDDE Problems</a></li><li><a class="tocitem" href="../../types/dae_types/">DAE Problems</a></li></ul></li><li><span class="tocitem">Solver Algorithms</span><ul><li><a class="tocitem" href="../../solvers/discrete_solve/">Discrete Solvers</a></li><li><a class="tocitem" href="../../solvers/ode_solve/">ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/split_ode_solve/">Split ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/steady_state_solve/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/bvp_solve/">BVP Solvers</a></li><li><a class="tocitem" href="../../solvers/sde_solve/">SDE Solvers</a></li><li><a class="tocitem" href="../../solvers/sdae_solve/">SDAE Solvers</a></li><li><a class="tocitem" href="../../solvers/rode_solve/">RODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dde_solve/">DDE Solvers</a></li><li><a class="tocitem" href="../../solvers/sdde_solve/">SDDE Solvers</a></li><li><a class="tocitem" href="../../solvers/dae_solve/">Mass Matrix and Fully Implicit DAE Solvers</a></li><li><a class="tocitem" href="../../solvers/benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="tocitem">Additional Features</span><ul><li><a class="tocitem" href="../../features/performance_overloads/">Jacobians, Gradients, etc.</a></li><li><a class="tocitem" href="../../features/diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="tocitem" href="../../features/diffeq_operator/">Matrix-Free Linear Operators with SciMLOperators.jl</a></li><li><a class="tocitem" href="../../features/noise_process/">Noise Processes</a></li><li><a class="tocitem" href="../../features/linear_nonlinear/">Specifying (Non)Linear Solvers and Preconditioners</a></li><li><a class="tocitem" href="../../features/dae_initialization/">DAE Initialization</a></li><li><a class="tocitem" href="../../features/callback_functions/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../features/callback_library/">Callback Library</a></li><li><a class="tocitem" href="../../features/ensemble/">Parallel Ensemble Simulations</a></li><li><a class="tocitem" href="../../features/io/">I/O: Saving and Loading Solution Data</a></li><li><a class="tocitem" href="../../features/low_dep/">Reduced Compile Time, Optimizing Runtime, and Low Dependency Usage</a></li><li><a class="tocitem" href="../../features/progress_bar/">Progress Bar Integration</a></li></ul></li><li><span class="tocitem">Solver Package APIs</span><ul><li><input class="collapse-toggle" id="menuitem-9-1" type="checkbox" checked/><label class="tocitem" for="menuitem-9-1"><span class="docs-label">Native Julia Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../delaydiffeq/">DelayDiffEq.jl</a></li><li><a class="tocitem" href="../steadystatediffeq/">SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../boundaryvaluediffeq/">BoundaryValueDiffEq.jl</a></li><li class="is-active"><a class="tocitem" href>DiffEqCallbacks.jl</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Callback-APIs"><span>Callback APIs</span></a></li></ul></li><li><a class="tocitem" href="../simplediffeq/">SimpleDiffEq.jl</a></li><li><a class="tocitem" href="../dassl/">DASSL.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-2" type="checkbox"/><label class="tocitem" for="menuitem-9-2"><span class="docs-label">External Wrappers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../sundials/">Sundials.jl</a></li><li><a class="tocitem" href="../daskr/">DASKR.jl</a></li><li><a class="tocitem" href="../lsoda/">LSODA.jl</a></li><li><a class="tocitem" href="../odeinterfacediffeq/">ODEInterfaceDiffEq.jl</a></li></ul></li></ul></li><li><span class="tocitem">OrdinaryDiffEq.jl API</span><ul><li><a class="tocitem" href="../ordinarydiffeq/">OrdinaryDiffEq.jl: ODE solvers and utilities</a></li><li><a class="tocitem" href="../ordinarydiffeq/usage/">Usage</a></li><li><input class="collapse-toggle" id="menuitem-10-3" type="checkbox"/><label class="tocitem" for="menuitem-10-3"><span class="docs-label">Explicit Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ordinarydiffeq/explicit/Tsit5/">OrdinaryDiffEqTsit5</a></li><li><a class="tocitem" href="../ordinarydiffeq/explicit/Verner/">OrdinaryDiffEqVerner</a></li><li><a class="tocitem" href="../ordinarydiffeq/explicit/AdamsBashforthMoulton/">OrdinaryDiffEqAdamsBashforthMoulton</a></li><li><a class="tocitem" href="../ordinarydiffeq/explicit/LowStorageRK/">OrdinaryDiffEqLowStorageRK</a></li><li><a class="tocitem" href="../ordinarydiffeq/explicit/SSPRK/">OrdinaryDiffEqSSPRK</a></li><li><a class="tocitem" href="../ordinarydiffeq/explicit/LowOrderRK/">OrdinaryDiffEqLowOrderRK</a></li><li><a class="tocitem" href="../ordinarydiffeq/explicit/HighOrderRK/">OrdinaryDiffEqHighOrderRK</a></li><li><a class="tocitem" href="../ordinarydiffeq/explicit/Feagin/">OrdinaryDiffEqFeagin</a></li><li><a class="tocitem" href="../ordinarydiffeq/explicit/PRK/">OrdinaryDiffEqPRK</a></li><li><a class="tocitem" href="../ordinarydiffeq/explicit/QPRK/">OrdinaryDiffEqQPRK</a></li><li><a class="tocitem" href="../ordinarydiffeq/explicit/TaylorSeries/">OrdinaryDiffEqTaylorSeries</a></li><li><a class="tocitem" href="../ordinarydiffeq/explicit/Extrapolation/">OrdinaryDiffEqExtrapolation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-4" type="checkbox"/><label class="tocitem" for="menuitem-10-4"><span class="docs-label">Semi-Implicit Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ordinarydiffeq/semiimplicit/Rosenbrock/">OrdinaryDiffEqRosenbrock</a></li><li><a class="tocitem" href="../ordinarydiffeq/semiimplicit/StabilizedRK/">OrdinaryDiffEqStabilizedRK</a></li><li><a class="tocitem" href="../ordinarydiffeq/semiimplicit/ExponentialRK/">OrdinaryDiffEqExponentialRK</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-5" type="checkbox"/><label class="tocitem" for="menuitem-10-5"><span class="docs-label">Implicit Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ordinarydiffeq/implicit/SDIRK/">OrdinaryDiffEqSDIRK</a></li><li><a class="tocitem" href="../ordinarydiffeq/implicit/FIRK/">OrdinaryDiffEqFIRK</a></li><li><a class="tocitem" href="../ordinarydiffeq/implicit/BDF/">OrdinaryDiffEqBDF</a></li><li><a class="tocitem" href="../ordinarydiffeq/implicit/Extrapolation/">OrdinaryDiffEqExtrapolation</a></li><li><a class="tocitem" href="../ordinarydiffeq/implicit/PDIRK/">OrdinaryDiffEqPDIRK</a></li><li><a class="tocitem" href="../ordinarydiffeq/implicit/Nordsieck/">OrdinaryDiffEqNordsieck</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-6" type="checkbox"/><label class="tocitem" for="menuitem-10-6"><span class="docs-label">IMEX Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ordinarydiffeq/imex/IMEXMultistep/">OrdinaryDiffEqIMEXMultistep</a></li><li><a class="tocitem" href="../ordinarydiffeq/imex/StabilizedIRK/">OrdinaryDiffEqStabilizedIRK</a></li><li><a class="tocitem" href="../ordinarydiffeq/imex/IMEXBDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-7" type="checkbox"/><label class="tocitem" for="menuitem-10-7"><span class="docs-label">Dynamical ODE Explicit Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ordinarydiffeq/dynamicalodeexplicit/RKN/">OrdinaryDiffEqRKN</a></li><li><a class="tocitem" href="../ordinarydiffeq/dynamicalodeexplicit/SymplecticRK/">OrdinaryDiffEqSymplecticRK</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-8" type="checkbox"/><label class="tocitem" for="menuitem-10-8"><span class="docs-label">Semilinear ODE Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ordinarydiffeq/semilinear/ExponentialRK/">OrdinaryDiffEqExponentialRK</a></li><li><a class="tocitem" href="../ordinarydiffeq/semilinear/Linear/">OrdinaryDiffEqLinear</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-9" type="checkbox"/><label class="tocitem" for="menuitem-10-9"><span class="docs-label">Mass Matrix DAE Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ordinarydiffeq/massmatrixdae/Rosenbrock/">OrdinaryDiffEqRosenbrock</a></li><li><a class="tocitem" href="../ordinarydiffeq/massmatrixdae/BDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-10" type="checkbox"/><label class="tocitem" for="menuitem-10-10"><span class="docs-label">Fully Implicit DAE Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ordinarydiffeq/fullyimplicitdae/BDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-11" type="checkbox"/><label class="tocitem" for="menuitem-10-11"><span class="docs-label">Misc Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ordinarydiffeq/misc/">Miscellaneous Solvers</a></li></ul></li></ul></li><li><span class="tocitem">StochasticDiffEq.jl API</span><ul><li><a class="tocitem" href="../stochasticdiffeq/">StochasticDiffEq.jl: SDE solvers and utilities</a></li><li><a class="tocitem" href="../stochasticdiffeq/usage/">Usage</a></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Nonstiff Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../stochasticdiffeq/nonstiff/basic_methods/">Basic Nonstiff Methods</a></li><li><a class="tocitem" href="../stochasticdiffeq/nonstiff/sra_sri_methods/">SRA/SRI Methods - Stochastic Runge-Kutta</a></li><li><a class="tocitem" href="../stochasticdiffeq/nonstiff/high_weak_order/">High Weak Order Methods</a></li><li><a class="tocitem" href="../stochasticdiffeq/nonstiff/commutative_noise/">Commutative Noise Methods</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Stiff Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../stochasticdiffeq/stiff/implicit_methods/">Implicit Methods for Stiff SDEs</a></li><li><a class="tocitem" href="../stochasticdiffeq/stiff/split_step_methods/">Split-Step Methods for Fully Stiff Problems</a></li><li><a class="tocitem" href="../stochasticdiffeq/stiff/stabilized_methods/">Stabilized Methods (SROCK Family)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Jump Diffusion</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../stochasticdiffeq/jumpdiffusion/tau_leaping/">Tau-Leaping Methods for Jump-Diffusion</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Misc Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../stochasticdiffeq/misc/">Miscellaneous Methods</a></li></ul></li></ul></li><li><span class="tocitem">Extra Details</span><ul><li><a class="tocitem" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solver Package APIs</a></li><li><a class="is-disabled">Native Julia Solvers</a></li><li class="is-active"><a href>DiffEqCallbacks.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DiffEqCallbacks.jl</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="diffeqcallbacks_api"><a class="docs-heading-anchor" href="#diffeqcallbacks_api">DiffEqCallbacks.jl</a><a id="diffeqcallbacks_api-1"></a><a class="docs-heading-anchor-permalink" href="#diffeqcallbacks_api" title="Permalink"></a></h1><p>DiffEqCallbacks.jl provides a library of pre-built callbacks for use with the SciML differential equation solvers. These include saving callbacks, manifold projection, domain constraints, and more.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>DiffEqCallbacks.jl is included with DifferentialEquations.jl. To use it standalone:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;DiffEqCallbacks&quot;)
import DiffEqCallbacks</code></pre><h2 id="Callback-APIs"><a class="docs-heading-anchor" href="#Callback-APIs">Callback APIs</a><a id="Callback-APIs-1"></a><a class="docs-heading-anchor-permalink" href="#Callback-APIs" title="Permalink"></a></h2><h3 id="Manifold-Projection-Callbacks"><a class="docs-heading-anchor" href="#Manifold-Projection-Callbacks">Manifold Projection Callbacks</a><a id="Manifold-Projection-Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Manifold-Projection-Callbacks" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DiffEqCallbacks.ManifoldProjection"><a class="docstring-binding" href="#DiffEqCallbacks.ManifoldProjection"><code>DiffEqCallbacks.ManifoldProjection</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ManifoldProjection(
    manifold; nlsolve = missing, save = true, autonomous = nothing,
    manifold_jacobian = nothing, autodiff = nothing, kwargs...)</code></pre><p>In many cases, you may want to declare a manifold on which a solution lives. Mathematically, a manifold <code>M</code> is defined by a function <code>g</code> as the set of points where <code>g(u) = 0</code>. An embedded manifold can be a lower dimensional object which constrains the solution. For example, <code>g(u) = E(u) - C</code> where <code>E</code> is the energy of the system in state <code>u</code>, meaning that the energy must be constant (energy preservation). Thus by defining the manifold the solution should live on, you can retain desired properties of the solution.</p><p><code>ManifoldProjection</code> projects the solution of the differential equation to the chosen manifold <code>g</code>, conserving a property while conserving the order. It is a consequence of convergence proofs both in the deterministic and stochastic cases that post-step projection to manifolds keep the same convergence rate, thus any algorithm can be easily extended to conserve properties. If the solution is supposed to live on a specific manifold or conserve such property, this guarantees the conservation law without modifying the convergence properties.</p><p><strong>Arguments</strong></p><ul><li><code>manifold</code>: The residual function for the manifold. If the ODEProblem is an inplace problem, then <code>g</code> must be an inplace function of form <code>g(resid, u, p)</code> or <code>g(resid, u, p, t)</code> and similarly if the ODEProblem is an out-of-place problem then <code>g</code> must be a function of form <code>g(u, p)</code> or <code>g(u, p, t)</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>nlsolve</code>: Defaults to a special single-factorize algorithm (denoted by <code>missing</code>) that would work in most cases (See [1] for details). Alternatively, a nonlinear solver as defined in the <a href="https://docs.sciml.ai/NonlinearSolve/stable/basics/solve/">NonlinearSolve.jl format</a> can be specified. Additionally if NonlinearSolve.jl is loaded and <code>nothing</code> is specified a polyalgorithm is used.</li><li><code>save</code>: Whether to do the standard saving (applied after the callback)</li><li><code>autonomous</code>: Whether <code>g</code> is an autonomous function of the form <code>g(resid, u, p)</code> or <code>g(u, p)</code>. Specify it as <code>Val(::Bool)</code> to disable runtime branching. If <code>nothing</code>, we attempt to infer it from the signature of <code>g</code>.</li><li><code>residual_prototype</code>: The size of the manifold residual. If it is not specified, we assume it to be same as <code>u</code> in the inplace case. Else we run a single evaluation of <code>manifold</code> to determine the size.</li><li><code>kwargs</code>: All other keyword arguments are passed to <a href="https://docs.sciml.ai/NonlinearSolve/stable/basics/solve/">NonlinearSolve.jl</a> if <code>nlsolve</code> is not <code>missing</code>.</li><li><code>autodiff</code>: The autodifferentiation algorithm to use to compute the Jacobian if <code>manifold_jacobian</code> is not specified. This must be specified if <code>manifold_jacobian</code> is not specified.</li><li><code>manifold_jacobian</code>: The Jacobian of the manifold (wrt the state). This has the same signature as <code>manifold</code> and the first argument is the Jacobian if inplace.</li></ul><p><strong>Saveat Warning</strong></p><p>Note that the <code>ManifoldProjection</code> callback modifies the endpoints of the integration intervals and thus breaks assumptions of internal interpolations. Because of this, the values for given by saveat will not be order-matching. However, the interpolation error can be proportional to the change by the projection, so if the projection is making small changes then one is still safe. However, if there are large changes from each projection, you should consider only saving at stopping/projection times. To do this, set <code>tstops</code> to the same values as <code>saveat</code>. There is a performance hit by doing so because now the integrator is forced to stop at every saving point, but this is guerenteed to match the order of the integrator even with the ManifoldProjection.</p><p><strong>References</strong></p><p>[1] Ernst Hairer, Christian Lubich, Gerhard Wanner. Geometric Numerical Integration: Structure-Preserving Algorithms for Ordinary Differential Equations. Berlin ; New York :Springer, 2002.</p></div></section></details></article><h3 id="Saving-Callbacks"><a class="docs-heading-anchor" href="#Saving-Callbacks">Saving Callbacks</a><a id="Saving-Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-Callbacks" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DiffEqCallbacks.SavingCallback"><a class="docstring-binding" href="#DiffEqCallbacks.SavingCallback"><code>DiffEqCallbacks.SavingCallback</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">SavingCallback(save_func, saved_values::SavedValues;
    saveat = Vector{eltype(saved_values.t)}(),
    save_everystep = isempty(saveat),
    save_start = true,
    tdir = 1)</code></pre><p>The saving callback lets you define a function <code>save_func(u, t, integrator)</code> which returns quantities of interest that shall be saved.</p><p><strong>Arguments</strong></p><ul><li><code>save_func(u, t, integrator)</code> returns the quantities which shall be saved. Note that this should allocate the output (not as a view to <code>u</code>).</li><li><code>saved_values::SavedValues</code> is the types that <code>save_func</code> will return, i.e. <code>save_func(t, u, integrator)::savevalType</code>. It&#39;s specified via <code>SavedValues(typeof(t),savevalType)</code>, i.e. give the type for time and the type that <code>save_func</code> will output (or higher compatible type).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>saveat</code> mimics <code>saveat</code> in <code>solve</code> from <code>solve</code>.</li><li><code>save_everystep</code> mimics <code>save_everystep</code> from <code>solve</code>.</li><li><code>save_start</code> mimics <code>save_start</code> from <code>solve</code>.</li><li><code>save_end</code> mimics <code>save_end</code> from <code>solve</code>.</li><li><code>tdir</code> should be <code>sign(tspan[end]-tspan[1])</code>. It defaults to <code>1</code> and should be adapted if <code>tspan[1] &gt; tspan[end]</code>.</li></ul><p>The outputted values are saved into <code>saved_values</code>. Time points are found via <code>saved_values.t</code> and the values are <code>saved_values.saveval</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqCallbacks.SavedValues"><a class="docstring-binding" href="#DiffEqCallbacks.SavedValues"><code>DiffEqCallbacks.SavedValues</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SavedValues{tType&lt;:Real, savevalType}</code></pre><p>A struct used to save values of the time in <code>t::Vector{tType}</code> and additional values in <code>saveval::Vector{savevalType}</code>.</p></div></section></details></article><h3 id="Domain-Callbacks"><a class="docs-heading-anchor" href="#Domain-Callbacks">Domain Callbacks</a><a id="Domain-Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Domain-Callbacks" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DiffEqCallbacks.PositiveDomain"><a class="docstring-binding" href="#DiffEqCallbacks.PositiveDomain"><code>DiffEqCallbacks.PositiveDomain</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">PositiveDomain(u = nothing; save = true, abstol = nothing, scalefactor = nothing)</code></pre><p>Especially in biology and other natural sciences, a desired property of dynamical systems is the positive invariance of the positive cone, i.e. non-negativity of variables at time <span>$t_0$</span> ensures their non-negativity at times <span>$t \geq t_0$</span> for which the solution is defined. However, even if a system satisfies this property mathematically it can be difficult for ODE solvers to ensure it numerically, as these <a href="https://www.mathworks.com/help/matlab/math/nonnegative-ode-solution.html">MATLAB examples</a> show.</p><p>To deal with this problem, one can specify <code>isoutofdomain=(u,p,t) -&gt; any(x -&gt; x &lt; 0, u)</code> as additional <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/common_solver_opts/">solver option</a>, which will reject any step that leads to non-negative values and reduce the next time step. However, since this approach only rejects steps and hence calculations might be repeated multiple times until a step is accepted, it can be computationally expensive.</p><p>Another approach is taken by a <code>PositiveDomain</code> callback in DiffEqCallbacks.jl, which is inspired by <a href="https://www.sciencedirect.com/science/article/pii/S0096300304009683">Shampine&#39;s et al. paper about non-negative ODE solutions</a>. It reduces the next step by a certain scale factor until the extrapolated value at the next time point is non-negative with a certain tolerance. Extrapolations are cheap to compute but might be inaccurate, so if a time step is changed it is additionally reduced by a safety factor of 0.9. Since extrapolated values are only non-negative up to a certain tolerance and in addition actual calculations might lead to negative values, also any negative values at the current time point are set to 0. Hence, by this callback non-negative values at any time point are ensured in a computationally cheap way, but the quality of the solution depends on how accurately extrapolations approximate next time steps.</p><p>Please note, that the system should be defined also outside the positive domain, since even with these approaches, negative variables might occur during the calculations. Moreover, one should follow Shampine&#39;s et al. advice and set the derivative <span>$x&#39;_i$</span> of a negative component <span>$x_i$</span> to <span>$\max \{0, f_i(x, t)\}$</span>, where <span>$t$</span> denotes the current time point with state vector <span>$x$</span> and <span>$f_i$</span> is the <span>$i$</span>-th component of function <span>$f$</span> in an ODE system <span>$x&#39; = f(x, t)$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>u</code>: A prototype of the state vector of the integrator. A copy of it is saved and extrapolated values are written to it. If it is not specified, every application of the callback allocates a new copy of the state vector.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>save</code>: Whether to do the standard saving (applied after the callback).</li><li><code>abstol</code>: Tolerance up to, which negative extrapolated values are accepted. Element-wise tolerances are allowed. If it is not specified, every application of the callback uses the current absolute tolerances of the integrator.</li><li><code>scalefactor</code>: Factor by which an unaccepted time step is reduced. If it is not specified, time steps are halved.</li></ul><p><strong>References</strong></p><p>Shampine, Lawrence F., Skip Thompson, Jacek Kierzenka and G. D. Byrne. Non-negative solutions of ODEs. Applied Mathematics and Computation 170 (2005): 556-569.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqCallbacks.GeneralDomain"><a class="docstring-binding" href="#DiffEqCallbacks.GeneralDomain"><code>DiffEqCallbacks.GeneralDomain</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">GeneralDomain(
    g, u = nothing; save = true, abstol = nothing, scalefactor = nothing,
    autonomous = nothing, domain_jacobian = nothing,
    nlsolve_kwargs = (; abstol = 10 * eps()), kwargs...)</code></pre><p>A <code>GeneralDomain</code> callback in DiffEqCallbacks.jl generalizes the concept of a <code>PositiveDomain</code> callback to arbitrary domains.</p><p>Domains are specified by</p><ul><li>in-place functions <code>g(resid, u, p)</code> or <code>g(resid, u, p, t)</code> if the corresponding ODEProblem is an inplace problem, or</li><li>out-of-place functions <code>g(u, p)</code> or <code>g(u, p, t)</code> if the corresponding ODEProblem is an out-of-place problem.</li></ul><p>The function calculates residuals of a state vector <code>u</code> at time <code>t</code> relative to that domain, with <code>p</code> the parameters of the corresponding integrator.</p><p>As for <code>PositiveDomain</code>, steps are accepted if residuals of the extrapolated values at the next time step are below a certain tolerance. Moreover, this callback is automatically coupled with a <code>ManifoldProjection</code> that keeps all calculated state vectors close to the desired domain, but in contrast to a <code>PositiveDomain</code> callback the nonlinear solver in a <code>ManifoldProjection</code> cannot guarantee that all state vectors of the solution are actually inside the domain. Thus, a <code>PositiveDomain</code> callback should generally be preferred.</p><p><strong>Arguments</strong></p><ul><li><code>g</code>: the implicit definition of the domain as a function as described above which is zero when the value is in the domain.</li><li><code>u</code>: A prototype of the state vector of the integrator. A copy of it is saved and extrapolated values are written to it. If it is not specified, every application of the callback allocates a new copy of the state vector.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>save</code>: Whether to do the standard saving (applied after the callback).</li><li><code>abstol</code>: Tolerance up to, which residuals are accepted. Element-wise tolerances are allowed. If it is not specified, every application of the callback uses the current absolute tolerances of the integrator.</li><li><code>scalefactor</code>: Factor by which an unaccepted time step is reduced. If it is not specified, time steps are halved.</li><li><code>autonomous</code>: Whether <code>g</code> is an autonomous function of the form <code>g(resid, u, p)</code>. If it is not specified, it is determined automatically.</li><li><code>kwargs</code>: All other keyword arguments are passed to <a href="#DiffEqCallbacks.ManifoldProjection"><code>ManifoldProjection</code></a>.</li><li><code>nlsolve_kwargs</code>: All keyword arguments are passed to the nonlinear solver in <code>ManifoldProjection</code>. The default is <code>(; abstol = 10 * eps())</code>.</li><li><code>domain_jacobian</code>: The Jacobian of the domain (wrt the state). This has the same signature as <code>g</code> and the first argument is the Jacobian if inplace. This corresponds to the <code>manifold_jacobian</code> argument of <a href="#DiffEqCallbacks.ManifoldProjection"><code>ManifoldProjection</code></a>. Note that passing a <code>manifold_jacobian</code> is not supported for <code>GeneralDomain</code> and results in an error.</li></ul><p><strong>References</strong></p><p>Shampine, Lawrence F., Skip Thompson, Jacek Kierzenka and G. D. Byrne. Non-negative solutions of ODEs. Applied Mathematics and Computation 170 (2005): 556-569.</p></div></section></details></article><h3 id="Stepping-Callbacks"><a class="docs-heading-anchor" href="#Stepping-Callbacks">Stepping Callbacks</a><a id="Stepping-Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Stepping-Callbacks" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DiffEqCallbacks.StepsizeLimiter"><a class="docstring-binding" href="#DiffEqCallbacks.StepsizeLimiter"><code>DiffEqCallbacks.StepsizeLimiter</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">StepsizeLimiter(dtFE;safety_factor=9//10,max_step=false,cached_dtcache=0.0)</code></pre><p>In many cases, there is a known maximal stepsize for which the computation is stable and produces correct results. For example, in hyperbolic PDEs one normally needs to ensure that the stepsize stays below some <span>$\Delta t_{FE}$</span> determined by the CFL condition. For nonlinear hyperbolic PDEs this limit can be a function <code>dtFE(u,p,t)</code> which changes throughout the computation. The stepsize limiter lets you pass a function which will adaptively limit the stepsizes to match these constraints.</p><p><strong>Arguments</strong></p><ul><li><code>dtFE</code> is the maximal timestep and is calculated using the previous <code>t</code> and <code>u</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>safety_factor</code> is the factor below the true maximum that will be stepped to which defaults to <code>9//10</code>.</li><li><code>max_step=true</code> makes every step equal to <code>safety_factor*dtFE(u,p,t)</code> when the solver is set to <code>adaptive=false</code>.</li><li><code>cached_dtcache</code> should be set to match the type for time when not using Float64 values.</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqCallbacks.FunctionCallingCallback"><a class="docstring-binding" href="#DiffEqCallbacks.FunctionCallingCallback"><code>DiffEqCallbacks.FunctionCallingCallback</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">FunctionCallingCallback(func;
    funcat = Vector{Float64}(),
    func_everystep = isempty(funcat),
    func_start = true,
    tdir = 1)</code></pre><p>The function calling callback lets you define a function <code>func(u,t,integrator)</code> which gets called at the time points of interest. The constructor is:</p><ul><li><code>func(u, t, integrator)</code> is the function to be called.</li><li><code>funcat</code> values or interval that the function is sure to be evaluated at.</li><li><code>func_everystep</code> whether to call the function after each integrator step.</li><li><code>func_start</code> whether the function is called at the initial condition.</li><li><code>tdir</code> should be <code>sign(tspan[end]-tspan[1])</code>. It defaults to <code>1</code> and should be adapted if <code>tspan[1] &gt; tspan[end]</code>.</li></ul></div></section></details></article><h3 id="Termination-Callbacks"><a class="docs-heading-anchor" href="#Termination-Callbacks">Termination Callbacks</a><a id="Termination-Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Termination-Callbacks" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DiffEqCallbacks.TerminateSteadyState"><a class="docstring-binding" href="#DiffEqCallbacks.TerminateSteadyState"><code>DiffEqCallbacks.TerminateSteadyState</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">TerminateSteadyState(abstol = 1e-8, reltol = 1e-6, test = allDerivPass; min_t = nothing,
    wrap_test::Val = Val(true))</code></pre><p><code>TerminateSteadyState</code> can be used to solve the problem for the steady-state by running the solver until the derivatives of the problem converge to 0 or <code>tspan[2]</code> is reached. This is an alternative approach to root finding (see the <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/steady_state_solve/">Steady State Solvers</a> section).</p><p><strong>Arguments</strong></p><ul><li><code>abstol</code> and <code>reltol</code> are the absolute and relative tolerance, respectively. These tolerances may be specified as scalars or as arrays of the same length as the states of the problem.</li><li><code>test</code> represents the function that evaluates the condition for termination. The default condition is that all derivatives should become smaller than <code>abstol</code> or the states times <code>reltol</code>. The user can pass any other function to implement a different termination condition. Such function should take four arguments: <code>integrator</code>, <code>abstol</code>, <code>reltol</code>, and <code>min_t</code>.</li><li><code>wrap_test</code> can be set to <code>Val(false)</code>, in which case <code>test</code> must have the definition <code>test(u, t, integrator)</code>. Otherwise, <code>test</code> must have the definition <code>test(integrator, abstol, reltol, min_t)</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>min_t</code> specifies an optional minimum <code>t</code> before the steady state calculations are allowed to terminate.</li></ul></div></section></details></article><h3 id="Iterative-Callbacks"><a class="docs-heading-anchor" href="#Iterative-Callbacks">Iterative Callbacks</a><a id="Iterative-Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Iterative-Callbacks" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DiffEqCallbacks.IterativeCallback"><a class="docstring-binding" href="#DiffEqCallbacks.IterativeCallback"><code>DiffEqCallbacks.IterativeCallback</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">IterativeCallback(time_choice, user_affect!, tType = Float64;
    initial_affect = false, kwargs...)</code></pre><p>A callback to be used to iteratively apply some affect. For example, if given the first effect at <code>t₁</code>, you can define <code>t₂</code> to apply the next effect.</p><p><strong>Arguments</strong></p><ul><li><code>time_choice(integrator)</code> determines the time of the next callback. If <code>nothing</code> is returned for the time choice, then the iterator ends.</li><li><code>user_affect!</code> is the effect applied to the integrator at the stopping points.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>initial_affect</code> is whether to apply the affect at <code>t=0</code> which defaults to <code>false</code></li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqCallbacks.PeriodicCallback"><a class="docstring-binding" href="#DiffEqCallbacks.PeriodicCallback"><code>DiffEqCallbacks.PeriodicCallback</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">PeriodicCallback(f, Δt::Number; phase = 0, initial_affect = false,
    final_affect = false,
    kwargs...)</code></pre><p><code>PeriodicCallback</code> can be used when a function should be called periodically in terms of integration time (as opposed to wall time), i.e. at <code>t = tspan[1]</code>, <code>t = tspan[1] + Δt</code>, <code>t = tspan[1] + 2Δt</code>, and so on.</p><p>If a non-zero <code>phase</code> is provided, the invocations of the callback will be shifted by <code>phase</code> time units, i.e., the calls will occur at <code>t = tspan[1] + phase</code>, <code>t = tspan[1] + phase + Δt</code>, <code>t = tspan[1] + phase + 2Δt</code>, and so on.</p><p>This callback can, for example, be used to model a discrete-time controller for a continuous-time system, running at a fixed rate.</p><p><strong>Arguments</strong></p><ul><li><code>f</code> the <code>affect!(integrator)</code> function to be called periodically</li><li><code>Δt</code> is the period</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>phase</code> is a phase offset</li><li><code>initial_affect</code> is whether to apply the affect at the initial time, which defaults to <code>false</code></li><li><code>final_affect</code> is whether to apply the affect at the final time, which defaults to <code>false</code></li><li><code>kwargs</code> are keyword arguments accepted by the <code>DiscreteCallback</code> constructor.</li></ul></div></section></details></article><h3 id="Preset-Time-Callbacks"><a class="docs-heading-anchor" href="#Preset-Time-Callbacks">Preset Time Callbacks</a><a id="Preset-Time-Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Preset-Time-Callbacks" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DiffEqCallbacks.PresetTimeCallback"><a class="docstring-binding" href="#DiffEqCallbacks.PresetTimeCallback"><code>DiffEqCallbacks.PresetTimeCallback</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">PresetTimeCallback(tstops, user_affect!;
    initialize = DiffEqBase.INITIALIZE_DEFAULT,
    filter_tstops = true,
    kwargs...)</code></pre><p>A callback that adds callback <code>affect!</code> calls at preset times. No playing around with <code>tstops</code> or anything is required: this callback adds the triggers for you to make it automatic.</p><p><strong>Arguments</strong></p><ul><li><code>tstops</code>: the times for the <code>affect!</code> to trigger at.</li><li><code>user_affect!</code>: an <code>affect!(integrator)</code> function to use at the time points.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>filter_tstops</code>: Whether to filter out tstops beyond the end of the integration timespan. Defaults to true. If false, then tstops can extend the interval of integration.</li></ul></div></section></details></article><h3 id="AutoAbstol"><a class="docs-heading-anchor" href="#AutoAbstol">AutoAbstol</a><a id="AutoAbstol-1"></a><a class="docs-heading-anchor-permalink" href="#AutoAbstol" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DiffEqCallbacks.AutoAbstol"><a class="docstring-binding" href="#DiffEqCallbacks.AutoAbstol"><code>DiffEqCallbacks.AutoAbstol</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">AutoAbstol(save = true; init_curmax = 1e-6)</code></pre><p>Provides a way to automatically adapt the absolute tolerance to the problem. This helps the solvers automatically “learn” what appropriate limits are. This callback set starts the absolute tolerance at <code>init_curmax</code> (default <code>1e-6</code>), and at each iteration it is set to the maximum value that the state has thus far reached times the relative tolerance.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>save</code> determines whether this callback has saving enabled</li><li><code>init_curmax</code> is the initial <code>abstol</code>.</li></ul><p>If this callback is used in isolation, <code>save=true</code> is required for normal saving behavior. Otherwise, <code>save=false</code> should be set to ensure extra saves do not occur.</p></div></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../boundaryvaluediffeq/">« BoundaryValueDiffEq.jl</a><a class="docs-footer-nextpage" href="../simplediffeq/">SimpleDiffEq.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 22 January 2026 00:07">Thursday 22 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
