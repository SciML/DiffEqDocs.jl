<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sundials.jl · DifferentialEquations.jl</title><meta name="title" content="Sundials.jl · DifferentialEquations.jl"/><meta property="og:title" content="Sundials.jl · DifferentialEquations.jl"/><meta property="twitter:title" content="Sundials.jl · DifferentialEquations.jl"/><meta name="description" content="Documentation for DifferentialEquations.jl."/><meta property="og:description" content="Documentation for DifferentialEquations.jl."/><meta property="twitter:description" content="Documentation for DifferentialEquations.jl."/><meta property="og:url" content="https://docs.sciml.ai/DiffEqDocs/stable/api/sundials/"/><meta property="twitter:url" content="https://docs.sciml.ai/DiffEqDocs/stable/api/sundials/"/><link rel="canonical" href="https://docs.sciml.ai/DiffEqDocs/stable/api/sundials/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DifferentialEquations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">DifferentialEquations.jl: Efficient Differential Equation Solving in Julia</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started with Differential Equations in Julia</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/faster_ode_example/">Code Optimization for Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/advanced_ode_example/">Solving Large Stiff Equations</a></li><li><a class="tocitem" href="../../tutorials/sde_example/">Stochastic Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/rode_example/">Random Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dde_example/">Delay Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dae_example/">Differential Algebraic Equations</a></li><li><a class="tocitem" href="../../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="tocitem" href="../../tutorials/bvp_example/">Boundary Value Problems</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Beginner</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/classical_physics/">Classical Physics Models</a></li><li><a class="tocitem" href="../../examples/conditional_dosing/">Conditional Dosing in Pharmacometrics</a></li><li><a class="tocitem" href="../../examples/kepler_problem/">The Kepler Problem</a></li><li><a class="tocitem" href="../../examples/outer_solar_system/">Simulating the Outer Solar System</a></li><li><a class="tocitem" href="../../examples/min_and_max/">Finding Maxima and Minima of ODEs Solutions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Advanced</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/spiking_neural_systems/">Spiking Neural Systems</a></li><li><a class="tocitem" href="../../examples/beeler_reuter/">An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model</a></li><li><a class="tocitem" href="../../examples/diffusion_implicit_heat_equation/">Solving the heat equation with diffusion-implicit time-stepping</a></li></ul></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../basics/common_solver_opts/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../basics/solution/">Solution Handling</a></li><li><a class="tocitem" href="../../basics/plot/">Plot Functions</a></li><li><a class="tocitem" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="tocitem" href="../../basics/problem/">Problem Interface</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="tocitem">Problem Types</span><ul><li><a class="tocitem" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="tocitem" href="../../types/ode_types/">ODE Problems</a></li><li><a class="tocitem" href="../../types/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group Problems</a></li><li><a class="tocitem" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="tocitem" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="tocitem" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="tocitem" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="tocitem" href="../../types/sde_types/">SDE Problems</a></li><li><a class="tocitem" href="../../types/sdae_types/">SDAE Problems</a></li><li><a class="tocitem" href="../../types/rode_types/">RODE Problems</a></li><li><a class="tocitem" href="../../types/dde_types/">DDE Problems</a></li><li><a class="tocitem" href="../../types/sdde_types/">SDDE Problems</a></li><li><a class="tocitem" href="../../types/dae_types/">DAE Problems</a></li></ul></li><li><span class="tocitem">Solver Algorithms</span><ul><li><a class="tocitem" href="../../solvers/discrete_solve/">Discrete Solvers</a></li><li><a class="tocitem" href="../../solvers/ode_solve/">ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/split_ode_solve/">Split ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/steady_state_solve/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/bvp_solve/">BVP Solvers</a></li><li><a class="tocitem" href="../../solvers/sde_solve/">SDE Solvers</a></li><li><a class="tocitem" href="../../solvers/sdae_solve/">SDAE Solvers</a></li><li><a class="tocitem" href="../../solvers/rode_solve/">RODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dde_solve/">DDE Solvers</a></li><li><a class="tocitem" href="../../solvers/sdde_solve/">SDDE Solvers</a></li><li><a class="tocitem" href="../../solvers/dae_solve/">Mass Matrix and Fully Implicit DAE Solvers</a></li><li><a class="tocitem" href="../../solvers/benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="tocitem">Additional Features</span><ul><li><a class="tocitem" href="../../features/performance_overloads/">Jacobians, Gradients, etc.</a></li><li><a class="tocitem" href="../../features/diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="tocitem" href="../../features/diffeq_operator/">DiffEqOperators</a></li><li><a class="tocitem" href="../../features/noise_process/">Noise Processes</a></li><li><a class="tocitem" href="../../features/linear_nonlinear/">Specifying (Non)Linear Solvers and Preconditioners</a></li><li><a class="tocitem" href="../../features/callback_functions/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../features/callback_library/">Callback Library</a></li><li><a class="tocitem" href="../../features/ensemble/">Parallel Ensemble Simulations</a></li><li><a class="tocitem" href="../../features/io/">I/O: Saving and Loading Solution Data</a></li><li><a class="tocitem" href="../../features/low_dep/">Reduced Compile Time, Optimizing Runtime, and Low Dependency Usage</a></li><li><a class="tocitem" href="../../features/progress_bar/">Progress Bar Integration</a></li></ul></li><li><span class="tocitem">Detailed Solver APIs</span><ul><li class="is-active"><a class="tocitem" href>Sundials.jl</a><ul class="internal"><li><a class="tocitem" href="#ODE-Solver-APIs"><span>ODE Solver APIs</span></a></li><li><a class="tocitem" href="#DAE-Solver-APIs"><span>DAE Solver APIs</span></a></li></ul></li><li><a class="tocitem" href="../daskr/">DASKR.jl</a></li></ul></li><li><span class="tocitem">Extra Details</span><ul><li><a class="tocitem" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Detailed Solver APIs</a></li><li class="is-active"><a href>Sundials.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sundials.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/DiffEqDocs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/DiffEqDocs.jl/blob/master/docs/src/api/sundials.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="sundials"><a class="docs-heading-anchor" href="#sundials">Sundials.jl</a><a id="sundials-1"></a><a class="docs-heading-anchor-permalink" href="#sundials" title="Permalink"></a></h1><p>This is a wrapper package for importing solvers from Sundials into the SciML interface. Note that these solvers do not come by default, and thus one needs to install the package before using these solvers:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;Sundials&quot;)
using Sundials</code></pre><p>These methods can be used independently of the rest of DifferentialEquations.jl.</p><h2 id="ODE-Solver-APIs"><a class="docs-heading-anchor" href="#ODE-Solver-APIs">ODE Solver APIs</a><a id="ODE-Solver-APIs-1"></a><a class="docs-heading-anchor-permalink" href="#ODE-Solver-APIs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sundials.CVODE_Adams" href="#Sundials.CVODE_Adams"><code>Sundials.CVODE_Adams</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CVODE_Adams(;method=:Functional,linear_solver=:None,
            jac_upper=0,jac_lower=0,
            stored_upper = jac_upper + jac_lower,
            krylov_dim=0,
            stability_limit_detect=false,
            max_hnil_warns = 10,
            max_order = 12,
            max_error_test_failures = 7,
            max_nonlinear_iters = 3,
            max_convergence_failures = 10,
            prec = nothing, psetup = nothing, prec_side = 0)</code></pre><p>CVODE_Adams: CVode Adams-Moulton solver.</p><p><strong>Method Choices</strong></p><ul><li>method - This is the method for solving the implicit equation. For BDF this defaults to   :Newton while for Adams this defaults to :Functional. These choices match the   recommended pairing in the Sundials.jl manual. However, note that using the :Newton   method may take less iterations but requires more memory than the :Function iteration   approach.</li><li>linear_solver - This is the linear solver which is used in the :Newton method.</li></ul><p><strong>Linear Solver Choices</strong></p><p>The choices for the linear solver are:</p><ul><li>:Dense - A dense linear solver.</li><li>:Band - A solver specialized for banded Jacobians. If used, you must set the position of the upper and lower non-zero diagonals via jac<em>upper and jac</em>lower.</li><li>:LapackDense - A version of the dense linear solver that uses the Julia-provided OpenBLAS-linked LAPACK for multithreaded operations. This will be faster than :Dense on larger systems but has noticable overhead on smaller (&lt;100 ODE) systems.</li><li>:LapackBand - A version of the banded linear solver that uses the Julia-provided OpenBLAS-linked LAPACK for multithreaded operations. This will be faster than :Band on larger systems but has noticable overhead on smaller (&lt;100 ODE) systems.</li><li>:Diagonal - This method is specialized for diagonal Jacobians.</li><li>:GMRES - A GMRES method. Recommended first choice Krylov method</li><li>:BCG - A Biconjugate gradient method.</li><li>:PCG - A preconditioned conjugate gradient method. Only for symmetric linear systems.</li><li>:TFQMR - A TFQMR method.</li><li>:KLU - A sparse factorization method. Requires that the user specifies a Jacobian. The Jacobian must be set as a sparse matrix in the ODEProblem type.</li></ul><p>Example:</p><pre><code class="language-julia hljs">CVODE_Adams() # Adams method using Newton + Dense solver
CVODE_Adams(method=:Functional) # Adams method using Functional iterations
CVODE_Adams(linear_solver=:Band,jac_upper=3,jac_lower=3) # Banded solver with nonzero diagonals 3 up and 3 down
CVODE_Adams(linear_solver=:BCG) # Biconjugate gradient method</code></pre><p><strong>Preconditioners</strong></p><p>Note that here <code>prec</code> is a preconditioner function <code>prec(z,r,p,t,y,fy,gamma,delta,lr)</code> where:</p><ul><li><code>z</code>: the computed output vector</li><li><code>r</code>: the right-hand side vector of the linear system</li><li><code>p</code>: the parameters</li><li><code>t</code>: the current independent variable</li><li><code>du</code>: the current value of <code>f(u,p,t)</code></li><li><code>gamma</code>: the <code>gamma</code> of <code>W = M - gamma*J</code></li><li><code>delta</code>: the iterative method tolerance</li><li><code>lr</code>: a flag for whether <code>lr=1</code> (left) or <code>lr=2</code> (right) preconditioning</li></ul><p>and <code>psetup</code> is the preconditioner setup function for pre-computing Jacobian information <code>psetup(p, t, u, du, jok, jcurPtr, gamma)</code>. Where:</p><ul><li><code>p</code>: the parameters</li><li><code>t</code>: the current independent variable</li><li><code>u</code>: the current state</li><li><code>du</code>: the current <code>f(u,p,t)</code></li><li><code>jok</code>: a bool indicating whether the Jacobian needs to be updated</li><li><code>jcurPtr</code>: a reference to an Int for whether the Jacobian was updated. <code>jcurPtr[]=true</code> should be set if the Jacobian was updated, and <code>jcurPtr[]=false</code> should be set if the Jacobian was not updated.</li><li><code>gamma</code>: the <code>gamma</code> of <code>W = M - gamma*J</code></li></ul><p><code>psetup</code> is optional when <code>prec</code> is set.</p><p><strong>Additional Options</strong></p><p>See <a href="https://computing.llnl.gov/sites/default/files/cv_guide-5.7.0.pdf">the CVODE manual</a> for details on the additional options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Sundials.jl/blob/v4.26.1/src/common_interface/algorithms.jl#L156-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sundials.CVODE_BDF" href="#Sundials.CVODE_BDF"><code>Sundials.CVODE_BDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CVODE_BDF(;method=:Newton,linear_solver=:Dense,
          jac_upper=0,jac_lower=0,
          stored_upper = jac_upper + jac_lower,
          non_zero=0,krylov_dim=0,
          stability_limit_detect=false,
          max_hnil_warns = 10,
          max_order = 5,
          max_error_test_failures = 7,
          max_nonlinear_iters = 3,
          max_convergence_failures = 10,
          prec = nothing, prec_side = 0)</code></pre><p>CVODE_BDF: CVode Backward Differentiation Formula (BDF) solver.</p><p><strong>Method Choices</strong></p><ul><li>method - This is the method for solving the implicit equation. For BDF this defaults to   :Newton while for Adams this defaults to :Functional. These choices match the   recommended pairing in the Sundials.jl manual. However, note that using the :Newton   method may take less iterations but requires more memory than the :Function iteration   approach.</li><li>linear_solver - This is the linear solver which is used in the :Newton method.</li></ul><p><strong>Linear Solver Choices</strong></p><p>The choices for the linear solver are:</p><ul><li>:Dense - A dense linear solver.</li><li>:Band - A solver specialized for banded Jacobians. If used, you must set the position of the upper and lower non-zero diagonals via jac<em>upper and jac</em>lower.</li><li>:LapackDense - A version of the dense linear solver that uses the Julia-provided OpenBLAS-linked LAPACK for multithreaded operations. This will be faster than :Dense on larger systems but has noticable overhead on smaller (&lt;100 ODE) systems.</li><li>:LapackBand - A version of the banded linear solver that uses the Julia-provided OpenBLAS-linked LAPACK for multithreaded operations. This will be faster than :Band on larger systems but has noticable overhead on smaller (&lt;100 ODE) systems.</li><li>:Diagonal - This method is specialized for diagonal Jacobians.</li><li>:GMRES - A GMRES method. Recommended first choice Krylov method</li><li>:BCG - A Biconjugate gradient method.</li><li>:PCG - A preconditioned conjugate gradient method. Only for symmetric linear systems.</li><li>:TFQMR - A TFQMR method.</li><li>:KLU - A sparse factorization method. Requires that the user specifies a Jacobian. The Jacobian must be set as a sparse matrix in the ODEProblem type.</li></ul><p>Example:</p><pre><code class="language-julia hljs">CVODE_BDF() # BDF method using Newton + Dense solver
CVODE_BDF(method=:Functional) # BDF method using Functional iterations
CVODE_BDF(linear_solver=:Band,jac_upper=3,jac_lower=3) # Banded solver with nonzero diagonals 3 up and 3 down
CVODE_BDF(linear_solver=:BCG) # Biconjugate gradient method</code></pre><p><strong>Preconditioners</strong></p><p>Note that here <code>prec</code> is a preconditioner function <code>prec(z,r,p,t,y,fy,gamma,delta,lr)</code> where:</p><ul><li><code>z</code>: the computed output vector</li><li><code>r</code>: the right-hand side vector of the linear system</li><li><code>p</code>: the parameters</li><li><code>t</code>: the current independent variable</li><li><code>du</code>: the current value of <code>f(u,p,t)</code></li><li><code>gamma</code>: the <code>gamma</code> of <code>W = M - gamma*J</code></li><li><code>delta</code>: the iterative method tolerance</li><li><code>lr</code>: a flag for whether <code>lr=1</code> (left) or <code>lr=2</code> (right) preconditioning</li></ul><p>and <code>psetup</code> is the preconditioner setup function for pre-computing Jacobian information <code>psetup(p, t, u, du, jok, jcurPtr, gamma)</code>. Where:</p><ul><li><code>p</code>: the parameters</li><li><code>t</code>: the current independent variable</li><li><code>u</code>: the current state</li><li><code>du</code>: the current <code>f(u,p,t)</code></li><li><code>jok</code>: a bool indicating whether the Jacobian needs to be updated</li><li><code>jcurPtr</code>: a reference to an Int for whether the Jacobian was updated. <code>jcurPtr[]=true</code> should be set if the Jacobian was updated, and <code>jcurPtr[]=false</code> should be set if the Jacobian was not updated.</li><li><code>gamma</code>: the <code>gamma</code> of <code>W = M - gamma*J</code></li></ul><p><code>psetup</code> is optional when <code>prec</code> is set.</p><p><strong>Additional Options</strong></p><p>See <a href="https://computing.llnl.gov/sites/default/files/cv_guide-5.7.0.pdf">the CVODE manual</a> for details on the additional options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Sundials.jl/blob/v4.26.1/src/common_interface/algorithms.jl#L11-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sundials.ARKODE" href="#Sundials.ARKODE"><code>Sundials.ARKODE</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ARKODE(stiffness=Sundials.Implicit();
      method=:Newton,linear_solver=:Dense,
      jac_upper=0,jac_lower=0,stored_upper = jac_upper+jac_lower,
      non_zero=0,krylov_dim=0,
      max_hnil_warns = 10,
      max_error_test_failures = 7,
      max_nonlinear_iters = 3,
      max_convergence_failures = 10,
      predictor_method = 0,
      nonlinear_convergence_coefficient = 0.1,
      dense_order = 3,
      order = 4,
      set_optimal_params = false,
      crdown = 0.3,
      dgmax = 0.2,
      rdiv = 2.3,
      msbp = 20,
      adaptivity_method = 0,
      prec = nothing, psetup = nothing, prec_side = 0
      )</code></pre><p>ARKODE: Explicit and ESDIRK Runge-Kutta methods of orders 2-8 depending on choice of options.</p><p><strong>Tableau Choices</strong></p><p>The main options for ARKODE are the choice between explicit and implicit and the method order, given via:</p><p>ARKODE(Sundials.Explicit()) # Solve with explicit tableau of default order 4 ARKODE(Sundials.Implicit(),order = 3) # Solve with explicit tableau of order 3</p><p>The order choices for explicit are 2 through 8 and for implicit 3 through 5. Specific methods can also be set through the etable and itable options for explicit and implicit tableaus respectively. The available tableaus are:</p><p>etable:</p><ul><li>HEUN<em>EULER</em>2<em>1</em>2: 2nd order Heun&#39;s method</li><li>BOGACKI<em>SHAMPINE</em>4<em>2</em>3:</li><li>ARK324L2SA<em>ERK</em>4<em>2</em>3: explicit portion of Kennedy and Carpenter&#39;s 3rd order method</li><li>ZONNEVELD<em>5</em>3_4: 4th order explicit method</li><li>ARK436L2SA<em>ERK</em>6<em>3</em>4: explicit portion of Kennedy and Carpenter&#39;s 4th order method</li><li>SAYFY<em>ABURUB</em>6<em>3</em>4: 4th order explicit method</li><li>CASH<em>KARP</em>6<em>4</em>5: 5th order explicit method</li><li>FEHLBERG<em>6</em>4_5: Fehlberg&#39;s classic 5th order method</li><li>DORMAND<em>PRINCE</em>7<em>4</em>5: the classic 5th order Dormand-Prince method</li><li>ARK548L2SA<em>ERK</em>8<em>4</em>5: explicit portion of Kennedy and Carpenter&#39;s 5th order method</li><li>VERNER<em>8</em>5_6: Verner&#39;s classic 5th order method</li><li>FEHLBERG<em>13</em>7_8: Fehlberg&#39;s 8th order method</li></ul><p>itable:</p><ul><li>SDIRK<em>2</em>1_2: An A-B-stable 2nd order SDIRK method</li><li>BILLINGTON<em>3</em>3_2: A second order method with a 3rd order error predictor of less stability</li><li>TRBDF2<em>3</em>3_2: The classic TR-BDF2 method</li><li>KVAERNO<em>4</em>2_3: an L-stable 3rd order ESDIRK method</li><li>ARK324L2SA<em>DIRK</em>4<em>2</em>3: implicit portion of Kennedy and Carpenter&#39;s 3th order method</li><li>CASH<em>5</em>2_4: Cash&#39;s 4th order L-stable SDIRK method</li><li>CASH<em>5</em>3_4: Cash&#39;s 2nd 4th order L-stable SDIRK method</li><li>SDIRK<em>5</em>3_4: Hairer&#39;s 4th order SDIRK method</li><li>KVAERNO<em>5</em>3_4: Kvaerno&#39;s 4th order ESDIRK method</li><li>ARK436L2SA<em>DIRK</em>6<em>3</em>4: implicit portion of Kennedy and Carpenter&#39;s 4th order method</li><li>KVAERNO<em>7</em>4_5: Kvaerno&#39;s 5th order ESDIRK method</li><li>ARK548L2SA<em>DIRK</em>8<em>4</em>5: implicit portion of Kennedy and Carpenter&#39;s 5th order method</li></ul><p>These can be set for example via:</p><pre><code class="language-julia hljs">ARKODE(Sundials.Explicit(),etable = Sundials.DORMAND_PRINCE_7_4_5)
ARKODE(Sundials.Implicit(),itable = Sundials.KVAERNO_4_2_3)</code></pre><p><strong>Method Choices</strong></p><ul><li>method - This is the method for solving the implicit equation. For BDF this defaults to   :Newton while for Adams this defaults to :Functional. These choices match the   recommended pairing in the Sundials.jl manual. However, note that using the :Newton   method may take less iterations but requires more memory than the :Function iteration   approach.</li><li>linear_solver - This is the linear solver which is used in the :Newton method.</li></ul><p><strong>Linear Solver Choices</strong></p><p>The choices for the linear solver are:</p><ul><li>:Dense - A dense linear solver.</li><li>:Band - A solver specialized for banded Jacobians. If used, you must set the position of the upper and lower non-zero diagonals via jac<em>upper and jac</em>lower.</li><li>:LapackDense - A version of the dense linear solver that uses the Julia-provided OpenBLAS-linked LAPACK for multithreaded operations. This will be faster than :Dense on larger systems but has noticable overhead on smaller (&lt;100 ODE) systems.</li><li>:LapackBand - A version of the banded linear solver that uses the Julia-provided OpenBLAS-linked LAPACK for multithreaded operations. This will be faster than :Band on larger systems but has noticable overhead on smaller (&lt;100 ODE) systems.</li><li>:Diagonal - This method is specialized for diagonal Jacobians.</li><li>:GMRES - A GMRES method. Recommended first choice Krylov method</li><li>:BCG - A Biconjugate gradient method.</li><li>:PCG - A preconditioned conjugate gradient method. Only for symmetric linear systems.</li><li>:TFQMR - A TFQMR method.</li><li>:KLU - A sparse factorization method. Requires that the user specifies a Jacobian. The Jacobian must be set as a sparse matrix in the ODEProblem type.</li></ul><p><strong>Preconditioners</strong></p><p>Note that here <code>prec</code> is a preconditioner function <code>prec(z,r,p,t,y,fy,gamma,delta,lr)</code> where:</p><ul><li><code>z</code>: the computed output vector</li><li><code>r</code>: the right-hand side vector of the linear system</li><li><code>p</code>: the parameters</li><li><code>t</code>: the current independent variable</li><li><code>du</code>: the current value of <code>f(u,p,t)</code></li><li><code>gamma</code>: the <code>gamma</code> of <code>W = M - gamma*J</code></li><li><code>delta</code>: the iterative method tolerance</li><li><code>lr</code>: a flag for whether <code>lr=1</code> (left) or <code>lr=2</code> (right) preconditioning</li></ul><p>and <code>psetup</code> is the preconditioner setup function for pre-computing Jacobian information <code>psetup(p, t, u, du, jok, jcurPtr, gamma)</code>. Where:</p><ul><li><code>p</code>: the parameters</li><li><code>t</code>: the current independent variable</li><li><code>u</code>: the current state</li><li><code>du</code>: the current <code>f(u,p,t)</code></li><li><code>jok</code>: a bool indicating whether the Jacobian needs to be updated</li><li><code>jcurPtr</code>: a reference to an Int for whether the Jacobian was updated. <code>jcurPtr[]=true</code> should be set if the Jacobian was updated, and <code>jcurPtr[]=false</code> should be set if the Jacobian was not updated.</li><li><code>gamma</code>: the <code>gamma</code> of <code>W = M - gamma*J</code></li></ul><p><code>psetup</code> is optional when <code>prec</code> is set.</p><p><strong>Additional Options</strong></p><p>See the <a href="https://computing.llnl.gov/sites/default/files/ark_guide-4.7.0.pdf">ARKODE manual</a> for details on the additional options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Sundials.jl/blob/v4.26.1/src/common_interface/algorithms.jl#L301-L434">source</a></section></article><h2 id="DAE-Solver-APIs"><a class="docs-heading-anchor" href="#DAE-Solver-APIs">DAE Solver APIs</a><a id="DAE-Solver-APIs-1"></a><a class="docs-heading-anchor-permalink" href="#DAE-Solver-APIs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sundials.IDA" href="#Sundials.IDA"><code>Sundials.IDA</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IDA(;linear_solver=:Dense,jac_upper=0,jac_lower=0,krylov_dim=0,
    max_order = 5,
    max_error_test_failures = 7,
    max_nonlinear_iters = 3,
    nonlinear_convergence_coefficient = 0.33,
    nonlinear_convergence_coefficient_ic = 0.0033,
    max_num_steps_ic = 5,
    max_num_jacs_ic = 4,
    max_num_iters_ic = 10,
    max_num_backs_ic = 100,
    use_linesearch_ic = true,
    max_convergence_failures = 10,
    init_all = false,
    prec = nothing, psetup = nothing)</code></pre><p>IDA: This is the IDA method from the Sundials.jl package.</p><p><strong>Linear Solvers</strong></p><p>Note that the constructors for the Sundials algorithms take a main argument: linearsolver - This is the linear solver which is used in the Newton iterations. The choices are:</p><ul><li>:Dense - A dense linear solver.</li><li>:Band - A solver specialized for banded Jacobians. If used, you must set the position of the upper and lower non-zero diagonals via jac<em>upper and jac</em>lower.</li><li>:LapackDense - A version of the dense linear solver that uses the Julia-provided OpenBLAS-linked LAPACK for multithreaded operations. This will be faster than :Dense on larger systems but has noticable overhead on smaller (&lt;100 ODE) systems.</li><li>:LapackBand - A version of the banded linear solver that uses the Julia-provided OpenBLAS-linked LAPACK for multithreaded operations. This will be faster than :Band on larger systems but has noticable overhead on smaller (&lt;100 ODE) systems.</li><li>:GMRES - A GMRES method. Recommended first choice Krylov method</li><li>:BCG - A Biconjugate gradient method.</li><li>:PCG - A preconditioned conjugate gradient method. Only for symmetric linear systems.</li><li>:TFQMR - A TFQMR method.</li><li>:KLU - A sparse factorization method. Requires that the user specifies a Jacobian. The Jacobian must be set as a sparse matrix in the ODEProblem type.</li></ul><p>Note that the preconditioner for iterative linear solvers (if supplied) should be a left preconditioner.</p><p>Example:</p><pre><code class="language-julia hljs">IDA() # Newton + Dense solver
IDA(linear_solver=:Band,jac_upper=3,jac_lower=3) # Banded solver with nonzero diagonals 3 up and 3 down
IDA(linear_solver=:BCG) # Biconjugate gradient method</code></pre><p><strong>Preconditioners</strong></p><p>Note that here <code>prec</code> is a (left) preconditioner function <code>prec(z,r,p,t,y,fy,gamma,delta)</code> where:</p><ul><li><code>z</code>: the computed output vector</li><li><code>r</code>: the right-hand side vector of the linear system</li><li><code>p</code>: the parameters</li><li><code>t</code>: the current independent variable</li><li><code>du</code>: the current value of <code>f(u,p,t)</code></li><li><code>gamma</code>: the <code>gamma</code> of <code>W = M - gamma*J</code></li><li><code>delta</code>: the iterative method tolerance</li></ul><p>and <code>psetup</code> is the preconditioner setup function for pre-computing Jacobian information. Where:</p><ul><li><code>p</code>: the parameters</li><li><code>t</code>: the current independent variable</li><li><code>resid</code>: the current residual</li><li><code>u</code>: the current state</li><li><code>du</code>: the current derivative of the state</li><li><code>gamma</code>: the <code>gamma</code> of <code>W = M - gamma*J</code></li></ul><p><code>psetup</code> is optional when <code>prec</code> is set.</p><p><strong>Additional Options</strong></p><p>See <a href="https://computing.llnl.gov/sites/default/files/ida_guide-5.7.0.pdf">the Sundials manual</a> for details on the additional options. The option <code>init_all</code> controls the initial condition consistency routine. If the initial conditions are inconsistent (i.e. they do not satisfy the implicit equation), <code>init_all=false</code> means that the algebraic variables and derivatives will be modified in order to satisfy the DAE. If <code>init_all=true</code>, all initial conditions will be modified to satisfy the DAE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Sundials.jl/blob/v4.26.1/src/common_interface/algorithms.jl#L562-L642">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../features/progress_bar/">« Progress Bar Integration</a><a class="docs-footer-nextpage" href="../daskr/">DASKR.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 22 January 2025 09:48">Wednesday 22 January 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
