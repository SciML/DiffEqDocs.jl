<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Chemical Reaction Models · DifferentialEquations.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-90474609-3', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://docs.juliadiffeq.org/stable/models/biological/index.html"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DifferentialEquations.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/ode_example/">Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/advanced_ode_example/">Solving Stiff Equations</a></li><li><a class="tocitem" href="../../tutorials/sde_example/">Stochastic Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/rode_example/">Random Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dde_example/">Delay Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dae_example/">Differential Algebraic Equations</a></li><li><a class="tocitem" href="../../tutorials/discrete_stochastic_example/">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="tocitem" href="../../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="tocitem" href="../../tutorials/bvp_example/">Boundary Value Problems</a></li><li><a class="tocitem" href="../../tutorials/additional/">Additional Tutorials</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../basics/common_solver_opts/">Common Solver Options</a></li><li><a class="tocitem" href="../../basics/solution/">Solution Handling</a></li><li><a class="tocitem" href="../../basics/plot/">Plot Functions</a></li><li><a class="tocitem" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="tocitem" href="../../basics/problem/">Problem Interface</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="tocitem">Problem Types</span><ul><li><a class="tocitem" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="tocitem" href="../../types/ode_types/">ODE Problems</a></li><li><a class="tocitem" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="tocitem" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="tocitem" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="tocitem" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="tocitem" href="../../types/sde_types/">SDE Problems</a></li><li><a class="tocitem" href="../../types/rode_types/">RODE Problems</a></li><li><a class="tocitem" href="../../types/dde_types/">DDE Problems</a></li><li><a class="tocitem" href="../../types/dae_types/">DAE Problems</a></li><li><a class="tocitem" href="../../types/jump_types/">Jump Problems</a></li></ul></li><li><span class="tocitem">Solver Algorithms</span><ul><li><a class="tocitem" href="../../solvers/discrete_solve/">Discrete Solvers</a></li><li><a class="tocitem" href="../../solvers/ode_solve/">ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/split_ode_solve/">Split ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/steady_state_solve/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/bvp_solve/">BVP Solvers</a></li><li><a class="tocitem" href="../../solvers/jump_solve/">Jump Problem Solvers</a></li><li><a class="tocitem" href="../../solvers/sde_solve/">SDE Solvers</a></li><li><a class="tocitem" href="../../solvers/rode_solve/">RODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dde_solve/">DDE Solvers</a></li><li><a class="tocitem" href="../../solvers/dae_solve/">DAE Solvers</a></li><li><a class="tocitem" href="../../solvers/benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="tocitem">Additional Features</span><ul><li><a class="tocitem" href="../../features/performance_overloads/">DiffEqFunctions (Jacobians, Gradients, etc.) and Jacobian Types</a></li><li><a class="tocitem" href="../../features/diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="tocitem" href="../../features/diffeq_operator/">DiffEqOperators</a></li><li><a class="tocitem" href="../../features/noise_process/">Noise Processes</a></li><li><a class="tocitem" href="../../features/linear_nonlinear/">Specifying (Non)Linear Solvers</a></li><li><a class="tocitem" href="../../features/callback_functions/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../features/callback_library/">Callback Library</a></li><li><a class="tocitem" href="../../features/ensemble/">Parallel Ensemble Simulations</a></li><li><a class="tocitem" href="../../features/io/">I/O: Saving and Loading Solution Data</a></li><li><a class="tocitem" href="../../features/low_dep/">Low Dependency Usage</a></li><li><a class="tocitem" href="../../features/progress_bar/">Progress Bar Integration</a></li></ul></li><li><span class="tocitem">Analysis Tools</span><ul><li><a class="tocitem" href="../../analysis/parameterized_functions/">ParameterizedFunctions</a></li><li><a class="tocitem" href="../../analysis/parameter_estimation/">Parameter Estimation and Bayesian Analysis</a></li><li><a class="tocitem" href="../../analysis/bifurcation/">Bifurcation Analysis</a></li><li><a class="tocitem" href="../../analysis/sensitivity/">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li><a class="tocitem" href="../../analysis/global_sensitivity/">Global Sensitivity Analysis</a></li><li><a class="tocitem" href="../../analysis/uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="tocitem" href="../../analysis/neural_networks/">Neural Networks</a></li><li><a class="tocitem" href="../../analysis/dev_and_test/">Algorithm Development and Testing</a></li></ul></li><li><span class="tocitem">Domain Modeling Tools</span><ul><li><a class="tocitem" href="../multiscale/">Multi-Scale Models</a></li><li><a class="tocitem" href="../physical/">Physical Models</a></li><li><a class="tocitem" href="../financial/">Financial Models</a></li><li class="is-active"><a class="tocitem" href>Chemical Reaction Models</a><ul class="internal"><li><a class="tocitem" href="#Installation-1"><span>Installation</span></a></li><li><a class="tocitem" href="#The-Reaction-DSL-Basic-1"><span>The Reaction DSL - Basic</span></a></li><li><a class="tocitem" href="#Model-Simulation-1"><span>Model Simulation</span></a></li><li><a class="tocitem" href="#The-Reaction-DSL-Advanced-1"><span>The Reaction DSL - Advanced</span></a></li><li><a class="tocitem" href="#The-Reaction-Network-Object-1"><span>The Reaction Network Object</span></a></li><li><a class="tocitem" href="#The-Min-Reaction-Network-Object-1"><span>The Min Reaction Network Object</span></a></li><li><a class="tocitem" href="#Chemical-Reaction-Network-Examples-1"><span>Chemical Reaction Network Examples</span></a></li></ul></li><li><a class="tocitem" href="../external_modeling/">External Modeling Packages</a></li></ul></li><li><span class="tocitem">APIs</span><ul><li><a class="tocitem" href="../../apis/diffeqbio/">DiffEqBiological.jl API</a></li></ul></li><li><span class="tocitem">Extra Details</span><ul><li><a class="tocitem" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li><li><a class="tocitem" href="../../extras/sensitivity_math/">Mathematics of Sensitivity Analysis</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Domain Modeling Tools</a></li><li class="is-active"><a href>Chemical Reaction Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Chemical Reaction Models</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/blob/master/docs/src/models/biological.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Chemical-Reaction-Models-1"><a class="docs-heading-anchor" href="#Chemical-Reaction-Models-1">Chemical Reaction Models</a><a class="docs-heading-anchor-permalink" href="#Chemical-Reaction-Models-1" title="Permalink"></a></h1><p>The biological models functionality is provided by <code>DiffEqBiological.jl</code> and helps the user to build discrete stochastic and differential equation based systems biological models. These tools allow one to define the models at a high level by specifying reactions and rate constants, and the creation of the actual problems is then handled by the modelling package.</p><h2 id="Installation-1"><a class="docs-heading-anchor" href="#Installation-1">Installation</a><a class="docs-heading-anchor-permalink" href="#Installation-1" title="Permalink"></a></h2><p>This functionality does not come standard with DifferentialEquations.jl. To use this functionality, you must install DiffEqBiological.jl:</p><pre><code class="language-julia">]add DiffEqBiological
using DiffEqBiological</code></pre><h2 id="The-Reaction-DSL-Basic-1"><a class="docs-heading-anchor" href="#The-Reaction-DSL-Basic-1">The Reaction DSL - Basic</a><a class="docs-heading-anchor-permalink" href="#The-Reaction-DSL-Basic-1" title="Permalink"></a></h2><p>This section covers some of the basic syntax for building chemical reaction network models. Examples showing how to both construct and solve network models are provided in <a href="#Chemical-Reaction-Network-Examples-1">Chemical Reaction Network Examples</a>.</p><h4 id="Basic-syntax-1"><a class="docs-heading-anchor" href="#Basic-syntax-1">Basic syntax</a><a class="docs-heading-anchor-permalink" href="#Basic-syntax-1" title="Permalink"></a></h4><p>The <code>@reaction_network</code> macro allows the (symbolic) specification of reaction networks with a simple format. Its input is a set of chemical reactions, and from them it generates a reaction network object which can be used as input to <code>ODEProblem</code>, <code>SteadyStateProblem</code>, <code>SDEProblem</code> and <code>JumpProblem</code> constructors. The <code>@min_reaction_network</code> macro constructs a more simplified reaction network, deferring construction of all the various functions needed for each of these problem types. It can then be incrementally filled in for specific problem types as needed, which reduces network construction time for very large networks (see <a href="#The-Min-Reaction-Network-Object-1">The Min Reaction Network Object</a> for a detailed description).</p><p>The basic syntax is:</p><pre><code class="language-julia">rn = @reaction_network begin
  2.0, X + Y --&gt; XY               
  1.0, XY --&gt; Z1 + Z2            
end</code></pre><p>where each line corresponds to a chemical reaction. Each reaction consists of a reaction rate (the expression on the left hand side of  <code>,</code>), a set of substrates (the expression in-between <code>,</code> and <code>--&gt;</code>), and a set of products (the expression on the right hand side of <code>--&gt;</code>). The substrates and the products may contain one or more reactants, separated by <code>+</code>.  The naming convention for these are the same as for normal variables in Julia.</p><p>The chemical reaction model is generated by the <code>@reaction_network</code> macro and stored in the <code>rn</code> variable (a normal variable, do not need to be called <code>rn</code>). The macro generates a differential equation model according to the law of mass action, in the above example the ODEs become:</p><div>\[\frac{d[X]}{dt} = -2 [X] [Y]\\
\frac{d[Y]}{dt} = -2 [X] [Y]\\
\frac{d[XY]}{dt} = 2 [X] [Y] - [XY]\\
\frac{d[Z1]}{dt}= [XY]\\
\frac{d[Z2]}{dt} = [XY]\]</div><h4 id="Arrow-variants-1"><a class="docs-heading-anchor" href="#Arrow-variants-1">Arrow variants</a><a class="docs-heading-anchor-permalink" href="#Arrow-variants-1" title="Permalink"></a></h4><p>Several types of arrows are accepted by the DSL and works instead of <code>--&gt;</code>. All of these works:  <code>&gt;</code>, <code>→</code> <code>↣</code>, <code>↦</code>, <code>⇾</code>, <code>⟶</code>, <code>⟼</code>, <code>⥟</code>, <code>⥟</code>, <code>⇀</code>, <code>⇁</code>. Backwards arrows can also be used to write the reaction in the opposite direction. Hence all of these three reactions are equivalent:</p><pre><code class="language-julia">rn = @reaction_network begin
  1.0, X + Y --&gt; XY               
  1.0, X + Y → XY      
  1.0, XY ← X + Y      
end</code></pre><p>(note that due to technical reasons <code>&lt;--</code> cannot be used)</p><h4 id="Using-bi-directional-arrows-1"><a class="docs-heading-anchor" href="#Using-bi-directional-arrows-1">Using bi-directional arrows</a><a class="docs-heading-anchor-permalink" href="#Using-bi-directional-arrows-1" title="Permalink"></a></h4><p>Bi-directional arrows can be used to designate a reaction that goes two ways. These two models are equivalent:</p><pre><code class="language-julia">rn = @reaction_network begin
  2.0, X + Y → XY             
  2.0, X + Y ← XY          
end
rn = @reaction_network begin
  2.0, X + Y ↔ XY               
end</code></pre><p>If the reaction rate in the backwards and forwards directions are different they can be designated in the following way:</p><pre><code class="language-julia">rn = @reaction_network begin
  (2.0,1.0) X + Y ↔ XY               
end</code></pre><p>which is identical to</p><pre><code class="language-julia">rn = @reaction_network begin
  2.0, X + Y → XY             
  1.0, X + Y ← XY          
end</code></pre><h4 id="Combining-several-reactions-in-one-line-1"><a class="docs-heading-anchor" href="#Combining-several-reactions-in-one-line-1">Combining several reactions in one line</a><a class="docs-heading-anchor-permalink" href="#Combining-several-reactions-in-one-line-1" title="Permalink"></a></h4><p>Several similar reactions can be combined in one line by providing a tuple of reaction rates and/or substrates and/or products. If several tuples are provided they much all be of identical length. These pairs of reaction networks are all identical:</p><pre><code class="language-julia">rn1 = @reaction_network begin
  1.0, S → (P1,P2)               
end
rn2 = @reaction_network begin
  1.0, S → P1     
  1.0, S → P2
end</code></pre><pre><code class="language-julia">rn1 = @reaction_network begin
  (1.0,2.0), (S1,S2) → P             
end
rn2 = @reaction_network begin
  1.0, S1 → P     
  2.0, S2 → P
end</code></pre><pre><code class="language-julia">rn1 = @reaction_network begin
  (1.0,2.0,3.0), (S1,S2,S3) → (P1,P2,P3)        
end
rn2 = @reaction_network begin
  1.0, S1 → P1
  2.0, S2 → P2   
  3.0, S3 → P3  
end</code></pre><p>This can also be combined with bi-directional arrows in which case separate tuples can be provided for the backward and forward reaction rates separately. These reaction networks are identical</p><pre><code class="language-julia">rn1 = @reaction_network begin
 (1.0,(1.0,2.0)), S ↔ (P1,P2)  
end
rn2 = @reaction_network begin
  1.0, S → P1
  1.0, S → P2
  1.0, P1 → S   
  2.0, P2 → S
end</code></pre><h4 id="Production-and-Destruction-and-Stoichiometry-1"><a class="docs-heading-anchor" href="#Production-and-Destruction-and-Stoichiometry-1">Production and Destruction and Stoichiometry</a><a class="docs-heading-anchor-permalink" href="#Production-and-Destruction-and-Stoichiometry-1" title="Permalink"></a></h4><p>Sometimes reactants are produced/destroyed from/to nothing. This can be designated using either <code>0</code> or <code>∅</code>:</p><pre><code class="language-julia">rn = @reaction_network begin
  2.0, 0 → X
  1.0, X → ∅
end</code></pre><p>Sometimes several molecules of the same reactant is involved in a reaction, the stoichiometry of a reactant in a reaction can be set using a number. Here two species of <code>X</code> forms the dimer <code>X2</code>:</p><pre><code class="language-julia">rn = @reaction_network begin
  1.0, 2X → X2
end</code></pre><p>this corresponds to the differential equation:</p><div>\[\frac{d[X]}{dt} = -[X]^2\\
\frac{d[X2]}{dt} = \frac{1}{2!} [X]^2\]</div><p>Other numbers than 2 can be used and parenthesises can be used to use the same stoichiometry for several reactants:</p><pre><code class="language-julia">rn = @reaction_network begin
  1.0, X + 2(Y + Z) → XY2Z2
end</code></pre><h4 id="Variable-reaction-rates-1"><a class="docs-heading-anchor" href="#Variable-reaction-rates-1">Variable reaction rates</a><a class="docs-heading-anchor-permalink" href="#Variable-reaction-rates-1" title="Permalink"></a></h4><p>Reaction rates do not need to be constant, but can also depend on the current concentration of the various reactants (when e.g. one reactant activate the production of another one). E.g. this is a valid notation:</p><pre><code class="language-julia">rn = @reaction_network begin
  X, Y → ∅
end</code></pre><p>and will have <code>Y</code> degraded at rate</p><div>\[\frac{d[Y]}{dt} = -[X][Y]\]</div><p>Note that this is actually equivalent to the reaction</p><pre><code class="language-julia">rn = @reaction_network begin
  1.0, X + Y → X
end</code></pre><p>Most expressions and functions are valid reaction rates, e.g:</p><pre><code class="language-julia">rn = @reaction_network begin
  2.0*X^2, 0 → X + Y
  gamma(Y)/5, X → ∅
  pi*X/Y, Y → ∅
end</code></pre><p>please note that user defined functions cannot be used directly (see later section &quot;User defined functions in reaction rates&quot;).</p><h4 id="Defining-parameters-1"><a class="docs-heading-anchor" href="#Defining-parameters-1">Defining parameters</a><a class="docs-heading-anchor-permalink" href="#Defining-parameters-1" title="Permalink"></a></h4><p>Just as when defining normal differential equations using <code>DifferentialEquations</code> parameter values does not need to be set when the model is created. Components can be designated as parameters by declaring them at the end:</p><pre><code class="language-julia">rn = @reaction_network begin
  p, ∅ → X
  d, X → ∅
end p d</code></pre><p>Parameters can only exist in the reaction rates (where they can be mixed with reactants). All variables not declared at the end will be considered a reactant.</p><h4 id="Pre-defined-functions-1"><a class="docs-heading-anchor" href="#Pre-defined-functions-1">Pre-defined functions</a><a class="docs-heading-anchor-permalink" href="#Pre-defined-functions-1" title="Permalink"></a></h4><p>Hill functions and a Michaelis-Menten function are pre-defined and can be used as rate laws. Below, the pair of reactions within <code>rn1</code> are equivalent, as are the pair of reactions within <code>rn2</code>:</p><pre><code class="language-julia">rn1 = @reaction_network begin
  hill(X,v,K,n), ∅ → X
  v*X^n/(X^n+K^n), ∅ → X
end v K n
rn2 = @reaction_network begin
  mm(X,v,K), ∅ → X
  v*X/(X+K), ∅ → X
end v K</code></pre><p>Repressor Hill (<code>hillr</code>) and Michaelis-Menten (<code>mmr</code>) functions are also provided:</p><pre><code class="language-julia">rn1 = @reaction_network begin
  hillr(X,v,K,n), ∅ → X
  v*K^n/(X^n+K^n), ∅ → X
end v K n
rn2 = @reaction_network begin
  mmr(X,v,K), ∅ → X
  v*K/(X+K), ∅ → X
end v K</code></pre><h2 id="Model-Simulation-1"><a class="docs-heading-anchor" href="#Model-Simulation-1">Model Simulation</a><a class="docs-heading-anchor-permalink" href="#Model-Simulation-1" title="Permalink"></a></h2><p>Once created, a reaction network can be used as input to various problem types which can be solved by <code>DifferentialEquations.jl</code>.</p><h4 id="Deterministic-simulations-using-ODEs-1"><a class="docs-heading-anchor" href="#Deterministic-simulations-using-ODEs-1">Deterministic simulations using ODEs</a><a class="docs-heading-anchor-permalink" href="#Deterministic-simulations-using-ODEs-1" title="Permalink"></a></h4><p>A reaction network can be used as input to an <code>ODEProblem</code> instead of a function, using <code>probODE = ODEProblem(rn, args...; kwargs...)</code> E.g. a model can be created and simulated using:</p><pre><code class="language-julia">rn = @reaction_network begin
  p, ∅ → X
  d, X → ∅
end p d
p = [1.0,2.0]
u0 = [0.1]
tspan = (0.,1.)
prob = ODEProblem(rn,u0,tspan,p)
sol = solve(prob)</code></pre><p>(if no parameters are given <code>p</code> does not need to be provided)</p><p>To solve for a steady-state starting from the guess <code>u0</code>, one can use</p><pre><code class="language-julia">prob = SteadyStateProblem(rn,u0,p)
sol = solve(prob, SSRootfind())</code></pre><p>or</p><pre><code class="language-julia">prob = SteadyStateProblem(rn,u0,p)
sol = solve(prob, DynamicSS(Tsit5()))</code></pre><h4 id="Stochastic-simulations-using-SDEs-1"><a class="docs-heading-anchor" href="#Stochastic-simulations-using-SDEs-1">Stochastic simulations using SDEs</a><a class="docs-heading-anchor-permalink" href="#Stochastic-simulations-using-SDEs-1" title="Permalink"></a></h4><p>In a similar way a SDE can be created using <code>probSDE = SDEProblem(rn, args...; kwargs...)</code>. In this case the chemical Langevin equations (as derived in Gillespie 2000) will be used to generate stochastic differential equations.</p><h4 id="Stochastic-simulations-using-discrete-stochastic-simulation-algorithms-1"><a class="docs-heading-anchor" href="#Stochastic-simulations-using-discrete-stochastic-simulation-algorithms-1">Stochastic simulations using discrete stochastic simulation algorithms</a><a class="docs-heading-anchor-permalink" href="#Stochastic-simulations-using-discrete-stochastic-simulation-algorithms-1" title="Permalink"></a></h4><p>Instead of solving SDEs one can create a stochastic jump process model using integer copy numbers and a discrete stochastic simulation algorithm. This can be done using:</p><pre><code class="language-julia">rn = @reaction_network begin
  p, ∅ → X
  d, X → ∅
end p d
p = [1.0,2.0]
u0 = [10]
tspan = (0.,1.)
discrete_prob = DiscreteProblem(rn, u0,tspan,p)
jump_prob = JumpProblem(discrete_prob,Direct(),rn)
sol = solve(jump_prob,SSAStepper())</code></pre><p>Here we used Gillespie&#39;s <code>Direct</code> method as the underlying stochastic simulation algorithm.</p><h4 id="Reaction-rate-laws-used-in-simulations-1"><a class="docs-heading-anchor" href="#Reaction-rate-laws-used-in-simulations-1">Reaction rate laws used in simulations</a><a class="docs-heading-anchor-permalink" href="#Reaction-rate-laws-used-in-simulations-1" title="Permalink"></a></h4><p>In generating mathematical models from a <code>reaction_network</code>, reaction rates are treated as <em>microscopic</em> rates. That is, for a general mass action reaction of the form <span>$n_1 S_1 + n_2 S_2 + \dots n_M S_M \to \dots$</span> with stoichiometric substrate coefficients <span>$\{n_i\}_{i=1}^M$</span> and rate constant <span>$k$</span>, the corresponding ODE rate law is taken to be</p><div>\[k \prod_{i=1}^M \frac{(S_i)^{n_i}}{n_i!},\]</div><p>while the jump process transition rate (i.e. propensity function) is</p><div>\[k \prod_{i=1}^M \frac{S_i (S_i-1) \dots (S_i-n_i+1)}{n_i!}.\]</div><p>For example, the ODE model of the reaction <span>$2X + 3Y \to Z$</span> with rate constant <span>$k$</span> would be</p><div>\[\frac{dX}{dt} =  -2 k \frac{X^2}{2!} \frac{Y^3}{3!} = -k \frac{X^2 Y^3}{3!} \\
\frac{dY}{dt} =  -3 k \frac{X^2}{2!} \frac{Y^3}{3!} = -k \frac{X^2 Y^3}{4} \\
\frac{dZ}{dt} = k \frac{X^2}{2!} \frac{Y^3}{3!}.\]</div><h2 id="The-Reaction-DSL-Advanced-1"><a class="docs-heading-anchor" href="#The-Reaction-DSL-Advanced-1">The Reaction DSL - Advanced</a><a class="docs-heading-anchor-permalink" href="#The-Reaction-DSL-Advanced-1" title="Permalink"></a></h2><p>This section covers some of the more advanced syntax for building chemical reaction network models (still not very complicated!).</p><h4 id="User-defined-functions-in-reaction-rates-1"><a class="docs-heading-anchor" href="#User-defined-functions-in-reaction-rates-1">User defined functions in reaction rates</a><a class="docs-heading-anchor-permalink" href="#User-defined-functions-in-reaction-rates-1" title="Permalink"></a></h4><p>The reaction network DSL cannot &quot;see&quot; user defined functions. E.g. this is not correct syntax:</p><pre><code class="language-julia">myHill(x) = 2.0*x^3/(x^3+1.5^3)
rn = @reaction_network begin
  myHill(X), ∅ → X
end</code></pre><p>However, it is possible to define functions in such a way that the DSL can see them using the <code>@reaction_func</code> macro:</p><pre><code class="language-julia">@reaction_func myHill(x) = 2.0*x^3/(x^3+1.5^3)
rn = @reaction_network begin
  myHill(X), ∅ → X
end</code></pre><h4 id="Defining-a-custom-reaction-network-type-1"><a class="docs-heading-anchor" href="#Defining-a-custom-reaction-network-type-1">Defining a custom reaction network type</a><a class="docs-heading-anchor-permalink" href="#Defining-a-custom-reaction-network-type-1" title="Permalink"></a></h4><p>While the default type of a reaction network is <code>reaction_network</code> (which inherits from <code>AbstractReactionNetwork</code>) it is possible to define a custom type (which also will inherit from <code>AbstractReactionNetwork</code>) by adding the type name as a first argument to the <code>@reaction_network</code> macro:</p><pre><code class="language-julia">rn = @reaction_network my_custom_type begin
  1.0, ∅ → X
end</code></pre><h4 id="Scaling-noise-in-the-chemical-Langevin-equations-1"><a class="docs-heading-anchor" href="#Scaling-noise-in-the-chemical-Langevin-equations-1">Scaling noise in the chemical Langevin equations</a><a class="docs-heading-anchor-permalink" href="#Scaling-noise-in-the-chemical-Langevin-equations-1" title="Permalink"></a></h4><p>When making stochastic simulations using SDEs it is possible to scale the amount of noise in the simulations by declaring a noise scaling parameter. This parameter is declared as a second argument to the <code>@reaction_network</code> macro (when scaling the noise one have to declare a custom type).</p><pre><code class="language-julia">rn = @reaction_network my_custom_type ns begin
  1.0, ∅ → X
end</code></pre><p>The noise scaling parameter is automatically added as a last argument to the parameter array (even if not declared at the end). E.g. this is correct syntax:</p><pre><code class="language-julia">rn = @reaction_network my_custom_type ns begin
  1.0, ∅ → X
end
p = [0.1,]
u0 = [0.1]
tspan = (0.,1.)
prob = SDEProblem(rn,u0,tspan,p)
sol = solve(prob)</code></pre><p>Here the amount of noise in the stochastic simulation will be reduced by a factor 10.</p><h4 id="Ignoring-mass-kinetics-1"><a class="docs-heading-anchor" href="#Ignoring-mass-kinetics-1">Ignoring mass kinetics</a><a class="docs-heading-anchor-permalink" href="#Ignoring-mass-kinetics-1" title="Permalink"></a></h4><p>While one in almost all cases want the reaction rate to take the law of mass action into account, so the reaction</p><pre><code class="language-julia">rn = @reaction_network my_custom_type ns begin
  k, X → ∅
end k</code></pre><p>occur at the rate <span>$d[X]/dt = -k[X]$</span>, it is possible to ignore this by using any of the following non-filled arrows when declaring the reaction: <code>⇐</code>, <code>⟽</code>, <code>⇒</code>, <code>⟾</code>, <code>⇔</code>, <code>⟺</code>. This means that the reaction</p><pre><code class="language-julia">rn = @reaction_network my_custom_type ns begin
  k, X ⇒ ∅
end k</code></pre><p>will occur at rate <span>$d[X]/dt = -k$</span> (which might become a problem since <span>$[X]$</span> will be degraded at a constant rate even when very small or equal to 0.</p><h2 id="The-Reaction-Network-Object-1"><a class="docs-heading-anchor" href="#The-Reaction-Network-Object-1">The Reaction Network Object</a><a class="docs-heading-anchor-permalink" href="#The-Reaction-Network-Object-1" title="Permalink"></a></h2><p>The <code>@reaction_network</code> macro generates a <code>reaction_network</code> object, which has a number of fields  which can be accessed.</p><ul><li><code>rn.f</code> is a function encoding the right hand side of the ODEs (i.e. the time derivatives of the chemical species).</li><li><code>rn.f_func</code> is a vector of expressions corresponding to the time derivatives of the chemical species.</li><li><code>rn.f_symfuncs</code> is a vector of <code>SymEngine</code> expressions corresponding to the time derivatives of the chemical species.</li><li><code>rn.g</code> is a function encoding the noise terms for the SDEs (see <code>rn.g_func</code> for details).</li><li><code>rn.g_func</code> is a vector containing expressions corresponding to the noise terms used when creating the SDEs (n*m elements when there are n reactants and m reactions. The first m elements correspond to the noise terms for the first reactant and each reaction, the next m elements for the second reactant and all reactions, and so on).</li><li><code>rn.jac</code> is a function that evaluates the Jacobian of <code>rn.f</code> in place. i.e. has the form <code>rn.jac(dJ,u,p,t)</code>, for pre-allocated Jacobian matrix <code>dJ</code>.</li><li><code>rn.jump_affect_expr</code> is a vector of expressions for how each reaction causes the species populations to change.</li><li><code>rn.jump_rate_expr</code> is a vector of expressions for how the transition rate (i.e. propensity) of each reaction is calculated from the species populations.</li><li><code>rn.jumps</code> is a vector storing a jump corresponding to each reaction (i.e. <code>ConstantRateJump</code>, <code>VariableRateJump</code>, etc...)</li><li><code>rn.odefun</code> stores an <code>ODEFunction</code> that can be used to create an <code>ODEProblem</code> corresponding to the reaction network.</li><li><code>rn.p_matrix</code> is a prototype matrix with the same size as the noise term.</li><li><code>rn.paramjac</code> is a function that evaluates the Jacobian of <code>rn.f</code> with respect to the <em>parameters</em>, <code>p</code>, in-place. It has the form <code>rn.paramjac(dpJ,u,p,t)</code> for pre-allocated parameter Jacobian matrix <code>dpJ</code>.</li><li><code>rn.params</code> is a vector containing symbols corresponding to all the parameters of the network.</li><li><code>rn.params_to_ints</code> provides a mapping from parameter symbol to the integer id of the parameter (i.e. where it is stored in the parameter vector passed to <code>ODEProblem</code>, <code>SDEProblem</code>, etc...)</li><li><code>rn.reactions</code> stores a vector of <code>DiffEqBiological.ReactionStruct</code>s, which collect info for their corresponding reaction (such as stoichiometric coefficients).</li><li><code>rn.regular_jumps</code> stores a <code>RegularJump</code> representation of the network, for use in <span>$\tau$</span>-leaping methods.</li><li><code>rn.scale_noise</code> is the noise scaling parameter symbol (if provided).</li><li><code>rn.sdefun</code> is a <code>SDEFunction</code> that can be used to create an <code>SDEProblem</code> corresponding to the reaction network.</li><li><code>rn.symjac</code> is the symbolically calculated Jacobian of the ODEs corresponding to the model.</li><li><code>rn.syms</code> is a vector containing symbols for all species of the network.</li><li><code>rn.syms_to_ints</code> is a map from the symbol of a species to its integer index within the solution vector.</li></ul><h2 id="The-Min-Reaction-Network-Object-1"><a class="docs-heading-anchor" href="#The-Min-Reaction-Network-Object-1">The Min Reaction Network Object</a><a class="docs-heading-anchor-permalink" href="#The-Min-Reaction-Network-Object-1" title="Permalink"></a></h2><p>The <code>@min_reaction_network</code> macro works similarly to the <code>@reaction_network</code> macro, but initially only fills in fields corresponding to basic reaction network properties (i.e. <code>rn.params</code>, <code>rn.params_to_ints</code>, <code>rn.scale_noise</code>, <code>rn.reactions</code>, <code>rn.syms</code>, and <code>rn.syms_to_ints</code>). To fill in the remaining fields call (in the following <code>[val]</code> denotes the default value of a keyword argument):</p><ul><li><code>addodes!(rn)</code> to complete ODE-related fields, optional keyword arguments include:<ul><li><code>build_jac=[true]</code>, is true if <code>rn.jac</code> and <code>rn.symjac</code> should be constructed. (Currently these build a dense Jacobian, so should be set to <code>false</code> for sufficiently large systems.)</li><li><code>build_symfuncs=[true]</code>, is true if symbolic functions should be constructed for each ODE rhs. It is recommended to disable this for larger systems to reduce memory usage and speedup network construction.</li></ul></li><li><code>addsdes!(rn)</code> to complete SDE-related fields. </li><li><code>addjumps!(rn)</code> to complete jump-related fields. <code>addjumps!</code> accepts several keyword arguments to control which jumps get created: <ul><li><code>build_jumps=[true]</code> is <code>true</code> if <code>rn.jumps</code> should be constructed. This can be set to <code>false</code> for regular jump problems, where only <code>rn.regular_jumps</code> is needed.</li><li><code>build_regular_jumps=[true]</code> is <code>true</code> if <code>rn.regular_jumps</code> should be constructed. This can be set to <code>false</code> for Gillespie-type jump problems, where <code>regular_jumps</code> are not used.</li><li><code>minimal_jumps=[false]</code> is <code>false</code> if <code>rn.jumps</code> should contain a jump for each possible reaction. If set to <code>true</code> jumps are only added to <code>rn.jumps</code> for non-mass action jumps. (Note, mass action jumps are still resolved within any jump simulation. This option simply speeds up the construction of the jump problem since entries in <code>rn.jumps</code> that correspond to mass action jumps are never directly called within jump simulations.)</li></ul></li></ul><p>For example, to simulate a jump process (i.e. Gillespie) simulation without constructing any <code>RegularJump</code>s, and only constructing a minimal set of jumps:</p><pre><code class="language-julia">rs = @min_reaction_network begin
  c1, X --&gt; 2X
  c2, X --&gt; 0
  c3, 0 --&gt; X
end c1 c2 c3
p = (2.0,1.0,0.5)
addjumps!(rs; build_regular_jumps=false, minimal_jumps=true)
prob = DiscreteProblem(rs, [5], (0.0, 4.0), p)
jump_prob = JumpProblem(prob, Direct(), rs)
sol = solve(jump_prob, SSAStepper())</code></pre><h2 id="Chemical-Reaction-Network-Examples-1"><a class="docs-heading-anchor" href="#Chemical-Reaction-Network-Examples-1">Chemical Reaction Network Examples</a><a class="docs-heading-anchor-permalink" href="#Chemical-Reaction-Network-Examples-1" title="Permalink"></a></h2><h4 id="Example:-Birth-Death-Process-1"><a class="docs-heading-anchor" href="#Example:-Birth-Death-Process-1">Example: Birth-Death Process</a><a class="docs-heading-anchor-permalink" href="#Example:-Birth-Death-Process-1" title="Permalink"></a></h4><pre><code class="language-julia">rs = @reaction_network begin
  c1, X --&gt; 2X
  c2, X --&gt; 0
  c3, 0 --&gt; X
end c1 c2 c3
p = (1.0,2.0,50.)
tspan = (0.,4.)
u0 = [5.]

# solve ODEs
oprob = ODEProblem(rs, u0, tspan, p)
osol  = solve(oprob, Tsit5())

# solve for Steady-States
ssprob = SteadyStateProblem(rs, u0, p)
sssol  = solve(ssprob, SSRootfind())

# solve SDEs
sprob = SDEProblem(rs, u0, tspan, p)
ssol  = solve(sprob, EM(), dt=.01)

# solve JumpProblem
u0 = [5]
dprob = DiscreteProblem(rs, u0, tspan, p)
jprob = JumpProblem(dprob, Direct(), rs)
jsol = solve(jprob, SSAStepper())</code></pre><h4 id="Example:-Michaelis-Menten-Enzyme-Kinetics-1"><a class="docs-heading-anchor" href="#Example:-Michaelis-Menten-Enzyme-Kinetics-1">Example: Michaelis-Menten Enzyme Kinetics</a><a class="docs-heading-anchor-permalink" href="#Example:-Michaelis-Menten-Enzyme-Kinetics-1" title="Permalink"></a></h4><pre><code class="language-julia">rs = @reaction_network begin
  c1, S + E --&gt; SE
  c2, SE --&gt; S + E
  c3, SE --&gt; P + E
end c1 c2 c3
p = (0.00166,0.0001,0.1)
tspan = (0., 100.)
u0 = [301., 100., 0., 0.]  # S = 301, E = 100, SE = 0, P = 0

# solve ODEs
oprob = ODEProblem(rs, u0, tspan, p)
osol  = solve(oprob, Tsit5())

# solve JumpProblem
u0 = [301, 100, 0, 0] 
dprob = DiscreteProblem(rs, u0, tspan, p)
jprob = JumpProblem(dprob, Direct(), rs)
jsol = solve(jprob, SSAStepper())</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../financial/">« Financial Models</a><a class="docs-footer-nextpage" href="../external_modeling/">External Modeling Packages »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 26 March 2020 16:08">Thursday 26 March 2020</span>. Using Julia version 1.1.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
