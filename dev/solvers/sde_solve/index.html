<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SDE Solvers · DifferentialEquations.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/sde_solve/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DifferentialEquations.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">DifferentialEquations.jl: Efficient Differential Equation Solving in Julia</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started with Differential Equations in Julia</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/faster_ode_example/">Code Optimization for Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/advanced_ode_example/">Solving Large Stiff Equations</a></li><li><a class="tocitem" href="../../tutorials/sde_example/">Stochastic Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/rode_example/">Random Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dde_example/">Delay Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dae_example/">Differential Algebraic Equations</a></li><li><a class="tocitem" href="../../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="tocitem" href="../../tutorials/bvp_example/">Boundary Value Problems</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Beginner</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/classical_physics/">Classical Physics Models</a></li><li><a class="tocitem" href="../../examples/conditional_dosing/">Conditional Dosing in Pharmacometrics</a></li><li><a class="tocitem" href="../../examples/kepler_problem/">The Kepler Problem</a></li><li><a class="tocitem" href="../../examples/outer_solar_system/">Simulating the Outer Solar System</a></li><li><a class="tocitem" href="../../examples/min_and_max/">Finding Maxima and Minima of ODEs Solutions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Advanced</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/spiking_neural_systems/">Spiking Neural Systems</a></li><li><a class="tocitem" href="../../examples/beeler_reuter/">An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model</a></li><li><a class="tocitem" href="../../examples/diffusion_implicit_heat_equation/">Solving the heat equation with diffusion-implicit time-stepping</a></li></ul></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../basics/common_solver_opts/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../basics/solution/">Solution Handling</a></li><li><a class="tocitem" href="../../basics/plot/">Plot Functions</a></li><li><a class="tocitem" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="tocitem" href="../../basics/problem/">Problem Interface</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="tocitem">Problem Types</span><ul><li><a class="tocitem" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="tocitem" href="../../types/ode_types/">ODE Problems</a></li><li><a class="tocitem" href="../../types/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group Problems</a></li><li><a class="tocitem" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="tocitem" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="tocitem" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="tocitem" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="tocitem" href="../../types/sde_types/">SDE Problems</a></li><li><a class="tocitem" href="../../types/sdae_types/">SDAE Problems</a></li><li><a class="tocitem" href="../../types/rode_types/">RODE Problems</a></li><li><a class="tocitem" href="../../types/dde_types/">DDE Problems</a></li><li><a class="tocitem" href="../../types/sdde_types/">SDDE Problems</a></li><li><a class="tocitem" href="../../types/dae_types/">DAE Problems</a></li></ul></li><li><span class="tocitem">Solver Algorithms</span><ul><li><a class="tocitem" href="../discrete_solve/">Discrete Solvers</a></li><li><a class="tocitem" href="../ode_solve/">ODE Solvers</a></li><li><a class="tocitem" href="../nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group ODE Solvers</a></li><li><a class="tocitem" href="../dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="tocitem" href="../split_ode_solve/">Split ODE Solvers</a></li><li><a class="tocitem" href="../steady_state_solve/">Steady State Solvers</a></li><li><a class="tocitem" href="../bvp_solve/">BVP Solvers</a></li><li class="is-active"><a class="tocitem" href>SDE Solvers</a><ul class="internal"><li><a class="tocitem" href="#Recommended-Methods"><span>Recommended Methods</span></a></li><li><a class="tocitem" href="#special_noise_forms"><span>Special Noise Forms</span></a></li><li><a class="tocitem" href="#Iterated-Integral-Approximations"><span>Iterated Integral Approximations</span></a></li><li><a class="tocitem" href="#Special-Keyword-Arguments"><span>Special Keyword Arguments</span></a></li><li><a class="tocitem" href="#Full-List-of-Methods"><span>Full List of Methods</span></a></li></ul></li><li><a class="tocitem" href="../sdae_solve/">SDAE Solvers</a></li><li><a class="tocitem" href="../rode_solve/">RODE Solvers</a></li><li><a class="tocitem" href="../dde_solve/">DDE Solvers</a></li><li><a class="tocitem" href="../sdde_solve/">SDDE Solvers</a></li><li><a class="tocitem" href="../dae_solve/">DAE Solvers</a></li><li><a class="tocitem" href="../benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="tocitem">Additional Features</span><ul><li><a class="tocitem" href="../../features/performance_overloads/">Jacobians, Gradients, etc.</a></li><li><a class="tocitem" href="../../features/diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="tocitem" href="../../features/diffeq_operator/">DiffEqOperators</a></li><li><a class="tocitem" href="../../features/noise_process/">Noise Processes</a></li><li><a class="tocitem" href="../../features/linear_nonlinear/">Specifying (Non)Linear Solvers and Preconditioners</a></li><li><a class="tocitem" href="../../features/callback_functions/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../features/callback_library/">Callback Library</a></li><li><a class="tocitem" href="../../features/ensemble/">Parallel Ensemble Simulations</a></li><li><a class="tocitem" href="../../features/io/">I/O: Saving and Loading Solution Data</a></li><li><a class="tocitem" href="../../features/low_dep/">Reduced Compile Time, Optimizing Runtime, and Low Dependency Usage</a></li><li><a class="tocitem" href="../../features/progress_bar/">Progress Bar Integration</a></li></ul></li><li><span class="tocitem">Detailed Solver APIs</span><ul><li><a class="tocitem" href="../../api/sundials/">Sundials.jl</a></li><li><a class="tocitem" href="../../api/daskr/">DASKR.jl</a></li></ul></li><li><span class="tocitem">Extra Details</span><ul><li><a class="tocitem" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solver Algorithms</a></li><li class="is-active"><a href>SDE Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SDE Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/DiffEqDocs.jl/blob/master/docs/src/solvers/sde_solve.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="sde_solve"><a class="docs-heading-anchor" href="#sde_solve">SDE Solvers</a><a id="sde_solve-1"></a><a class="docs-heading-anchor-permalink" href="#sde_solve" title="Permalink"></a></h1><h2 id="Recommended-Methods"><a class="docs-heading-anchor" href="#Recommended-Methods">Recommended Methods</a><a id="Recommended-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Recommended-Methods" title="Permalink"></a></h2><p>For most Ito diagonal and scalar noise problems where a good amount of accuracy is required and where mild stiffness may be an issue, the <code>SOSRI</code> algorithm should do well. If the problem has additive noise, then <code>SOSRA</code> will be the optimal algorithm. At low tolerances (<code>&lt;1e-4</code>?) <code>SRA3</code> will be more efficient, though <code>SOSRA</code> is more robust to stiffness. For commutative noise, <code>RKMilCommute</code> is a strong order 1.0 method which utilizes the commutativity property to greatly speed up the stochastic iterated integral approximation and can choose between Ito and Stratonovich. For non-commutative noise, difficult problems usually require adaptive time stepping in order to be efficient. In this case, <code>LambaEM</code> and <code>LambaEulerHeun</code> are adaptive and handle general non-diagonal problems (for Ito and Stratonovich interpretations, respectively). If adaptivity isn&#39;t necessary, the <code>EM</code> and <code>EulerHeun</code> are good choices (for Ito and Stratonovich interpretations, respectively).</p><p>For stiff problems with additive noise, the high order adaptive method <code>SKenCarp</code> is highly preferred and will solve problems with similar efficiency as ODEs. If possible, stiff problems should be converted to make use of this additive noise solver. If the noise term is large/stiff, then the split-step methods are required in order for the implicit methods to be stable. For Ito in this case, use <code>ISSEM</code> and for Stratonovich use <code>ISSEulerHeun</code>. These two methods can handle any noise form.</p><p>If the noise term is not too large, for stiff problems with diagonal noise, <code>ImplicitRKMil</code> is the most efficient method and can choose between Ito and Stratonovich. For each of the theta methods, the parameter <code>theta</code> can be chosen. The default is <code>theta=1/2</code> which will not dampen numerical oscillations and thus is symmetric (and almost symplectic) and will lead to less error when noise is sufficiently small. However, <code>theta=1/2</code> is not L-stable in the drift term, and thus one can receive more stability (L-stability in the drift term) with <code>theta=1</code>, but with a tradeoff of error efficiency in the low noise case. In addition, the option <code>symplectic=true</code> will turn these methods into an implicit Midpoint extension, which is symplectic in distribution but has an accuracy tradeoff.</p><p>If only an estimate of the expected value of the solution is required, i.e., if one is only interested in an accurate draw from the distribution induced by a given SDE, the use of high weak order solvers is recommended. Specifically, <code>DRI1</code> is preferred for a high number of Wiener processes. The weak stochastic Runge-Kutta solvers with weak order 2 due to Roessler are adaptive. All other high weak order solvers currently require a fixed step size.</p><h2 id="special_noise_forms"><a class="docs-heading-anchor" href="#special_noise_forms">Special Noise Forms</a><a id="special_noise_forms-1"></a><a class="docs-heading-anchor-permalink" href="#special_noise_forms" title="Permalink"></a></h2><p>Some solvers are for specialized forms of noise. Diagonal noise is the default setup. Non-diagonal noise is specified via setting <code>noise_rate_prototype</code> to a matrix in the <code>SDEProblem</code> type. A special form of non-diagonal noise, commutative noise, occurs when the noise satisfies the following condition:</p><p class="math-container">\[\sum_{i=1}^d g_{i,j_1}(t,x) \frac{\partial g_{k,j_2}(t,x)}{\partial x_i} = \sum_{i=1}^d g_{i,j_2}(t,x) \frac{\partial g_{k,j_1}(t,x)}{\partial x_i}\]</p><p>for every <span>$j_1,j_2$</span> and <span>$k$</span>. Additive noise is when <span>$g(t,u)=g(t)$</span>, i.e. is independent of <code>u</code>. Multiplicative noise is <span>$g_i(t,u)=a_i u$</span>.</p><h2 id="Iterated-Integral-Approximations"><a class="docs-heading-anchor" href="#Iterated-Integral-Approximations">Iterated Integral Approximations</a><a id="Iterated-Integral-Approximations-1"></a><a class="docs-heading-anchor-permalink" href="#Iterated-Integral-Approximations" title="Permalink"></a></h2><p>The difficulty of higher strong order integrators stems from the presence of iterated stochastic integrals</p><p class="math-container">\[I(h) = \int_0^h\int_0^sdW^1_tdW^2_s\]</p><p>in these schemes.</p><p>The approximation of these iterated integrals can be avoided, if the diffusion matrix satisfies the special commutativity condition given <a href="#special_noise_forms">above</a>. Because of this, many methods are only applicable to problems that satisfy the commutativity condition. In other words, many methods can only handle specific noise cases, like diagonal noise or commutative noise, because of how this iterated integral approximation is computed.</p><p>However, the methods for general SDEs, like <code>RKMilGeneral</code>, perform a direct approximation of the iterated integrals. For those methods, the algorithms have an <code>ii_approx</code> keyword argument that allows one to specify the method for the approximation. The choices are:</p><ul><li><code>IICommutative</code>: a simplification of the integral which assumes the noise commutativity property. If used on a non-commutative noise problem this will limit the strong convergence to 0.5.</li><li><code>IILevyArea</code>: computes the iterated integrals based on an approximation of the Levy area using the <a href="https://github.com/stochastics-uni-luebeck/LevyArea.jl">LevyArea.jl</a> package: Kastner, F. and Rößler, A., <a href="https://arxiv.org/abs/2201.08424">arXiv: 2201.08424</a> Kastner, F. and Rößler, A., LevyArea.jl, <a href="https://zenodo.org/record/5883749#.Yg-d698xmu4">10.5281/ZENODO.5883748</a>. The package supports the schemes: <code>Fourier()</code>, <code>Milstein()</code>, <code>Wiktorsson()</code>,<code>MronRoe()</code>. The optimal algorithm is automatically selected based on the dimension of the Brownian process and the step size. By passing a specific scheme, e.g., <code>ii_approx=Fourier()</code> methods can be manually selected. One must be careful when using the Levy area approximations in conjunction with adaptivity (<code>adaptive=true</code>) because the Levy area approximations draw random numbers that do not reflect the random numbers taken in a previous rejected step. This leads to a bias that increases with an increasing number of rejected steps.</li></ul><p>Example: <code>RKMilGeneral(;ii_approx=IILevyArea())</code>.</p><h2 id="Special-Keyword-Arguments"><a class="docs-heading-anchor" href="#Special-Keyword-Arguments">Special Keyword Arguments</a><a id="Special-Keyword-Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Special-Keyword-Arguments" title="Permalink"></a></h2><ul><li><code>save_noise</code>: Determines whether the values of <code>W</code> are saved whenever the timeseries is saved. Defaults to true.</li><li><code>delta</code>: The <code>delta</code> adaptivity parameter for the natural error estimator. Determines the balance between drift and diffusion error. For more details, see <a href="https://chrisrackauckas.com/assets/Papers/ChrisRackauckas-AdaptiveSRK.pdf">the publication</a>.</li><li><code>seed</code>: Sets the seed for the random number generator. This overrides any seed set in the <code>SDEProblem</code>.</li></ul><h2 id="Full-List-of-Methods"><a class="docs-heading-anchor" href="#Full-List-of-Methods">Full List of Methods</a><a id="Full-List-of-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Full-List-of-Methods" title="Permalink"></a></h2><h3 id="StochasticDiffEq.jl"><a class="docs-heading-anchor" href="#StochasticDiffEq.jl">StochasticDiffEq.jl</a><a id="StochasticDiffEq.jl-1"></a><a class="docs-heading-anchor-permalink" href="#StochasticDiffEq.jl" title="Permalink"></a></h3><p>Each of the StochasticDiffEq.jl solvers come with a linear interpolation. Orders are given in terms of strong order.</p><h4 id="Nonstiff-Methods"><a class="docs-heading-anchor" href="#Nonstiff-Methods">Nonstiff Methods</a><a id="Nonstiff-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Nonstiff-Methods" title="Permalink"></a></h4><ul><li><code>EM</code>- The Euler-Maruyama method. Strong Order 0.5 in the Ito sense. Has an optional argument <code>split=true</code> for controlling step splitting. When splitting is enabled, the stability with large diffusion eigenvalues is improved. Can handle all forms of noise, including non-diagonal, scalar, and colored noise. Fixed time step only.†</li><li><code>LambaEM</code>- A modified Euler-Maruyama method with adaptive time stepping with an error estimator based on Lamba and Rackauckas. Has an optional argument <code>split=true</code> for controlling step splitting. When splitting is enabled, the stability with   large diffusion eigenvalues is improved. Strong Order 0.5 in the Ito sense. Can handle all forms of noise, including non-diagonal, scalar, and colored noise.†</li><li><code>EulerHeun</code> - The Euler-Heun method. Strong Order 0.5 in the Stratonovich sense. Can handle all forms of noise, including non-diagonal, scalar, and colored noise. Fixed time step only.†</li><li><code>LambaEulerHeun</code> - A modified Euler-Heun method with adaptive time stepping with an error estimator based on Lamba due to Rackauckas. Strong order 0.5 in the Stratonovich sense. Can handle all forms of noise, including non-diagonal, scalar, and colored noise.†</li><li><code>RKMil</code> - An explicit Runge-Kutta discretization of the strong order 1.0 Milstein method. Defaults to solving the Ito problem, but <code>RKMil(interpretation=:Stratonovich)</code> makes it solve the Stratonovich problem. Only handles scalar and diagonal noise.†</li><li><code>RKMilCommute</code> - An explicit Runge-Kutta discretization of the strong order 1.0 Milstein method for commutative noise problems. Defaults to solving the Ito problem, but <code>RKMilCommute(interpretation=:Stratonovich)</code> makes it solve the Stratonovich problem. Uses a 1.5/2.0 error estimate for adaptive time stepping.†</li><li><code>RKMilGeneral(;interpretation=:Ito, ii_approx=IILevyArea()</code> - An explicit Runge-Kutta discretization of the strong order 1.0 Milstein method for general non-commutative noise problems. Allows for a choice of interpretation between <code>:Ito</code> and <code>:Stratonovich</code>. Allows for a choice of iterated integral approximation.</li><li><code>WangLi3SMil_A</code> - fixed step-size explicit 3-stage Milstein methods for Ito problem with strong and weak order 1.0</li><li><code>WangLi3SMil_B</code> - fixed step-size explicit 3-stage Milstein methods for Ito problem with strong and weak order 1.0</li><li><code>WangLi3SMil_C</code> - fixed step-size explicit 3-stage Milstein methods for Ito problem with strong and weak order 1.0</li><li><code>WangLi3SMil_D</code> - fixed step-size explicit 3-stage Milstein methods for Ito problem with strong and weak order 1.0</li><li><code>WangLi3SMil_E</code> - fixed step-size explicit 3-stage Milstein methods for Ito problem with strong and weak order 1.0</li><li><code>WangLi3SMil_F</code> - fixed step-size explicit 3-stage Milstein methods for Ito problem with strong and weak order 1.0</li><li><code>SRA</code> - Adaptive strong order 1.5 methods for additive Ito and Stratonovich SDEs. Default tableau is for SRA1. Can handle diagonal, non-diagonal and scalar additive noise.</li><li><code>SRI</code> - Adaptive strong order 1.5 methods for diagonal/scalar Ito SDEs. Default tableau is for SRIW1.</li><li><code>SRIW1</code> - Adaptive strong order 1.5 and weak order 2.0 for diagonal/scalar Ito SDEs.†</li><li><code>SRIW2</code> - Adaptive strong order 1.5 and weak order 3.0 for diagonal/scalar Ito SDEs.†</li><li><code>SOSRI</code> - Stability-optimized adaptive strong order 1.5 and weak order 2.0 for diagonal/scalar Ito SDEs. Stable at high tolerances and robust to stiffness.†</li><li><code>SOSRI2</code> - Stability-optimized adaptive strong order 1.5 and weak order 2.0 for diagonal/scalar Ito SDEs. Stable at high tolerances and robust to stiffness.†</li><li><code>SRA1</code> - Adaptive strong order 1.5 for additive Ito and Stratonovich SDEs with weak order 2. Can handle diagonal, non-diagonal, and scalar additive noise.†</li><li><code>SRA2</code> - Adaptive strong order 1.5 for additive Ito and Stratonovich SDEs with weak order 2. Can handle diagonal, non-diagonal, and scalar additive noise.†</li><li><code>SRA3</code> - Adaptive strong order 1.5 for additive Ito and Stratonovich SDEs with weak order 3. Can handle non-diagonal and scalar additive noise.†</li><li><code>SOSRA</code> - A stability-optimized adaptive SRA. Strong order 1.5 for additive Ito and Stratonovich SDEs with weak order 2. Can handle diagonal, non-diagonal, and scalar additive noise. Stable at high tolerances and robust to stiffness.†</li><li><code>SOSRA2</code> - A stability-optimized adaptive SRA. Strong order 1.5 for additive Ito and Stratonovich SDEs with weak order 2. Can handle diagonal, non-diagonal, and scalar additive noise. Stable at high tolerances and robust to stiffness.†</li></ul><p>Example usage:</p><pre><code class="language-julia hljs">sol = solve(prob, SRIW1())</code></pre><p>3-stage Milstein Methods <code>WangLi3SMil_A</code>, <code>WangLi3SMil_B</code>, <code>WangLi3SMil_D</code>, <code>WangLi3SMil_E</code> and <code>WangLi3SMil_F</code> are currently implemented for 1-dimensional and diagonal noise only.</p><h4 id="Tableau-Controls"><a class="docs-heading-anchor" href="#Tableau-Controls">Tableau Controls</a><a id="Tableau-Controls-1"></a><a class="docs-heading-anchor-permalink" href="#Tableau-Controls" title="Permalink"></a></h4><p>For <code>SRA</code> and <code>SRI</code>, the following option is allowed:</p><ul><li><code>tableau</code>: The tableau for an <code>:SRA</code> or <code>:SRI</code> algorithm. Defaults to SRIW1 or SRA1.</li></ul><h4 id="S-ROCK-Methods"><a class="docs-heading-anchor" href="#S-ROCK-Methods">S-ROCK Methods</a><a id="S-ROCK-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#S-ROCK-Methods" title="Permalink"></a></h4><ul><li><code>SROCK1</code> - is a fixed step size stabilized explicit method for stiff problems. Defaults to solving the Ito problem but <code>SROCK1(interpretation=:Stratonovich)</code> can make it solve the Stratonovich problem. Strong order of convergence is 0.5 and weak order 1, but is optimized to get order 1 in case of scalar/diagonal noise.</li><li><code>SROCKEM</code> - is fixed step Euler-Mayurama with first order ROCK stabilization, and can thus handle stiff problems. Only for Ito problems. Defaults to strong and weak order 1.0, but can solve with weak order 0.5 as <code>SROCKEM(strong_order_1=false)</code>. This method can handle 1-dimensional, diagonal and non-diagonal noise.</li><li><code>SROCK2</code> - is a weak second order and strong first order fixed step stabilized method for stiff Ito problems. This method can handle 1-dimensional, diagonal and non-diagonal noise.</li><li><code>SKSROCK</code> - is fixed step stabilized explicit method for stiff Ito problems. Strong order 0.5 and weak order 1. This method has a better stability domain then <code>SROCK1</code>. Also, it allows special post-processing techniques in case of ergodic dynamical systems, in the context of ergodic Brownian dynamics, to achieve order 2 accuracy. <code>SKSROCK(;post_processing=true)</code> will make use of post-processing. By default, it doesn&#39;t use post-processing. Post-processing is optional and under development. The rest of the method is completely functional and can handle 1-dimensional, diagonal and non-diagonal noise.</li><li><code>TangXiaoSROCK2</code> - is a fixed step size stabilized explicit method for stiff problems. Only for Ito problems. Weak order of 2 and strong order of 1. Has 5 versions with different stability domains which can be used as <code>TangXiaoSROCK2(version_num=i)</code> where <code>i</code> is 1-5. Under Development.</li></ul><h4 id="Stiff-Methods"><a class="docs-heading-anchor" href="#Stiff-Methods">Stiff Methods</a><a id="Stiff-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Stiff-Methods" title="Permalink"></a></h4><ul><li><code>ImplicitEM</code> - An order 0.5 Ito drift-implicit method. This is a theta method which defaults to <code>theta=1</code> or the Trapezoid method on the drift term. This method defaults to <code>symplectic=false</code>, but when true and <code>theta=1/2</code> this is the implicit Midpoint method on the drift term and is symplectic in distribution. Can handle all forms of noise, including non-diagonal, scalar, and colored noise. Uses a 1.0/1.5 heuristic for adaptive time stepping.</li><li><code>STrapezoid</code> - An alias for <code>ImplicitEM</code> with <code>theta=1/2</code></li><li><code>SImplicitMidpoint</code> - An alias for <code>ImplicitEM</code> with <code>theta=1/2</code> and <code>symplectic=true</code></li><li><code>ImplicitEulerHeun</code> - An order 0.5 Stratonovich drift-implicit method. This is a theta method which defaults to <code>theta=1/2</code> or the Trapezoid method on the drift term. This method defaults to <code>symplectic=false</code>, but when true and <code>theta=1</code> this is the implicit Midpoint method on the drift term and is symplectic in distribution. Can handle all forms of noise, including non-diagonal, scalar, and colored noise. Uses a 1.0/1.5 heuristic for adaptive time stepping.</li><li><code>ImplicitRKMil</code> - An order 1.0 drift-implicit method. This is a theta method which defaults to <code>theta=1</code> or the Trapezoid method on the drift term. Defaults to solving the Ito problem, but <code>ImplicitRKMil(interpretation=:Stratonovich)</code> makes it solve the Stratonovich problem. This method defaults to <code>symplectic=false</code>, but when true and <code>theta=1/2</code> this is the implicit Midpoint method on the drift term and is symplectic in distribution. Handles diagonal and scalar noise. Uses a 1.5/2.0 heuristic for adaptive time stepping.</li><li><code>ISSEM</code> - An order 0.5 split-step Ito implicit method. It is fully implicit, meaning it can handle stiffness in the noise term. This is a theta method which defaults to <code>theta=1</code> or the Trapezoid method on the drift term. This method defaults to <code>symplectic=false</code>, but when true and <code>theta=1/2</code> this is the implicit Midpoint method on the drift term and is symplectic in distribution. Can handle all forms of noise, including non-diagonal, scalar, and colored noise. Uses a 1.0/1.5 heuristic for adaptive time stepping.</li><li><code>ISSEulerHeun</code> - An order 0.5 split-step Stratonovich implicit method. It is fully implicit, meaning it can handle stiffness in the noise term. This is a theta method which defaults to <code>theta=1</code> or the Trapezoid method on the drift term. This method defaults to <code>symplectic=false</code>, but when true and <code>theta=1/2</code> this is the implicit Midpoint method on the drift term and is symplectic in distribution. Can handle all forms of noise, including non-diagonal,Q scalar, and colored noise. Uses a 1.0/1.5 heuristic for adaptive time stepping.</li><li><code>SKenCarp</code> - Adaptive L-stable drift-implicit strong order 1.5 for additive Ito and Stratonovich SDEs with weak order 2. Can handle diagonal, non-diagonal and scalar additive noise.*†</li></ul><h4 id="Derivative-Based-Methods"><a class="docs-heading-anchor" href="#Derivative-Based-Methods">Derivative-Based Methods</a><a id="Derivative-Based-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Derivative-Based-Methods" title="Permalink"></a></h4><p>The following methods require analytic derivatives of the diffusion term.</p><ul><li><code>PCEuler</code> - The predictor corrector Euler method. Strong Order 0.5 in the Ito sense. Requires the ggprime function, which is defined as<p class="math-container">\[  \text{ggprime}^k(t,x) = \sum_{j=1}^m \sum_{i=1}^d g_{i,j}(t,x) \frac{\partial g_{k,j}(t,x)}{\partial x_i}.\]</p>This can also be understood more intuitively in vector/matrix form as,<p class="math-container">\[\text{ggprime}(t,x) = \sum_{j=1}^m \bar{\mathcal{J}}[\vec g^{(j)}(t,x)] \vec g^{(j)}(t,x).\]</p>where <span>$\vec g^{(j)}$</span> is the noise vector for the j&#39;th noise channel and <span>$\bar{\mathcal{J}}$</span> is the Jacobian of the j&#39;th   noise vector.The default settings for the drift implicitness are <code>theta=0.5</code> and the diffusion implicitness is <code>eta=0.5</code>.</li></ul><h4 id="High-Weak-Order-Methods"><a class="docs-heading-anchor" href="#High-Weak-Order-Methods">High Weak Order Methods</a><a id="High-Weak-Order-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#High-Weak-Order-Methods" title="Permalink"></a></h4><p>Note that none of the following methods are adaptive.</p><ul><li><code>SimplifiedEM</code> - A simplified Euler-Maruyama method with weak order 1.0 and fixed step size. Can handle all forms of noise, including non-diagonal, scalar, and colored noise.†</li><li><code>DRI1</code> - Adaptive step weak order 2.0 for Ito SDEs with minimized error constants (deterministic order 3). Can handle diagonal, non-diagonal, non-commuting, and scalar additive noise.†</li><li><code>DRI1NM</code> - Adaptive step weak order 2.0 for Ito SDEs with minimized error constants (deterministic order 3). Can handle non-mixing diagonal (i.e., du[k] = f(u[k])) and scalar additive noise.†</li><li><code>RI1</code> - Adaptive step weak order 2.0 for Ito SDEs (deterministic order 3). Can handle diagonal, non-diagonal, non-commuting, and scalar additive noise.†</li><li><code>RI3</code> - Adaptive step weak order 2.0 for Ito SDEs (deterministic order 3). Can handle diagonal, non-diagonal, non-commuting, and scalar additive noise.†</li><li><code>RI5</code> - Adaptive step weak order 2.0 for Ito SDEs (deterministic order 3). Can handle diagonal, non-diagonal, non-commuting, and scalar additive noise.†</li><li><code>RI6</code> - Adaptive step weak order 2.0 for Ito SDEs (deterministic order 2). Can handle diagonal, non-diagonal, non-commuting, and scalar additive noise.†</li><li><code>RDI1WM</code> - Fixed step weak order 1.0 for Ito SDEs (deterministic order 2). Can handle diagonal, non-diagonal, non-commuting, and scalar additive noise.†</li><li><code>RDI2WM</code> - Adaptive step weak order 2.0 for Ito SDEs (deterministic order 2). Can handle diagonal, non-diagonal, non-commuting, and scalar additive noise.†</li><li><code>RDI3WM</code> - Adaptive step weak order 2.0 for Ito SDEs (deterministic order 3). Can handle diagonal, non-diagonal, non-commuting, and scalar additive noise.†</li><li><code>RDI4WM</code> - Adaptive step weak order 2.0 for Ito SDEs (deterministic order 3). Can handle diagonal, non-diagonal, non-commuting, and scalar additive noise.†</li><li><code>RS1</code> - Fixed step weak order 2.0 for Stratonovich SDEs (deterministic order 2). Can handle diagonal, non-diagonal, non-commuting, and scalar additive noise.†</li><li><code>RS2</code> - Fixed step weak order 2.0 for Stratonovich SDEs (deterministic order 3). Can handle diagonal, non-diagonal, non-commuting, and scalar additive noise.†</li><li><code>PL1WM</code> - Fixed step weak order 2.0 for Ito SDEs (deterministic order 2). Can handle diagonal, non-diagonal, non-commuting, and scalar additive noise.†</li><li><code>PL1WMA</code> - Fixed step weak order 2.0 for Ito SDEs (deterministic order 2). Can handle additive noise.†</li><li><code>NON</code> - Fixed step weak order 2.0 for Stratonovich SDEs (deterministic order 4). Can handle diagonal, non-diagonal, non-commuting, and scalar additive noise.†</li><li><code>SIEA</code> - Fixed step weak order 2.0 for Ito SDEs (deterministic order 2). Can handle diagonal and scalar additive noise.†  Stochastic generalization of the improved Euler method.</li><li><code>SIEB</code> - Fixed step weak order 2.0 for Ito SDEs (deterministic order 2). Can handle diagonal and scalar additive noise.†  Stochastic generalization of the improved Euler method.</li><li><code>SMEA</code> - Fixed step weak order 2.0 for Ito SDEs (deterministic order 2). Can handle diagonal and scalar additive noise.†  Stochastic generalization of the modified Euler method.</li><li><code>SMEB</code> - Fixed step weak order 2.0 for Ito SDEs (deterministic order 2). Can handle diagonal and scalar additive noise.†  Stochastic generalization of the modified Euler method.</li></ul><h3 id="StochasticCompositeAlgorithm"><a class="docs-heading-anchor" href="#StochasticCompositeAlgorithm">StochasticCompositeAlgorithm</a><a id="StochasticCompositeAlgorithm-1"></a><a class="docs-heading-anchor-permalink" href="#StochasticCompositeAlgorithm" title="Permalink"></a></h3><p>One unique feature of StochasticDiffEq.jl is the <code>StochasticCompositeAlgorithm</code>, which allows you to, with very minimal overhead, design a multimethod which switches between chosen algorithms as needed. The syntax is <code>StochasticCompositeAlgorithm(algtup,choice_function)</code> where <code>algtup</code> is a tuple of StochasticDiffEq.jl algorithms, and <code>choice_function</code> is a function which declares which method to use in the following step. For example, we can design a multimethod which uses <code>EM()</code> but switches to <code>RKMil()</code> whenever <code>dt</code> is too small:</p><pre><code class="language-julia hljs">choice_function(integrator) = (Int(integrator.dt &lt; 0.001) + 1)
alg_switch = StochasticCompositeAlgorithm((EM(), RKMil()), choice_function)</code></pre><p>The <code>choice_function</code> takes in an <code>integrator</code> and thus all the features available in the <a href="../../basics/integrator/#integrator">Integrator Interface</a> can be used in the choice function.</p><h3 id="SimpleDiffEq.jl"><a class="docs-heading-anchor" href="#SimpleDiffEq.jl">SimpleDiffEq.jl</a><a id="SimpleDiffEq.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SimpleDiffEq.jl" title="Permalink"></a></h3><p>This setup provides access to simplified versions of a few SDE solvers. They mostly exist for experimentation, but offer shorter compile times. They have limitations compared to StochasticDiffEq.jl.</p><ul><li><code>SimpleEM</code> - A fixed timestep solve method for Euler-Maruyama. Only works with non-colored Gaussian noise.</li></ul><p>Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use SimpleDiffEq.jl:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;SimpleDiffEq&quot;)
using SimpleDiffEq</code></pre><h3 id="BridgeDiffEq.jl"><a class="docs-heading-anchor" href="#BridgeDiffEq.jl">BridgeDiffEq.jl</a><a id="BridgeDiffEq.jl-1"></a><a class="docs-heading-anchor-permalink" href="#BridgeDiffEq.jl" title="Permalink"></a></h3><p>Bridge.jl is a set of fixed timestep algorithms written in Julia. These methods are made and optimized for out-of-place functions on immutable (static vector) types. Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use BridgeDiffEq.jl:</p><pre><code class="language-julia hljs">Pkg.clone(&quot;https://github.com/SciML/BridgeDiffEq.jl&quot;)
using BridgeDiffEq</code></pre><ul><li><code>BridgeEuler</code> - Strong order 0.5 Euler-Maruyama method for Ito equations.†</li><li><code>BridgeHeun</code> - Strong order 0.5 Euler-Heun method for Stratonovich equations.†</li><li><code>BridgeSRK</code> - Strong order 1.0 derivative-free stochastic Runge-Kutta method for scalar (<code>&lt;:Number</code>) Ito equations.†</li></ul><h5 id="Notes"><a class="docs-heading-anchor" href="#Notes">Notes</a><a id="Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Notes" title="Permalink"></a></h5><p>†: Does not step to the interval endpoint. This can cause issues with discontinuity detection, and <a href="../../features/diffeq_arrays/#diffeq_arrays">discrete variables need to be updated appropriately</a>.</p><p>*:  Note that although <code>SKenCarp</code> uses the same table as <code>KenCarp3</code>, solving a ODE problem using <code>SKenCarp</code> by setting <code>g(du,u,p,t) = du .= 0</code> will take much more steps than <code>KenCarp3</code> because error estimator of <code>SKenCarp</code> is different (because of noise terms) and default value of <code>qmax</code> (maximum permissible ratio of relaxing/tightening <code>dt</code> for adaptive steps) is smaller for StochasticDiffEq algorithms.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../bvp_solve/">« BVP Solvers</a><a class="docs-footer-nextpage" href="../sdae_solve/">SDAE Solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 6 May 2023 01:02">Saturday 6 May 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
