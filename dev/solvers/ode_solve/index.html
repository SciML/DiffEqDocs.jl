<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ODE Solvers · DifferentialEquations.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://diffeq.sciml.ai/stable/solvers/ode_solve/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DifferentialEquations.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">DifferentialEquations.jl: Scientific Machine Learning (SciML) Enabled Simulation and Estimation</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/ode_example/">Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/faster_ode_example/">Code Optimization for Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/advanced_ode_example/">Solving Large Stiff Equations</a></li><li><a class="tocitem" href="../../tutorials/sde_example/">Stochastic Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/rode_example/">Random Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dde_example/">Delay Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dae_example/">Differential Algebraic Equations</a></li><li><a class="tocitem" href="../../tutorials/discrete_stochastic_example/">Continuous-Time Jump Processes and Gillespie Methods</a></li><li><a class="tocitem" href="../../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="tocitem" href="../../tutorials/bvp_example/">Boundary Value Problems</a></li><li><a class="tocitem" href="../../tutorials/additional/">Additional Tutorials</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../basics/common_solver_opts/">Common Solver Options</a></li><li><a class="tocitem" href="../../basics/solution/">Solution Handling</a></li><li><a class="tocitem" href="../../basics/plot/">Plot Functions</a></li><li><a class="tocitem" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="tocitem" href="../../basics/problem/">Problem Interface</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="tocitem">Problem Types</span><ul><li><a class="tocitem" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="tocitem" href="../../types/ode_types/">ODE Problems</a></li><li><a class="tocitem" href="../../types/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group Problems</a></li><li><a class="tocitem" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="tocitem" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="tocitem" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="tocitem" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="tocitem" href="../../types/sde_types/">SDE Problems</a></li><li><a class="tocitem" href="../../types/sdae_types/">SDAE Problems</a></li><li><a class="tocitem" href="../../types/rode_types/">RODE Problems</a></li><li><a class="tocitem" href="../../types/dde_types/">DDE Problems</a></li><li><a class="tocitem" href="../../types/sdde_types/">SDDE Problems</a></li><li><a class="tocitem" href="../../types/dae_types/">DAE Problems</a></li><li><a class="tocitem" href="../../types/jump_types/">Jump Problems</a></li></ul></li><li><span class="tocitem">Solver Algorithms</span><ul><li><a class="tocitem" href="../discrete_solve/">Discrete Solvers</a></li><li class="is-active"><a class="tocitem" href>ODE Solvers</a><ul class="internal"><li><a class="tocitem" href="#Recommended-Methods"><span>Recommended Methods</span></a></li><li><a class="tocitem" href="#Translations-from-MATLAB/Python/R"><span>Translations from MATLAB/Python/R</span></a></li><li><a class="tocitem" href="#Full-List-of-Methods"><span>Full List of Methods</span></a></li></ul></li><li><a class="tocitem" href="../nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group ODE Solvers</a></li><li><a class="tocitem" href="../dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="tocitem" href="../split_ode_solve/">Split ODE Solvers</a></li><li><a class="tocitem" href="../steady_state_solve/">Steady State Solvers</a></li><li><a class="tocitem" href="../bvp_solve/">BVP Solvers</a></li><li><a class="tocitem" href="../jump_solve/">Jump Problem and Jump Diffusion Solvers</a></li><li><a class="tocitem" href="../sde_solve/">SDE Solvers</a></li><li><a class="tocitem" href="../sdae_solve/">SDAE Solvers</a></li><li><a class="tocitem" href="../rode_solve/">RODE Solvers</a></li><li><a class="tocitem" href="../dde_solve/">DDE Solvers</a></li><li><a class="tocitem" href="../sdde_solve/">SDDE Solvers</a></li><li><a class="tocitem" href="../dae_solve/">DAE Solvers</a></li><li><a class="tocitem" href="../benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="tocitem">Additional Features</span><ul><li><a class="tocitem" href="../../features/performance_overloads/">Jacobians, Gradients, etc.</a></li><li><a class="tocitem" href="../../features/diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="tocitem" href="../../features/diffeq_operator/">DiffEqOperators</a></li><li><a class="tocitem" href="../../features/noise_process/">Noise Processes</a></li><li><a class="tocitem" href="../../features/linear_nonlinear/">Specifying (Non)Linear Solvers and Preconditioners</a></li><li><a class="tocitem" href="../../features/callback_functions/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../features/callback_library/">Callback Library</a></li><li><a class="tocitem" href="../../features/ensemble/">Parallel Ensemble Simulations</a></li><li><a class="tocitem" href="../../features/io/">I/O: Saving and Loading Solution Data</a></li><li><a class="tocitem" href="../../features/low_dep/">Low Dependency Usage</a></li><li><a class="tocitem" href="../../features/progress_bar/">Progress Bar Integration</a></li></ul></li><li><span class="tocitem">Analysis Tools</span><ul><li><a class="tocitem" href="../../analysis/parameterized_functions/">ParameterizedFunctions</a></li><li><a class="tocitem" href="../../analysis/parameter_estimation/">Parameter Estimation and Bayesian Analysis</a></li><li><a class="tocitem" href="../../analysis/bifurcation/">Bifurcation Analysis</a></li><li><a class="tocitem" href="../../analysis/sensitivity/">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li><a class="tocitem" href="../../analysis/global_sensitivity/">Global Sensitivity Analysis</a></li><li><a class="tocitem" href="../../analysis/uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="tocitem" href="../../analysis/neural_networks/">Neural Networks</a></li><li><a class="tocitem" href="../../analysis/dev_and_test/">Algorithm Development and Testing</a></li></ul></li><li><span class="tocitem">Domain Modeling Tools</span><ul><li><a class="tocitem" href="../../models/multiscale/">Multi-Scale Models</a></li><li><a class="tocitem" href="../../models/physical/">Physical Models</a></li><li><a class="tocitem" href="../../models/financial/">Financial Models</a></li><li><a class="tocitem" href="../../models/chemical_reactions/">Chemical Reactions</a></li><li><a class="tocitem" href="../../models/external_modeling/">External Modeling Packages</a></li></ul></li><li><span class="tocitem">Extra Details</span><ul><li><a class="tocitem" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li><li><a class="tocitem" href="../../extras/sensitivity_math/">Mathematics of Sensitivity Analysis</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solver Algorithms</a></li><li class="is-active"><a href>ODE Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ODE Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/DiffEqDocs.jl/blob/master/docs/src/solvers/ode_solve.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ode_solve"><a class="docs-heading-anchor" href="#ode_solve">ODE Solvers</a><a id="ode_solve-1"></a><a class="docs-heading-anchor-permalink" href="#ode_solve" title="Permalink"></a></h1><p><code>solve(prob::ODEProblem,alg;kwargs)</code></p><p>Solves the ODE defined by <code>prob</code> using the algorithm <code>alg</code>. If no algorithm is given, a default algorithm will be chosen.</p><h2 id="Recommended-Methods"><a class="docs-heading-anchor" href="#Recommended-Methods">Recommended Methods</a><a id="Recommended-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Recommended-Methods" title="Permalink"></a></h2><p>It is suggested that you try choosing an algorithm using the <code>alg_hints</code> keyword argument. However, in some cases you may want something specific, or you may just be curious. This guide is to help you choose the right algorithm.</p><h3 id="Unknown-Stiffness-Problems"><a class="docs-heading-anchor" href="#Unknown-Stiffness-Problems">Unknown Stiffness Problems</a><a id="Unknown-Stiffness-Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Unknown-Stiffness-Problems" title="Permalink"></a></h3><p>When the stiffness of the problem is unknown, it is recommended you use a stiffness detection and auto-switching algorithm. These methods are multi-paradigm and allow for efficient solution of both stiff and non-stiff problems. The cost for auto-switching is very minimal but the choices are restrained and so they are a good go-to method when applicable.</p><p>For default tolerances, <code>AutoTsit5(Rosenbrock23())</code> is a good choice. For lower tolerances, using <code>AutoVern7</code> or <code>AutoVern9</code> with <code>Rodas4</code>, <code>KenCarp4</code>, or <code>Rodas5</code> can all be good choices depending on the problem. For very large systems (<code>&gt;1000 ODEs?</code>), consider using <code>lsoda</code>.</p><h3 id="Non-Stiff-Problems"><a class="docs-heading-anchor" href="#Non-Stiff-Problems">Non-Stiff Problems</a><a id="Non-Stiff-Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Stiff-Problems" title="Permalink"></a></h3><p>For non-stiff problems, the native OrdinaryDiffEq.jl algorithms are vastly more efficient than the other choices. For most non-stiff problems, we recommend <code>Tsit5</code>. When more robust error control is required, <code>BS5</code> is a good choice. If at moderate tolerances and the interpolation error is very important, consider the <code>OwrenZen5</code> method. For fast solving at higher tolerances, we recommend <code>BS3</code> (or <code>OwrenZen3</code> if the interpolation error is important). For high accuracy but with the range of <code>Float64</code> (<code>~1e-8-1e-12</code>), we recommend <code>Vern6</code>, <code>Vern7</code>, or <code>Vern8</code> as efficient choices.</p><p>For high accuracy non-stiff solving (<code>BigFloat</code> and tolerances like <code>&lt;1e-12</code>), we recommend the <code>Vern9</code> method. If a high-order method is needed with a high order interpolant, then you should choose <code>Vern9</code> which is Order 9 with an Order 9 interpolant. If you need extremely high accuracy (<code>&lt;1e-30</code>?) and do not need an interpolant, try the <code>Feagin12</code> or <code>Feagin14</code> methods. Note that the Feagin methods are the only high-order optimized methods which do not include a high-order interpolant (they do include a 3rd order Hermite interpolation if needed). Note that these high order RK methods are more robust than the high order Adams-Bashforth methods to discontinuities and achieve very high precision, and are much more efficient than the extrapolation methods. However, the <code>VCABM</code> method can be a good choice for high accuracy when the system of equations is very large (<code>&gt;1,000</code> ODEs?), the function calculation is very expensive, or the solution is very smooth.</p><p>If strict error bounds are needed, then adaptive methods with defect controls are required. Defect controls use an error measurement on the interpolating polynomial to make the error estimate better capture the error over the full interval. For medium accuracy calculations, <code>RK4</code> is a good choice.</p><h3 id="Stiff-Problems"><a class="docs-heading-anchor" href="#Stiff-Problems">Stiff Problems</a><a id="Stiff-Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Stiff-Problems" title="Permalink"></a></h3><p>For stiff problems at high tolerances (<code>&gt;1e-2</code>?) it is recommended that you use <code>Rosenbrock23</code> or <code>TRBDF2</code>. These are robust to oscillations and massive stiffness, though are only efficient when low accuracy is needed. <code>Rosenbrock23</code> is more efficient for small systems where re-evaluating and re-factorizing the Jacobian is not too costly, and for sufficiently large systems <code>TRBDF2</code> will be more efficient. <code>QNDF</code> or <code>FBDF</code> can be the most efficient the largest systems or most expensive <code>f</code>.</p><p>At medium tolerances (<code>&gt;1e-8</code>?) it is recommended you use <code>Rodas5</code>, <code>Rodas4P</code> (the former is more efficient but the later is more reliable), <code>Kvaerno5</code>, or <code>KenCarp4</code>. As native DifferentialEquations.jl solvers, many Julia numeric types (such as BigFloats, <a href="https://github.com/JuliaArbTypes/ArbFloats.jl">ArbFloats</a>, or <a href="https://github.com/stevengj/DecFP.jl">DecFP</a>) will work. When the equation is defined via the <code>@ode_def</code> macro, these will be the most efficient.</p><p>For faster solving at low tolerances (<code>&lt;1e-9</code>) but when <code>Vector{Float64}</code> is used, use <code>radau</code>.</p><p>For asymptotically large systems of ODEs (<code>N&gt;1000</code>?) where <code>f</code> is very costly and the complex eigenvalues are minimal (low oscillations), in that case <code>QNDF</code> or <code>FBDF</code> will be the most efficient. <code>QNDF</code> and <code>FBDF</code> will also do surprisingly well if the solution is smooth. However, this method can handle less stiffness than other methods and its Newton iterations may fail at low accuracy situations. Other choices to consider in this regime are <code>CVODE_BDF</code> and <code>lsoda</code>.</p><h4 id="Special-Properties-of-Stiff-Integrators"><a class="docs-heading-anchor" href="#Special-Properties-of-Stiff-Integrators">Special Properties of Stiff Integrators</a><a id="Special-Properties-of-Stiff-Integrators-1"></a><a class="docs-heading-anchor-permalink" href="#Special-Properties-of-Stiff-Integrators" title="Permalink"></a></h4><p><code>ImplicitMidpoint</code> is a symmetric and symplectic integrator. <code>Trapezoid</code> is a symmetric (almost symplectic) integrator with adaptive timestepping. <code>ImplicitEuler</code> is an extension to the common algorithm with adaptive timestepping and efficient quasi-Newton Jacobian re-usage which is fully strong-stability preserving (SSP) for hyperbolic PDEs.</p><p>Notice that <code>Rodas4</code> loses accuracy on discretizations of nonlinear parabolic PDEs, and thus it&#39;s suggested you replace it with <code>Rodas4P</code> in those situations which is 3rd order. <code>ROS3P</code> is only third order and achieves 3rd order on such problems and can thus be more efficient in this case.</p><h2 id="Translations-from-MATLAB/Python/R"><a class="docs-heading-anchor" href="#Translations-from-MATLAB/Python/R">Translations from MATLAB/Python/R</a><a id="Translations-from-MATLAB/Python/R-1"></a><a class="docs-heading-anchor-permalink" href="#Translations-from-MATLAB/Python/R" title="Permalink"></a></h2><p>For users familiar with MATLAB/Python/R, good translations of the standard library methods are as follows:</p><ul><li><code>ode23</code> –&gt; <code>BS3()</code></li><li><code>ode45</code>/<code>dopri5</code> –&gt; <code>DP5()</code>, though in most cases <code>Tsit5()</code> is more efficient</li><li><code>ode23s</code> –&gt; <code>Rosenbrock23()</code>, though in most cases <code>Rodas4()</code> is more efficient</li><li><code>ode113</code> –&gt; <code>VCABM()</code>, though in many cases <code>Vern7()</code> is more efficient</li><li><code>dop853</code> –&gt; <code>DP8()</code>, though in most cases <code>Vern7()</code> is more efficient</li><li><code>ode15s</code>/<code>vode</code> –&gt; <code>QNDF()</code> or <code>FBDF()</code>, though in many cases <code>Rodas4()</code>, <code>KenCarp4()</code>, <code>TRBDF2()</code>, or <code>RadauIIA5()</code> are more efficient</li><li><code>ode23t</code> –&gt; <code>Trapezoid()</code></li><li><code>ode23tb</code> –&gt; <code>TRBDF2()</code></li><li><code>lsoda</code> –&gt; <code>lsoda()</code>, though <code>AutoTsit5(Rosenbrock23())</code> or <code>AutoVern7(Rodas5())</code> may be more efficient. Note that <code>lsoda()</code> requires the LSODA.jl extension, which can be added via <code>]add LSODA; using LSODA</code>.</li><li><code>ode15i</code> –&gt; <code>IDA()</code> or <code>DFBDF()</code>, though in many cases <code>Rodas4()</code> can handle the DAE and is significantly more efficient.</li></ul><h2 id="Full-List-of-Methods"><a class="docs-heading-anchor" href="#Full-List-of-Methods">Full List of Methods</a><a id="Full-List-of-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Full-List-of-Methods" title="Permalink"></a></h2><h3 id="OrdinaryDiffEq.jl-for-Non-Stiff-Equations"><a class="docs-heading-anchor" href="#OrdinaryDiffEq.jl-for-Non-Stiff-Equations">OrdinaryDiffEq.jl for Non-Stiff Equations</a><a id="OrdinaryDiffEq.jl-for-Non-Stiff-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#OrdinaryDiffEq.jl-for-Non-Stiff-Equations" title="Permalink"></a></h3><p>Unless otherwise specified, the OrdinaryDiffEq algorithms all come with a 3rd order Hermite polynomial interpolation. The algorithms denoted as having a &quot;free&quot; interpolation means that no extra steps are required for the interpolation. For the non-free higher order interpolating functions, the extra steps are computed lazily (i.e. not during the solve).</p><p>The OrdinaryDiffEq.jl algorithms achieve the highest performance for non-stiff equations while being the most generic: accepting the most Julia-based types, allow for sophisticated event handling, etc. On stiff ODEs these algorithms again consistently among the top. OrdinaryDiffEq.jl is recommended for most ODE problems.</p><h4 id="Explicit-Runge-Kutta-Methods"><a class="docs-heading-anchor" href="#Explicit-Runge-Kutta-Methods">Explicit Runge-Kutta Methods</a><a id="Explicit-Runge-Kutta-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Explicit-Runge-Kutta-Methods" title="Permalink"></a></h4><ul><li><code>Euler</code>- The canonical forward Euler method. Fixed timestep only.</li><li><code>Midpoint</code> - The second order midpoint method. Uses embedded Euler method for adaptivity.</li><li><code>Heun</code> - The second order Heun&#39;s method. Uses embedded Euler method for adaptivity.</li><li><code>Ralston</code> - The optimized second order midpoint method. Uses embedded Euler. method for adaptivity.</li><li><code>RK4</code> - The canonical Runge-Kutta Order 4 method. Uses a defect control for adaptive stepping using maximum error over the whole interval.</li><li><code>BS3</code> - Bogacki-Shampine 3/2 method.</li><li><code>OwrenZen3</code> - Owren-Zennaro optimized interpolantion 3/2 method (free 3th order interpolant).</li><li><code>OwrenZen4</code> - Owren-Zennaro optimized interpolantion 4/3 method (free 4th order interpolant).</li><li><code>OwrenZen5</code> - Owren-Zennaro optimized interpolantion 5/4 method (free 5th order interpolant).</li><li><code>DP5</code> - Dormand-Prince&#39;s 5/4 Runge-Kutta method. (free 4th order interpolant).</li><li><code>Tsit5</code> - Tsitouras 5/4 Runge-Kutta method. (free 4th order interpolant).</li><li><code>Anas5(w)</code> - 4th order Runge-Kutta method designed for periodic problems. Requires a periodicity estimate <code>w</code> which when accurate the method becomes 5th order (and is otherwise 4th order with less error for better estimates).</li><li><code>FRK65(w=0)</code> - Zero Dissipation Runge-Kutta of 6th order. Takes an optional argument <code>w</code> to for the periodicity phase, in which case this method results in zero numerical dissipation.</li><li><code>PFRK87(w=0)</code> - Phase-fitted Runge-Kutta Runge-Kutta of 8th order. Takes an optional argument <code>w</code> to for the periodicity phase, in which case this method results in zero numerical dissipation.</li><li><code>RKO65</code> - Tsitouras&#39; Runge-Kutta-Oliver 6 stage 5th order method. This method is robust on problems which have a singularity at <code>t=0</code>.</li><li><code>TanYam7</code> - Tanaka-Yamashita 7 Runge-Kutta method.</li><li><code>DP8</code> - Hairer&#39;s 8/5/3 adaption of the Dormand-Prince Runge-Kutta method. (7th order interpolant).</li><li><code>TsitPap8</code> - Tsitouras-Papakostas 8/7 Runge-Kutta method.</li><li><code>Feagin10</code> - Feagin&#39;s 10th-order Runge-Kutta method.</li><li><code>Feagin12</code> - Feagin&#39;s 12th-order Runge-Kutta method.</li><li><code>Feagin14</code> - Feagin&#39;s 14th-order Runge-Kutta method.</li></ul><p>Example usage:</p><pre><code class="language-julia hljs">alg = Tsit5()
solve(prob,alg)</code></pre><p>Additionally, the following algorithms have a lazy interpolant:</p><ul><li><code>BS5</code> - Bogacki-Shampine 5/4 Runge-Kutta method. (lazy 5th order interpolant).</li><li><code>Vern6</code> - Verner&#39;s &quot;Most Efficient&quot; 6/5 Runge-Kutta method. (lazy 6th order interpolant).</li><li><code>Vern7</code> - Verner&#39;s &quot;Most Efficient&quot; 7/6 Runge-Kutta method. (lazy 7th order interpolant).</li><li><code>Vern8</code> - Verner&#39;s &quot;Most Efficient&quot; 8/7 Runge-Kutta method. (lazy 8th order interpolant)</li><li><code>Vern9</code> - Verner&#39;s &quot;Most Efficient&quot; 9/8 Runge-Kutta method. (lazy 9th order interpolant)</li></ul><p>These methods require a few extra steps in order to compute the high order interpolation, but these steps are only taken when the interpolation is used. These methods when lazy assume that the parameter vector <code>p</code> will be unchanged between the moment of the interval solving and the interpolation. If <code>p</code> is changed in a ContinuousCallback, or in a DiscreteCallback and the continuous solution is used after the full solution, then set <code>lazy=false</code>.</p><p>Example:</p><pre><code class="language-julia hljs">solve(prob,Vern7()) # lazy by default
solve(prob,Vern7(lazy=false))</code></pre><h4 id="Parallel-Explicit-Runge-Kutta-Methods"><a class="docs-heading-anchor" href="#Parallel-Explicit-Runge-Kutta-Methods">Parallel Explicit Runge-Kutta Methods</a><a id="Parallel-Explicit-Runge-Kutta-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-Explicit-Runge-Kutta-Methods" title="Permalink"></a></h4><ul><li><code>KuttaPRK2p5</code> - A 5 parallel, 2 processor explicit Runge-Kutta method of 5th order.</li></ul><p>These methods utilize multithreading on the <code>f</code> calls to parallelize the problem. This requires that simultaneous calls to <code>f</code> are thread-safe.</p><h4 id="Explicit-Strong-Stability-Preserving-Runge-Kutta-Methods-for-Hyperbolic-PDEs-(Conservation-Laws)"><a class="docs-heading-anchor" href="#Explicit-Strong-Stability-Preserving-Runge-Kutta-Methods-for-Hyperbolic-PDEs-(Conservation-Laws)">Explicit Strong-Stability Preserving Runge-Kutta Methods for Hyperbolic PDEs (Conservation Laws)</a><a id="Explicit-Strong-Stability-Preserving-Runge-Kutta-Methods-for-Hyperbolic-PDEs-(Conservation-Laws)-1"></a><a class="docs-heading-anchor-permalink" href="#Explicit-Strong-Stability-Preserving-Runge-Kutta-Methods-for-Hyperbolic-PDEs-(Conservation-Laws)" title="Permalink"></a></h4><ul><li><code>SSPRK22</code> - The two-stage, second order strong stability preserving (SSP) method of Shu and Osher (SSP coefficient 1, free 2nd order SSP interpolant). Fixed timestep only.</li><li><code>SSPRK33</code> - The three-stage, third order strong stability preserving (SSP) method of Shu and Osher (SSP coefficient 1, free 2nd order SSP interpolant). Fixed timestep only.</li><li><code>SSPRK53</code> - The five-stage, third order strong stability preserving (SSP) method of Ruuth (SSP coefficient 2.65, free 3rd order Hermite interpolant). Fixed timestep only.</li><li><code>SSPRK63</code> - The six-stage, third order strong stability preserving (SSP) method of Ruuth (SSP coefficient 3.518, free 3rd order Hermite interpolant). Fixed timestep only.</li><li><code>SSPRK73</code> - The seven-stage, third order strong stability preserving (SSP) method of Ruuth (SSP coefficient 4.2879, free 3rd order Hermite interpolant). Fixed timestep only.</li><li><code>SSPRK83</code> - The eight-stage, third order strong stability preserving (SSP) method of Ruuth (SSP coefficient 5.107, free 3rd order Hermite interpolant). Fixed timestep only.</li><li><code>SSPRK432</code> - A  3/2 adaptive strong stability preserving (SSP) method with five stages (SSP coefficient 2, free 2nd order SSP interpolant).</li><li><code>SSPRK43</code> - A  3/2 adaptive strong stability preserving (SSP) method with five stages (SSP coefficient 2, free 2nd order SSP interpolant). The main method is the same as <code>SSPRK432</code>, but the embedded method has a larger stability region.</li><li><code>SSPRK932</code> - A  3/2 adaptive strong stability preserving (SSP) method with nine stages (SSP coefficient 6, free 3rd order Hermite interpolant).</li><li><code>SSPRK54</code> - The five-stage, fourth order strong stability preserving (SSP) method of Spiteri and Ruuth (SSP coefficient 1.508, 3rd order Hermite interpolant). Fixed timestep only.</li><li><code>SSPRK104</code> - The ten-stage, fourth order strong stability preserving method of Ketcheson (SSP coefficient 6, free 3rd order Hermite interpolant). Fixed timestep only.</li><li><code>SSPRKMSVS32</code> - 3-stage, 2nd order SSP-optimal linear multistep method. (SSP coefficent 0.5, 3rd order Hermite interpolant). Fixed timestep only.</li><li><code>SSPRKMSVS43</code> - 4-stage, 3rd order SSP-optimal linear multistep method. (SSP coefficent 0.33, 3rd order Hermite interpolant). Fixed timestep only.</li></ul><p>The SSP coefficients of the methods can be queried as <code>ssp_coefficient(alg)</code>. All explicit SSP methods take two optional arguments <code>SSPXY(stage_limiter!, step_limiter!)</code>, where <code>stage_limiter!</code> and <code>step_limiter</code> are functions taking arguments of the form <code>limiter!(u, integrator, p, t)</code>. Here, <code>u</code> is the new solution value (updated inplace) after an explicit Euler stage / the whole time step , <code>integrator</code> the ODE integrator, and <code>t</code> the current time. These limiters can be used to enforce physical constraints, e.g. the positivity preserving limiters of Zhang and Shu (Zhang, Xiangxiong, and Chi-Wang Shu. &quot;Maximum-principle-satisfying and positivity-preserving high-order schemes for conservation laws: survey and new developments.&quot; Proceedings of the Royal Society of London A: Mathematical, Physical and Engineering Sciences. The Royal Society, 2011.).</p><h4 id="Low-Storage-Methods"><a class="docs-heading-anchor" href="#Low-Storage-Methods">Low-Storage Methods</a><a id="Low-Storage-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Low-Storage-Methods" title="Permalink"></a></h4><ul><li><code>ORK256</code> - 5-stage, second order low-storage method for wave propogation equations. Fixed timestep only. Like SSPRK methods, ORK256 also takes optional arguments <code>stage_limiter!</code>, <code>step_limiter!</code>, where <code>stage_limiter!</code> and <code>step_limiter!</code> are functions of the form <code>limiter!(u, integrator, p, t)</code>.</li><li><code>SSPRK53_2N1</code> and <code>SSPRK53_2N2</code> - 5-stage, third order low-storage methods with large SSP coefficients. (SSP coefficient 2.18 and 2.15, free 3rd order Hermite interpolant). Fixed timestep only.</li><li><code>CarpenterKennedy2N54</code> - The five-stage, fourth order low-storage method of Carpenter and Kennedy (free 3rd order Hermite interpolant). Fixed timestep only. Designed for hyperbolic PDEs (stability properties). Like SSPRK methods, <code>CarpenterKennedy2N54</code> also takes optional arguments <code>stage_limiter!</code>, <code>step_limiter!</code>.</li><li><code>NDBLSRK124</code> - 12-stage, fourth order low-storage method with optimized stability regions for advection-dominated problems. Fixed timestep only. Like SSPRK methods, <code>NDBLSRK124</code> also takes optional arguments <code>stage_limiter!</code>, <code>step_limiter!</code>.</li><li><code>NDBLSRK134</code> - 13-stage, fourth order low-storage method with optimized stability regions for advection-dominated problems. Fixed timestep only. Like SSPRK methods, <code>NDBLSRK134</code> also takes optional arguments <code>stage_limiter!</code>, <code>step_limiter!</code>.</li><li><code>NDBLSRK144</code> - 14-stage, fourth order low-storage method with optimized stability regions for advection-dominated problems. Fixed timestep only.  Like SSPRK methods, <code>NDBLSRK144</code> also takes optional arguments <code>stage_limiter!</code>, <code>step_limiter!</code>.</li><li><code>CFRLDDRK64</code> - 6-stage, fourth order low-storage, low-dissipation, low-dispersion scheme. Fixed timestep only.</li><li><code>TSLDDRK74</code> - 7-stage, fourth order low-storage low-dissipation, low-dispersion scheme with maximal accuracy and stability limit along the imaginary axes. Fixed timestep only.</li><li><code>DGLDDRK73_C</code> - 7-stage, third order low-storage low-dissipation, low-dispersion scheme for discontinuous Galerkin space discretizations applied to wave propagation problems, optimized for PDE discretizations when maximum spatial step is small due to geometric features of computational domain. Fixed timestep only. Like SSPRK methods, <code>DGLDDRK73_C</code> also takes optional arguments <code>stage_limiter!</code>, <code>step_limiter!</code>.</li><li><code>DGLDDRK84_C</code> - 8-stage, fourth order low-storage low-dissipation, low-dispersion scheme for discontinuous Galerkin space discretizations applied to wave propagation problems, optimized for PDE discretizations when maximum spatial step is small due to geometric features of computational domain. Fixed timestep only. Like SSPRK methods, <code>DGLDDRK84_C</code> also takes optional arguments <code>stage_limiter!</code>, <code>step_limiter!</code>.</li><li><code>DGLDDRK84_F</code> - 8-stage, fourth order low-storage low-dissipation, low-dispersion scheme for discontinuous Galerkin space discretizations applied to wave propagation problems, optimized for PDE discretizations when the maximum spatial step size is not constrained. Fixed timestep only. Like SSPRK methods, <code>DGLDDRK84_F</code> also takes optional arguments <code>stage_limiter!</code>, <code>step_limiter!</code>.</li><li><code>SHLDDRK64</code> - 6-stage, fourth order low-stage, low-dissipation, low-dispersion scheme. Fixed timestep only. Like SSPRK methods, SHLDDRK64 also takes optional arguments <code>stage_limiter!</code>, <code>step_limiter!</code>.</li><li><code>RK46NL</code> - 6-stage, fourth order low-stage, low-dissipation, low-dispersion scheme. Fixed timestep only.</li><li><code>ParsaniKetchesonDeconinck3S32</code> - 3-stage, second order (3S) low-storage scheme, optimised for for the spectral difference method applied to wave propagation problems.</li><li><code>ParsaniKetchesonDeconinck3S82</code> - 8-stage, second order (3S) low-storage scheme, optimised for for the spectral difference method applied to wave propagation problems.</li><li><code>ParsaniKetchesonDeconinck3S53</code> - 5-stage, third order (3S) low-storage scheme, optimised for for the spectral difference method applied to wave propagation problems.</li><li><code>ParsaniKetchesonDeconinck3S173</code> - 17-stage, third order (3S) low-storage scheme, optimised for for the spectral difference method applied to wave propagation problems.</li><li><code>ParsaniKetchesonDeconinck3S94</code> - 9-stage, fourth order (3S) low-storage scheme, optimised for for the spectral difference method applied to wave propagation problems.</li><li><code>ParsaniKetchesonDeconinck3S184</code> - 18-stage, fourth order (3S) low-storage scheme, optimised for for the spectral difference method applied to wave propagation problems.</li><li><code>ParsaniKetchesonDeconinck3S105</code> - 10-stage, fifth order (3S) low-storage scheme, optimised for for the spectral difference method applied to wave propagation problems.</li><li><code>ParsaniKetchesonDeconinck3S205</code> - 20-stage, fifth order (3S) low-storage scheme, optimised for for the spectral difference method applied to wave propagation problems.</li><li><code>CKLLSRK43_2</code> - 4-stage, third order low-storage scheme, optimised for compressible Navier–Stokes equations..</li><li><code>CKLLSRK54_3C</code> - 5-stage, fourth order low-storage scheme, optimised for compressible Navier–Stokes equations.</li><li><code>CKLLSRK95_4S</code> - 9-stage, fifth order low-storage scheme, optimised for compressible Navier–Stokes equations.</li><li><code>CKLLSRK95_4C</code> - 9-stage, fifth order low-storage scheme, optimised for compressible Navier–Stokes equations.</li><li><code>CKLLSRK95_4M</code> - 9-stage, fifth order low-storage scheme, optimised for compressible Navier–Stokes equations.</li><li><code>CKLLSRK54_3C_3R</code> - 5-stage, fourth order low-storage scheme, optimised for compressible Navier–Stokes equations.</li><li><code>CKLLSRK54_3M_3R</code> - 5-stage, fourth order low-storage scheme, optimised for compressible Navier–Stokes equations.</li><li><code>CKLLSRK54_3N_3R</code> - 5-stage, fourth order low-storage scheme, optimised for compressible Navier–Stokes equations.</li><li><code>CKLLSRK85_4C_3R</code> - 8-stage, fifth order low-storage scheme, optimised for compressible Navier–Stokes equations.</li><li><code>CKLLSRK85_4M_3R</code> - 8-stage, fifth order low-storage scheme, optimised for compressible Navier–Stokes equations.</li><li><code>CKLLSRK85_4P_3R</code> - 8-stage, fifth order low-storage scheme, optimised for compressible Navier–Stokes equations.</li><li><code>CKLLSRK54_3N_4R</code> - 5-stage, fourth order low-storage scheme, optimised for compressible Navier–Stokes equations.</li><li><code>CKLLSRK54_3M_4R</code> - 5-stage, fourth order low-storage scheme, optimised for compressible Navier–Stokes equations.</li><li><code>CKLLSRK65_4M_4R</code> - 6-stage, fifth order low-storage scheme, optimised for compressible Navier–Stokes equations.</li><li><code>CKLLSRK85_4FM_4R</code> - 8-stage, fifth order low-storage scheme, optimised for compressible Navier–Stokes equations.</li><li><code>CKLLSRK75_4M_5R</code> - 7-stage, fifth order low-storage scheme, optimised for compressible Navier–Stokes equations.</li><li><code>RDPK3Sp35</code> - 5-stage, third order low-storage scheme with embedded error estimator, optimized for compressible fluid mechanics. Like SSPRK methods, this method also takes optional arguments <code>stage_limiter!</code> and <code>step_limiter!</code>.</li><li><code>RDPK3SpFSAL35</code> - 5-stage, third order low-storage scheme with embedded error estimator, optimized for compressible fluid mechanics. Like SSPRK methods, this method also takes optional arguments <code>stage_limiter!</code> and <code>step_limiter!</code>.</li><li><code>RDPK3Sp49</code> - 9-stage, fourth order low-storage scheme with embedded error estimator, optimized for compressible fluid mechanics. Like SSPRK methods, this method also takes optional arguments <code>stage_limiter!</code> and <code>step_limiter!</code>.</li><li><code>RDPK3SpFSAL49</code> - 9-stage, fourth order low-storage scheme with embedded error estimator, optimized for compressible fluid mechanics. Like SSPRK methods, this method also takes optional arguments <code>stage_limiter!</code> and <code>step_limiter!</code>.</li><li><code>RDPK3Sp510</code> - 10-stage, fifth order low-storage scheme with embedded error estimator, optimized for compressible fluid mechanics. Like SSPRK methods, this method also takes optional arguments <code>stage_limiter!</code> and <code>step_limiter!</code>.</li><li><code>RDPK3SpFSAL510</code> - 10-stage, fifth order low-storage scheme with embedded error estimator, optimized for compressible fluid mechanics. Like SSPRK methods, this method also takes optional arguments <code>stage_limiter!</code> and <code>step_limiter!</code>.</li></ul><p><strong>NOTE</strong>: All the 2N Methods (<code>ORK256</code>, <code>CarpenterKennedy2N54</code>, <code>NDBLSRK124</code>, <code>NDBLSRK134</code>, <code>NDBLSRK144</code>, <code>DGLDDRK73_C</code>, <code>DGLDDRK84_C</code>, <code>DGLDDRK84_F</code> and <code>SHLDDRK64</code>) work on the basic principle of being able to perform step <code>S1 = S1 + F(S2)</code> in just 2 registers. Certain optimizations have been done to achieve this theoritical limit (when <code>alias_u0</code> is set) but have a limitation that <code>du</code> should always be on the left hand side (assignments only) in the implementation.</p><p>Example - This is an invalid implementation for 2N methods:</p><pre><code class="language-julia hljs">function f(du,u,p,t)
  du[1] = u[1] * u[2]
  du[2] = du[1] * u[2] # du appears on the RHS
end</code></pre><p>If you don&#39;t wish to have the optimization and have to use <code>du</code> on the RHS, please set the keyword argument <code>williamson_condition</code> to <code>false</code> in the algorithm (by default it is set to <code>true</code>). In this case 3 registers worth memory would be needed instead.</p><p>Example :</p><pre><code class="language-julia hljs">alg = CarpenterKennedy2N54(;williamson_condition=false)</code></pre><p>So the above implementation of <code>f</code> becomes valid.</p><h4 id="Parallelized-Explicit-Extrapolation-Methods"><a class="docs-heading-anchor" href="#Parallelized-Explicit-Extrapolation-Methods">Parallelized Explicit Extrapolation Methods</a><a id="Parallelized-Explicit-Extrapolation-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Parallelized-Explicit-Extrapolation-Methods" title="Permalink"></a></h4><p>The following are adaptive order, adaptive step size extrapolation methods:</p><ul><li><code>AitkenNeville</code> - Euler extrapolation using Aitken-Neville with the Romberg Sequence.</li><li><code>ExtrapolationMidpointDeuflhard</code> - Midpoint extrapolation using Barycentric coordinates</li><li><code>ExtrapolationMidpointHairerWanner</code> - Midpoint extrapolation using Barycentric coordinates, following Hairer&#39;s <code>ODEX</code> in the adaptivity behavior.</li></ul><p>These methods have arguments for <code>max_order</code>, <code>min_order</code>, and <code>init_order</code> on the adaptive order algorithm. The <code>sequence_factor</code> denotes which even multiple of sequence to take while evaluating internal discretisations. <code>threading</code> denotes whether to automatically multithread the <code>f</code> evaluations, allowing for a high degree of within-method parallelism. The defaults are:</p><ul><li><code>max_order=10</code></li><li><code>min_order=1</code> except for <code>ExtrapolationMidpointHairerWanner</code> it&#39;s 2.</li><li><code>init_order=5</code></li><li><code>threading=true</code></li><li><code>seqeunce_factor = 2</code></li></ul><p>Additionally, the <code>ExtrapolationMidpointDeuflhard</code> and <code>ExtrapolationMidpointHairerWanner</code> methods have the additional argument:</p><ul><li><code>sequence</code>: the step-number sequences, also called the subdividing</li></ul><p>sequence. Possible values are <code>:harmonic</code>, <code>:romberg</code> or <code>:bulirsch</code>. Default  is <code>:harmonic</code>.</p><p>To override, utilize the keyword arguments. For example:</p><pre><code class="language-julia hljs">alg = ExtrapolationMidpointDeuflhard(max_order=7,min_order=4,init_order=4,sequence=:bulirsch,threading=false)
solve(prob,alg)</code></pre><p>Note that the order that is referred to is the extrapolation order. For <code>AitkenNeville</code> this is the order of the method, for the others an extrapolation order of <code>n</code> gives an order <code>2(n+1)</code> method.</p><h4 id="Explicit-Multistep-Methods"><a class="docs-heading-anchor" href="#Explicit-Multistep-Methods">Explicit Multistep Methods</a><a id="Explicit-Multistep-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Explicit-Multistep-Methods" title="Permalink"></a></h4><p>Methods using the approximation at more than one previous mesh point to determine the approximation at the next point are called multistep methods. These methods tend to be more efficient as the size of the system or the cost of <code>f</code> increases.</p><h4 id="Adams-Bashforth-Explicit-Methods"><a class="docs-heading-anchor" href="#Adams-Bashforth-Explicit-Methods">Adams-Bashforth Explicit Methods</a><a id="Adams-Bashforth-Explicit-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Bashforth-Explicit-Methods" title="Permalink"></a></h4><p>These methods require a choice of <code>dt</code>.</p><ul><li><code>AB3</code> - The 3-step third order multistep method. Ralston&#39;s Second Order Method is used to calculate starting values.</li><li><code>AB4</code> - The 4-step fourth order multistep method. Runge-Kutta method of order 4 is used to calculate starting values.</li><li><code>AB5</code> - The 5-step fifth order multistep method. Runge-Kutta method of order 4 is used to calculate starting values.</li><li><code>ABM32</code> - It is third order method. In <code>ABM32</code>, <code>AB3</code> works as predictor and Adams Moulton 2-steps method works as Corrector. Ralston&#39;s Second Order Method is used to calculate starting values.</li><li><code>ABM43</code> - It is fourth order method. In <code>ABM43</code>, <code>AB4</code> works as predictor and Adams Moulton 3-steps method works as Corrector. Runge-Kutta method of order 4 is used to calculate starting values.</li><li><code>ABM54</code> - It is fifth order method. In <code>ABM54</code>, <code>AB5</code> works as predictor and Adams Moulton 4-steps method works as Corrector. Runge-Kutta method of order 4 is used to calculate starting values.</li></ul><h4 id="Adaptive-step-size-Adams-explicit-Methods"><a class="docs-heading-anchor" href="#Adaptive-step-size-Adams-explicit-Methods">Adaptive step size Adams explicit Methods</a><a id="Adaptive-step-size-Adams-explicit-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-step-size-Adams-explicit-Methods" title="Permalink"></a></h4><ul><li><code>VCAB3</code> - The 3rd order Adams method. Bogacki-Shampine 3/2 method is used to calculate starting values.</li><li><code>VCAB4</code> - The 4th order Adams method. Runge-Kutta 4 is used to calculate starting values.</li><li><code>VCAB5</code> - The 5th order Adams method. Runge-Kutta 4 is used to calculate starting values.</li><li><code>VCABM3</code> - The 3rd order Adams-Moulton method. Bogacki-Shampine 3/2 method is used to calculate starting values.</li><li><code>VCABM4</code> - The 4th order Adams-Moulton method. Runge-Kutta 4 is used to calculate starting values.</li><li><code>VCABM5</code> - The 5th order Adams-Moulton method. Runge-Kutta 4 is used to calculate starting values.</li><li><code>VCABM</code> - An adaptive order adaptive time Adams Moulton method. It uses an order adaptivity algorithm is derived from Shampine&#39;s DDEABM.</li><li><code>AN5</code> - An adaptive 5th order fixed-leading coefficient Adams method in Nordsieck form.</li><li><code>JVODE_Adams</code> - An adaptive time adaptive order fixed-leading coefficient Adams method in Nordsieck form. The order adaptivity algorithm is derived from Sundials&#39; <code>CVODE_Adams</code>. In development.</li></ul><h3 id="OrdinaryDiffEq.jl-for-Stiff-Equations"><a class="docs-heading-anchor" href="#OrdinaryDiffEq.jl-for-Stiff-Equations">OrdinaryDiffEq.jl for Stiff Equations</a><a id="OrdinaryDiffEq.jl-for-Stiff-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#OrdinaryDiffEq.jl-for-Stiff-Equations" title="Permalink"></a></h3><h4 id="SDIRK-Methods"><a class="docs-heading-anchor" href="#SDIRK-Methods">SDIRK Methods</a><a id="SDIRK-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#SDIRK-Methods" title="Permalink"></a></h4><ul><li><code>ImplicitEuler</code> - A 1st order implicit solver. A-B-L-stable. Adaptive timestepping through a divided differences estimate via memory. Strong-stability preserving (SSP).</li><li><code>ImplicitMidpoint</code> - A second order A-stable symplectic and symmetric implicit solver. Good for highly stiff equations which need symplectic integration.</li><li><code>Trapezoid</code> - A second order A-stable symmetric ESDIRK method. &quot;Almost symplectic&quot; without numerical dampening. Also known as Crank-Nicolson when applied to PDEs. Adaptive timestepping via divided differences on the memory. Good for highly stiff equations which are non-oscillatory.</li><li><code>TRBDF2</code> - A second order A-B-L-S-stable one-step ESDIRK method. Includes stiffness-robust error estimates for accurate adaptive timestepping, smoothed derivatives for highly stiff and oscillatory problems.</li><li><code>SDIRK2</code> - An A-B-L stable 2nd order SDIRK method</li><li><code>Kvaerno3</code> - An A-L stable stiffly-accurate 3rd order ESDIRK method</li><li><code>KenCarp3</code> - An A-L stable stiffly-accurate 3rd order ESDIRK method with splitting</li><li><code>Cash4</code> - An A-L stable 4th order SDIRK method</li><li><code>Hairer4</code> - An A-L stable 4th order SDIRK method</li><li><code>Hairer42</code> - An A-L stable 4th order SDIRK method</li><li><code>Kvaerno4</code> - An A-L stable stiffly-accurate 4th order ESDIRK method</li><li><code>KenCarp4</code> - An A-L stable stiffly-accurate 4th order ESDIRK method with splitting</li><li><code>KenCarp47</code> - An A-L stable stiffly-accurate 4th order seven-stage ESDIRK method with splitting</li><li><code>Kvaerno5</code> - An A-L stable stiffly-accurate 5th order ESDIRK method</li><li><code>KenCarp5</code> - An A-L stable stiffly-accurate 5th order ESDIRK method with splitting</li><li><code>KenCarp58</code> - An A-L stable stiffly-accurate 5th order eight-stage ESDIRK method with splitting</li></ul><h4 id="Fully-Implicit-Runge-Kutta-Methods-(FIRK)"><a class="docs-heading-anchor" href="#Fully-Implicit-Runge-Kutta-Methods-(FIRK)">Fully-Implicit Runge-Kutta Methods (FIRK)</a><a id="Fully-Implicit-Runge-Kutta-Methods-(FIRK)-1"></a><a class="docs-heading-anchor-permalink" href="#Fully-Implicit-Runge-Kutta-Methods-(FIRK)" title="Permalink"></a></h4><ul><li><code>RadauIIA3</code> - An A-B-L stable fully implicit Runge-Kutta method with internal tableau complex basis transform for efficiency.</li><li><code>RadauIIA5</code> - An A-B-L stable fully implicit Runge-Kutta method with internal tableau complex basis transform for efficiency.</li></ul><h4 id="Parallel-Diagonally-Implicit-Runge-Kutta-Methods"><a class="docs-heading-anchor" href="#Parallel-Diagonally-Implicit-Runge-Kutta-Methods">Parallel Diagonally Implicit Runge-Kutta Methods</a><a id="Parallel-Diagonally-Implicit-Runge-Kutta-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-Diagonally-Implicit-Runge-Kutta-Methods" title="Permalink"></a></h4><ul><li><code>PDIRK44</code> - A 2 processor 4th order diagonally non-adaptive implicit method.</li></ul><p>These methods also have option <code>nlsolve</code> same as SDIRK methods. These methods also need <code>f</code> to be thread safe. It parallelises the <code>nlsolve</code> calls inside the method.</p><h4 id="Rosenbrock-Methods"><a class="docs-heading-anchor" href="#Rosenbrock-Methods">Rosenbrock Methods</a><a id="Rosenbrock-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Rosenbrock-Methods" title="Permalink"></a></h4><ul><li><code>ROS3P</code> - 3rd order A-stable and stiffly stable Rosenbrock method. Keeps high accuracy on discretizations of nonlinear parabolic PDEs.</li><li><code>Rodas3</code> - 3rd order A-stable and stiffly stable Rosenbrock method.</li><li><code>RosShamp4</code>- An A-stable 4th order Rosenbrock method.</li><li><code>Veldd4</code> - A 4th order D-stable Rosenbrock method.</li><li><code>Velds4</code> - A 4th order A-stable Rosenbrock method.</li><li><code>GRK4T</code> - An efficient 4th order Rosenbrock method.</li><li><code>GRK4A</code> - An A-stable 4th order Rosenbrock method. Essentially &quot;anti-L-stable&quot; but efficient.</li><li><code>Ros4LStab</code> - A 4th order L-stable Rosenbrock method.</li><li><code>Rodas4</code> - A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant</li><li><code>Rodas42</code> - A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant</li><li><code>Rodas4P</code> - A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems (as opposed to lower if not corrected).</li><li><code>Rodas4P2</code> - A 4th order L-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems. It is an improvement of Roadas4P and in case of inexact Jacobians a second order W method.</li><li><code>Rodas5</code> - A 5th order A-stable stiffly stable Rosenbrock method. Currently has a Hermite interpolant because its stiff-aware 3rd order interpolant is not yet implemented.</li></ul><h4 id="Rosenbrock-W-Methods"><a class="docs-heading-anchor" href="#Rosenbrock-W-Methods">Rosenbrock-W Methods</a><a id="Rosenbrock-W-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Rosenbrock-W-Methods" title="Permalink"></a></h4><ul><li><code>Rosenbrock23</code> - An Order 2/3 L-Stable Rosenbrock-W method which is good for very stiff equations with oscillations at low tolerances. 2nd order stiff-aware interpolation.</li><li><code>Rosenbrock32</code> - An Order 3/2 A-Stable Rosenbrock-W method which is good for mildy stiff equations without oscillations at low tolerances. Note that this method is prone to instability in the presence of oscillations, so use with caution. 2nd order stiff-aware interpolation.</li><li><code>RosenbrockW6S4OS</code> - A 4th order L-stable Rosenbrock-W method (fixed step only).</li><li><code>ROS34PW1a</code> - A 4th order L-stable Rosenbrock-W method.</li><li><code>ROS34PW1b</code> - A 4th order L-stable Rosenbrock-W method.</li><li><code>ROS34PW2</code> - A 4th order stiffy accurate Rosenbrock-W method for PDAEs.</li><li><code>ROS34PW3</code> - A 4th order strongly A-stable (Rinf~0.63) Rosenbrock-W method.</li></ul><h4 id="Stabilized-Explicit-Methods"><a class="docs-heading-anchor" href="#Stabilized-Explicit-Methods">Stabilized Explicit Methods</a><a id="Stabilized-Explicit-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Stabilized-Explicit-Methods" title="Permalink"></a></h4><ul><li><code>ROCK2</code> - Second order stabilized Runge-Kutta method. Exhibits high stability for real eigenvalues and is smoothened to allow for moderate sized complex eigenvalues.</li><li><code>ROCK4</code> - Fourth order stabilized Runge-Kutta method. Exhibits high stability for real eigenvalues and is smoothened to allow for moderate sized complex eigenvalues.</li><li><code>RKC</code> - Second order stabilized Runge-Kutta method. Exhibits high stability for real eigenvalues and is smoothened to allow for moderate sized complex eigenvalues.</li><li><code>SERK2</code> - Second order stabilized extrapolated Runge-Kutta method. Exhibits high stability for real eigenvalues and is smoothened to allow for moderate sized complex eigenvalues.</li><li><code>ESERK5</code> - Fifth order stabilized extrapolated Runge-Kutta method. Exhibits high stability for real eigenvalues and is smoothened to allow for moderate sized complex eigenvalues.</li></ul><p>ROCK methods offer a <code>min_stages</code> and <code>max_stages</code> functionality. SERK methods derive higher orders by Aitken-Neville algorithm. SERK2 is defaulted to Predictive control but has option of PI control.</p><h4 id="Parallelized-Implicit-Extrapolation-Methods"><a class="docs-heading-anchor" href="#Parallelized-Implicit-Extrapolation-Methods">Parallelized Implicit Extrapolation Methods</a><a id="Parallelized-Implicit-Extrapolation-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Parallelized-Implicit-Extrapolation-Methods" title="Permalink"></a></h4><p>The following are adaptive order, adaptive step size extrapolation methods:</p><ul><li><code>ImplicitEulerExtrapolation</code> - Extrapolation of implicit Euler method with Romberg sequence. Similar to Hairer&#39;s <code>SEULEX</code>.</li><li><code>ImplicitDeuflhardExtrapolation</code> - Midpoint extrapolation using Barycentric coordinates</li><li><code>ImplicitHairerWannerExtrapolation</code> - Midpoint extrapolation using Barycentric coordinates, following Hairer&#39;s <code>SODEX</code> in the adaptivity behavior.</li></ul><p>These methods have arguments for <code>max_order</code>, <code>min_order</code>, and <code>init_order</code> on the adaptive order algorithm. <code>threading</code> denotes whether to automatically multithread the <code>f</code> evaluations and J/W instantiations+factorizations, allowing for a high degree of within-method parallelism. We recommend to switch to multi-threading when the system consists of more than ~ 150 ODES. The defaults are:</p><ul><li><code>max_order=10</code></li><li><code>min_order=1</code> except for <code>ImplicitHairerWannerExtrapolation</code> it&#39;s 2.</li><li><code>init_order=5</code></li><li><code>threading=false</code></li></ul><p>Additionally, the <code>ImplicitDeuflhardExtrapolation</code> and <code>ImplicitHairerWannerExtrapolation</code> methods have the additional argument:</p><ul><li><code>sequence</code>: the step-number sequences, also called the subdividing</li></ul><p>sequence. Possible values are <code>:harmonic</code>, <code>:romberg</code> or <code>:bulirsch</code>. Default  is <code>:harmonic</code>.</p><p>To override, utilize the keyword arguments. For example:</p><pre><code class="language-julia hljs">alg = ImplicitDeuflhardExtrapolation(max_order=7,min_order=4,init_order=4,sequence=:bulirsch)
solve(prob,alg)</code></pre><p>Note that the order that is referred to is the extrapolation order. For <code>ImplicitEulerExtrapolation</code> this is the order of the method, for the others an extrapolation order of <code>n</code> gives an order <code>2(n+1)</code> method.</p><h4 id="Parallelized-DIRK-Methods"><a class="docs-heading-anchor" href="#Parallelized-DIRK-Methods">Parallelized DIRK Methods</a><a id="Parallelized-DIRK-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Parallelized-DIRK-Methods" title="Permalink"></a></h4><p>These methods parallelize the J/W instantiation and factorization, making them efficient on small highly stiff ODEs. Has an option <code>threading=true</code> to turn on/off multithreading.</p><ul><li><code>PDIRK44</code>: a 4th order 2-processor DIRK method.</li></ul><h4 id="Exponential-Runge-Kutta-Methods"><a class="docs-heading-anchor" href="#Exponential-Runge-Kutta-Methods">Exponential Runge-Kutta Methods</a><a id="Exponential-Runge-Kutta-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Exponential-Runge-Kutta-Methods" title="Permalink"></a></h4><p>These methods are all fixed timestepping only.</p><ul><li><code>LawsonEuler</code> - First order exponential Euler scheme.</li><li><code>NorsettEuler</code> - First order exponential-RK scheme. Alias: <code>ETD1</code>.</li><li><code>ETD2</code> - Second order Exponential Time Differencing method (in development).</li><li><code>ETDRK2</code> - 2nd order exponential-RK scheme.</li><li><code>ETDRK3</code> - 3rd order exponential-RK scheme.</li><li><code>ETDRK4</code> - 4th order exponential-RK scheme.</li><li><code>HochOst4</code> - 4th order exponential-RK scheme with stiff order 4.</li></ul><p>The methods are intended for semilinear problems constructed by <a href="../../types/split_ode_types/#split_ode_prob"><code>SplitODEProblem</code></a> or <code>SplitODEFunction</code>. They can also be used for a general nonlinear problem, in which case the jacobian of the right hand side is used as the linear operator in each time step.</p><p>Except for <code>ETD2</code>, all methods come with these options, which can be set in the methods&#39; constructor:</p><ul><li><code>krylov</code> - boolean, default: <code>false</code>. Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.</li><li><code>m</code> - integer, default: <code>30</code>. Controls the size of Krylov subsapce.</li><li><code>iop</code> - integer, default: <code>0</code>. If not zero, determines the length of the incomplete orthogonalization procedure (IOP) <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. Note that if the linear operator/jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.</li><li><code>autodiff</code> and <code>chunksize</code>: autodiff control if problem is not semilinear and explicit jacobian is not given. See <a href="#Extra-Options-1">Extra Options</a> for more details.</li></ul><h4 id="Adaptive-Exponential-Rosenbrock-Methods"><a class="docs-heading-anchor" href="#Adaptive-Exponential-Rosenbrock-Methods">Adaptive Exponential Rosenbrock Methods</a><a id="Adaptive-Exponential-Rosenbrock-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-Exponential-Rosenbrock-Methods" title="Permalink"></a></h4><ul><li><code>Exprb32</code> - 3rd order adaptive Exponential-Rosenbrock scheme.</li><li><code>Exprb43</code> - 4th order adaptive Exponential-Rosenbrock scheme.</li></ul><p>The exponential rosenbrock methods cannot be applied to semilinear problems. Options for the solvers are the same as <a href="#Exponential-Runge-Kutta-Methods-1">Exponential Runge-Kutta Methods</a> except that Krylov approximation is always used.</p><h4 id="Exponential-Propagation-Iterative-Runge-Kutta-Methods-(EPIRK)"><a class="docs-heading-anchor" href="#Exponential-Propagation-Iterative-Runge-Kutta-Methods-(EPIRK)">Exponential Propagation Iterative Runge-Kutta Methods (EPIRK)</a><a id="Exponential-Propagation-Iterative-Runge-Kutta-Methods-(EPIRK)-1"></a><a class="docs-heading-anchor-permalink" href="#Exponential-Propagation-Iterative-Runge-Kutta-Methods-(EPIRK)" title="Permalink"></a></h4><p>These methods are all fixed timestepping only.</p><ul><li><code>Exp4</code> - 4th order EPIRK scheme.</li><li><code>EPIRK4s3A</code> - 4th order EPIRK scheme with stiff order 4.</li><li><code>EPIRK4s3B</code> - 4th order EPIRK scheme with stiff order 4.</li><li><code>EPIRK5P1</code> - 5th order EPIRK scheme.</li><li><code>EPIRK5P2</code> - 5th order EPIRK scheme.</li><li><code>EPIRK5s3</code> - 5th order &quot;horizontal&quot; EPIRK scheme with stiff order 5. Broken.</li><li><code>EXPRB53s3</code>- 5th order EPIRK scheme with stiff order 5.</li></ul><p>Options:</p><ul><li><code>adaptive_krylov</code> - boolean, default: <code>true</code>. Determines if the adaptive Krylov algorithm with timestepping of Neisen &amp; Wright is used.</li><li><code>m</code> - integer, default: <code>30</code>. Controls the size of Krylov subsapce, or the size for the first step if <code>adaptive_krylov=true</code>.</li><li><code>iop</code> - integer, default: <code>0</code>. If not zero, determines the length of the incomplete orthogonalization procedure (IOP) <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. Note that if the linear operator/jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.</li><li><code>autodiff</code> and <code>chunksize</code>: autodiff control if problem is not semilinear and explicit jacobian is not given. See <a href="#Extra-Options-1">Extra Options</a> for more details.</li></ul><p>It should be noted that many of the methods are still at an experimental stage of development, and thus should be used with caution.</p><h4 id="Multistep-Methods"><a class="docs-heading-anchor" href="#Multistep-Methods">Multistep Methods</a><a id="Multistep-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Multistep-Methods" title="Permalink"></a></h4><p>Quasi-constant stepping is the time stepping strategy which matches the classic GEAR, LSODE,  and <code>ode15s</code> integrators. The variable-coefficient methods match the ideas of the classic EPISODE integrator and early VODE designs. The Fixed Leading Coefficient (FLC) methods match the behavior of the classic VODE and Sundials CVODE integrator.</p><ul><li><code>QNDF1</code> - An adaptive order 1 quasi-constant timestep L-stable numerical differentiation function (NDF) method. Optional parameter <code>kappa</code> defaults to Shampine&#39;s accuracy-optimal <code>-0.1850</code>.</li><li><code>QBDF1</code> - An adaptive order 1 L-stable BDF method. This is equivalent to implicit Euler but using the BDF error estimator.</li><li><code>ABDF2</code> - An adaptive order 2 L-stable fixed leading coefficient multistep BDF method.</li><li><code>QNDF2</code> - An adaptive order 2 quasi-constant timestep L-stable numerical differentiation function (NDF) method.</li><li><code>QBDF2</code> - An adaptive order 2 L-stable BDF method using quasi-constant timesteps.</li><li><code>QNDF</code> - An adaptive order quasi-constant timestep NDF method. Utilizes Shampine&#39;s accuracy-optimal <code>kappa</code> values as defaults (has a keyword argument for a tuple of <code>kappa</code> coefficients). Similar to <code>ode15s</code>.</li><li><code>QBDF</code> - An adaptive order quasi-constant timestep BDF method.  </li><li><code>MEBDF2</code> - The second order Modified Extended BDF method, which has improved stability properties over the standard BDF. Fixed timestep only.</li><li><code>FBDF</code> - A fixed-leading coefficient adaptive-order adaptive-time BDF method, similar to <code>ode15i</code> or <code>CVODE_BDF</code> in divided differences form.</li></ul><h4 id="Implicit-Strong-Stability-Preserving-Runge-Kutta-Methods-for-Hyperbolic-PDEs-(Conservation-Laws)"><a class="docs-heading-anchor" href="#Implicit-Strong-Stability-Preserving-Runge-Kutta-Methods-for-Hyperbolic-PDEs-(Conservation-Laws)">Implicit Strong-Stability Preserving Runge-Kutta Methods for Hyperbolic PDEs (Conservation Laws)</a><a id="Implicit-Strong-Stability-Preserving-Runge-Kutta-Methods-for-Hyperbolic-PDEs-(Conservation-Laws)-1"></a><a class="docs-heading-anchor-permalink" href="#Implicit-Strong-Stability-Preserving-Runge-Kutta-Methods-for-Hyperbolic-PDEs-(Conservation-Laws)" title="Permalink"></a></h4><ul><li><code>SSPSDIRK2</code> - A second order A-L stable symplectic SDIRK method with the strong stability preserving (SSP) property (SSP coefficient 2). Fixed timestep only.</li></ul><h4 id="Extra-Options"><a class="docs-heading-anchor" href="#Extra-Options">Extra Options</a><a id="Extra-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Extra-Options" title="Permalink"></a></h4><p>All of the Rosenbrock and SDIRK methods allow for specification of <code>linsolve</code>: the linear solver which is used. For more information on specifying the linear solver, see <a href="../../features/linear_nonlinear/#linear_nonlinear">the manual page on solver specification</a>.</p><p>Note that performance overload information (Jacobians etc.) are not used in this mode. This can control automatic differentiation of the Jacobian as well. For more information on specifying the nonlinear solver, see <a href="../../features/linear_nonlinear/#linear_nonlinear">the manual page on solver specification</a>.</p><p>Additionally, the Rosenbrock and SDIRK methods have differentiation controls. In each of these, <code>autodiff</code> can be set to turn on/off autodifferentiation, and <code>chunk_size</code> can be used to set the chunksize of the Dual  numbers (see the <a href="http://www.juliadiff.org/ForwardDiff.jl/stable/user/advanced/#Configuring-Chunk-Size-1">documentation for ForwardDiff.jl for details</a>). In addition, the Rosenbrock and SDIRK methods can set <code>diff_type</code>, which is the type of numerical differentiation that is used (when autodifferentiation is disabled). The choices are <code>Val{:central}</code>, <code>Val{:forward}</code> or <code>Val{:complex}</code>.</p><p>Examples:</p><pre><code class="language-julia hljs">sol = solve(prob,Rosenbrock23()) # Standard, uses autodiff
sol = solve(prob,Rosenbrock23(chunk_size=10)) # Autodiff with chunksize of 10
sol = solve(prob,Rosenbrock23(autodiff=false)) # Numerical differentiation with central differencing
sol = solve(prob,Rosenbrock23(autodiff=false,diff_type=Val{:forward})) # Numerical differentiation with forward differencing</code></pre><h4 id="Tableau-Method"><a class="docs-heading-anchor" href="#Tableau-Method">Tableau Method</a><a id="Tableau-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Tableau-Method" title="Permalink"></a></h4><p>Additionally, there is the tableau method:</p><ul><li><code>ExplicitRK</code> - A general Runge-Kutta solver which takes in a tableau. Can be adaptive. Tableaus are specified via the keyword argument <code>tab=tableau</code>. The default tableau is for Dormand-Prince 4/5. Other supplied tableaus can be found in the Supplied Tableaus section.</li></ul><p>Example usage:</p><pre><code class="language-julia hljs">alg = ExplicitRK(tableau=constructDormandPrince())
solve(prob,alg)</code></pre><h4 id="CompositeAlgorithm"><a class="docs-heading-anchor" href="#CompositeAlgorithm">CompositeAlgorithm</a><a id="CompositeAlgorithm-1"></a><a class="docs-heading-anchor-permalink" href="#CompositeAlgorithm" title="Permalink"></a></h4><p>One unique feature of OrdinaryDiffEq.jl is the <code>CompositeAlgorithm</code>, which allows you to, with very minimal overhead, design a multimethod which switches between chosen algorithms as needed. The syntax is <code>CompositeAlgorithm(algtup,choice_function)</code> where <code>algtup</code> is a tuple of OrdinaryDiffEq.jl algorithms, and <code>choice_function</code> is a function which declares which method to use in the following step. For example, we can design a multimethod which uses <code>Tsit5()</code> but switches to <code>Vern7()</code> whenever <code>dt</code> is too small:</p><pre><code class="language-julia hljs">choice_function(integrator) = (Int(integrator.dt&lt;0.001) + 1)
alg_switch = CompositeAlgorithm((Tsit5(),Vern7()),choice_function)</code></pre><p>The <code>choice_function</code> takes in an <code>integrator</code> and thus all of the features available in the <a href="../../basics/integrator/#integrator">Integrator Interface</a> can be used in the choice function.</p><p>A helper algorithm was created for building 2-method automatic switching for stiffness detection algorithms. This is the <code>AutoSwitch</code> algorithm with the following options:</p><pre><code class="language-julia hljs">AutoSwitch(nonstiffalg::nAlg, stiffalg::sAlg;
           maxstiffstep=10, maxnonstiffstep=3,
           nonstifftol::T=9//10, stifftol::T=9//10,
           dtfac=2.0, stiffalgfirst=false)</code></pre><p>The <code>nonstiffalg</code> must have an appropriate stiffness estimate built into the method. The <code>stiffalg</code> can receive its estimate from the Jacobian calculation. <code>maxstiffstep</code> is the number of stiffness detects before switching to the stiff algorithm and <code>maxnonstiffstep</code> is vice versa. <code>nonstifftol</code> and <code>stifftol</code> are the tolerances associated with the stiffness comparison against the stability region. Decreasing <code>stifftol</code> makes switching to the non-stiff algorithm less likely. Decreasing <code>nonstifftol</code> makes switching to the stiff algorithm more likely. <code>dtfac</code> is the factor that <code>dt</code> is changed when switching: multiplied when going from non-stiff to stiff and divided when going stiff to non-stiff. <code>stiffalgfirst</code> denotes whether the first step should use the stiff algorithm.</p><h4 id="Pre-Built-Stiffness-Detecting-and-Auto-Switching-Algorithms"><a class="docs-heading-anchor" href="#Pre-Built-Stiffness-Detecting-and-Auto-Switching-Algorithms">Pre-Built Stiffness Detecting and Auto-Switching Algorithms</a><a id="Pre-Built-Stiffness-Detecting-and-Auto-Switching-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-Built-Stiffness-Detecting-and-Auto-Switching-Algorithms" title="Permalink"></a></h4><p>These methods require a <code>Autoalg(stiffalg)</code> to be chosen as the method to switch to when the ODE is stiff. It can be any of the OrdinaryDiffEq.jl one-step stiff methods and has all of the arguments of the <code>AutoSwitch</code> algorithm.</p><ul><li><code>AutoTsit5</code> - <code>Tsit5</code> with automated switching.</li><li><code>AutoDP5</code> - <code>DP5</code> with automated switching.</li><li><code>AutoVern6</code> - <code>Vern6</code> with automated switching.</li><li><code>AutoVern7</code> - <code>Vern7</code> with automated switching.</li><li><code>AutoVern8</code> - <code>Vern8</code> with automated switching.</li><li><code>AutoVern9</code> - <code>Vern9</code> with automated switching.</li></ul><p>Example:</p><pre><code class="language-julia hljs">tsidas_alg = AutoTsit5(Rodas5())
sol = solve(prob,tsidas_alg)

tsidas_alg = AutoTsit5(Rodas5(),nonstifftol = 11/10)</code></pre><p>Is the <code>Tsit5</code> method with automatic switching to <code>Rodas5</code>.</p><h3 id="ode_solve_sundials"><a class="docs-heading-anchor" href="#ode_solve_sundials">Sundials.jl</a><a id="ode_solve_sundials-1"></a><a class="docs-heading-anchor-permalink" href="#ode_solve_sundials" title="Permalink"></a></h3><p>Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use Sundials.jl:</p><pre><code class="language-julia hljs">]add Sundials
using Sundials</code></pre><p>The Sundials suite is built around multistep methods. These methods are more efficient than other methods when the cost of the function calculations is really high, but for less costly functions the cost of nurturing the timestep overweighs the benefits. However, the BDF method is a classic method for stiff equations and &quot;generally works&quot;.</p><ul><li><code>CVODE_BDF</code> - CVode Backward Differentiation Formula (BDF) solver.</li><li><code>CVODE_Adams</code> - CVode Adams-Moulton solver.</li><li><code>ARKODE</code> - Explicit and ESDIRK Runge-Kutta methods of orders 2-8 depending on choice of options.</li></ul><p>The Sundials algorithms all come with a 3rd order Hermite polynomial interpolation. Note that the constructors for the Sundials algorithms take two main arguments:</p><ul><li><code>method</code> - This is the method for solving the implicit equation. For BDF this defaults to <code>:Newton</code> while for Adams this defaults to <code>:Functional</code>. These choices match the recommended pairing in the Sundials.jl manual. However, note that using the <code>:Newton</code> method may take less iterations but requires more memory than the <code>:Function</code> iteration approach.</li><li><code>linear_solver</code> - This is the linear solver which is used in the <code>:Newton</code> method.</li></ul><p>The choices for the linear solver are:</p><ul><li><code>:Dense</code> - A dense linear solver.</li><li><code>:Band</code> - A solver specialized for banded Jacobians. If used, you must set the position of the upper and lower non-zero diagonals via <code>jac_upper</code> and <code>jac_lower</code>.</li><li><code>:LapackDense</code> - A version of the dense linear solver that uses the Julia-provided OpenBLAS-linked LAPACK for multithreaded operations. This will be faster than <code>:Dense</code> on larger systems but has noticable overhead on smaller (&lt;100 ODE) systems.</li><li><code>:LapackBand</code> - A version of the banded linear solver that uses the Julia-provided OpenBLAS-linked LAPACK for multithreaded operations. This will be faster than <code>:Band</code> on larger systems but has noticable overhead on smaller (&lt;100 ODE) systems.</li><li><code>:Diagonal</code> - This method is specialized for diagonal Jacobians.</li><li><code>:GMRES</code> - A GMRES method. Recommended first choice Krylov method</li><li><code>:BCG</code> - A Biconjugate gradient method.</li><li><code>:PCG</code> - A preconditioned conjugate gradient method. Only for symmetric linear systems.</li><li><code>:TFQMR</code> - A TFQMR method.</li><li><code>:KLU</code> - A sparse factorization method. Requires that the user specifies a Jacobian. The Jacobian must be set as a sparse matrix in the <code>ODEProblem</code> type.</li></ul><p>Example:</p><pre><code class="language-julia hljs">CVODE_BDF() # BDF method using Newton + Dense solver
CVODE_BDF(method=:Functional) # BDF method using Functional iterations
CVODE_BDF(linear_solver=:Band,jac_upper=3,jac_lower=3) # Banded solver with nonzero diagonals 3 up and 3 down
CVODE_BDF(linear_solver=:BCG) # Biconjugate gradient method</code></pre><p>The main options for <code>ARKODE</code> are the choice between explicit and implicit and the method order, given via:</p><pre><code class="language-julia hljs">ARKODE(Sundials.Explicit()) # Solve with explicit tableau of default order 4
ARKODE(Sundials.Implicit(),order = 3) # Solve with explicit tableau of order 3</code></pre><p>The order choices for explicit are 2 through 8 and for implicit 3 through 5. Specific methods can also be set through the <code>etable</code> and <code>itable</code> options for explicit and implicit tableaus respectively. The available tableaus are:</p><p><code>etable</code>:</p><ul><li><code>HEUN_EULER_2_1_2</code>: 2nd order Heun&#39;s method</li><li><code>BOGACKI_SHAMPINE_4_2_3</code>:</li><li><code>ARK324L2SA_ERK_4_2_3</code>: explicit portion of Kennedy and Carpenter&#39;s 3rd order method</li><li><code>ZONNEVELD_5_3_4</code>: 4th order explicit method</li><li><code>ARK436L2SA_ERK_6_3_4</code>: explicit portion of Kennedy and Carpenter&#39;s 4th order method</li><li><code>SAYFY_ABURUB_6_3_4</code>: 4th order explicit method</li><li><code>CASH_KARP_6_4_5</code>: 5th order explicit method</li><li><code>FEHLBERG_6_4_5</code>: Fehlberg&#39;s classic 5th order method</li><li><code>DORMAND_PRINCE_7_4_5</code>: the classic 5th order Dormand-Prince method</li><li><code>ARK548L2SA_ERK_8_4_5</code>: explicit portion of Kennedy and Carpenter&#39;s 5th order method</li><li><code>VERNER_8_5_6</code>: Verner&#39;s classic 5th order method</li><li><code>FEHLBERG_13_7_8</code>: Fehlberg&#39;s 8th order method</li></ul><p><code>itable</code>:</p><ul><li><code>SDIRK_2_1_2</code>: An A-B-stable 2nd order SDIRK method</li><li><code>BILLINGTON_3_3_2</code>: A second order method with a 3rd order error predictor of less stability</li><li><code>TRBDF2_3_3_2</code>: The classic TR-BDF2 method</li><li><code>KVAERNO_4_2_3</code>: an L-stable 3rd order ESDIRK method</li><li><code>ARK324L2SA_DIRK_4_2_3</code>: implicit portion of Kennedy and Carpenter&#39;s 3th order method</li><li><code>CASH_5_2_4</code>: Cash&#39;s 4th order L-stable SDIRK method</li><li><code>CASH_5_3_4</code>: Cash&#39;s 2nd 4th order L-stable SDIRK method</li><li><code>SDIRK_5_3_4</code>: Hairer&#39;s 4th order SDIRK method</li><li><code>KVAERNO_5_3_4</code>: Kvaerno&#39;s 4th order ESDIRK method</li><li><code>ARK436L2SA_DIRK_6_3_4</code>: implicit portion of Kennedy and Carpenter&#39;s 4th order method</li><li><code>KVAERNO_7_4_5</code>: Kvaerno&#39;s 5th order ESDIRK method</li><li><code>ARK548L2SA_DIRK_8_4_5</code>: implicit portion of Kennedy and Carpenter&#39;s 5th order method</li></ul><p>These can be set for example via:</p><pre><code class="language-julia hljs">ARKODE(Sundials.Explicit(),etable = Sundials.DORMAND_PRINCE_7_4_5)
ARKODE(Sundials.Implicit(),itable = Sundials.KVAERNO_4_2_3)</code></pre><p>All of the additional options are available. The full constructor is:</p><pre><code class="language-julia hljs">CVODE_BDF(;method=:Newton,linear_solver=:Dense,
          jac_upper=0,jac_lower=0,
          stored_upper = jac_upper + jac_lower,
          non_zero=0,krylov_dim=0,
          stability_limit_detect=false,
          max_hnil_warns = 10,
          max_order = 5,
          max_error_test_failures = 7,
          max_nonlinear_iters = 3,
          max_convergence_failures = 10,
          prec = nothing, prec_side = 0)

CVODE_Adams(;method=:Functional,linear_solver=:None,
            jac_upper=0,jac_lower=0,
            stored_upper = jac_upper + jac_lower,
            krylov_dim=0,
            stability_limit_detect=false,
            max_hnil_warns = 10,
            max_order = 12,
            max_error_test_failures = 7,
            max_nonlinear_iters = 3,
            max_convergence_failures = 10,
            prec = nothing, psetup = nothing, prec_side = 0)

ARKODE(stiffness=Sundials.Implicit();
      method=:Newton,linear_solver=:Dense,
      jac_upper=0,jac_lower=0,stored_upper = jac_upper+jac_lower,
      non_zero=0,krylov_dim=0,
      max_hnil_warns = 10,
      max_error_test_failures = 7,
      max_nonlinear_iters = 3,
      max_convergence_failures = 10,
      predictor_method = 0,
      nonlinear_convergence_coefficient = 0.1,
      dense_order = 3,
      order = 4,
      set_optimal_params = false,
      crdown = 0.3,
      dgmax = 0.2,
      rdiv = 2.3,
      msbp = 20,
      adaptivity_method = 0,
      prec = nothing, psetup = nothing, prec_side = 0
      )</code></pre><p>See <a href="https://computing.llnl.gov/sites/default/files/cv_guide-5.7.0.pdf">the CVODE manual</a> and the <a href="https://computing.llnl.gov/sites/default/files/ark_guide-4.7.0.pdf">ARKODE manual</a> for details on the additional options.</p><p>Note that here <code>prec</code> is a preconditioner function <code>prec(z,r,p,t,y,fy,gamma,delta,lr)</code> where:</p><ul><li><code>z</code>: the computed output vector</li><li><code>r</code>: the right-hand side vector of the linear system</li><li><code>p</code>: the parameters</li><li><code>t</code>: the current independent variable</li><li><code>du</code>: the current value of <code>f(u,p,t)</code></li><li><code>gamma</code>: the <code>gamma</code> of <code>W = M - gamma*J</code></li><li><code>delta</code>: the iterative method tolerance</li><li><code>lr</code>: a flag for whether <code>lr=1</code> (left) or <code>lr=2</code> (right) preconditioning</li></ul><p>and <code>psetup</code> is the preconditioner setup function for pre-computing Jacobian information <code>psetup(p, t, u, du, jok, jcurPtr, gamma)</code>. Where:</p><ul><li><code>p</code>: the parameters</li><li><code>t</code>: the current independent variable</li><li><code>u</code>: the current state</li><li><code>du</code>: the current <code>f(u,p,t)</code></li><li><code>jok</code>: a bool indicating whether the Jacobian needs to be updated</li><li><code>jcurPtr</code>: a reference to an Int for whether the Jacobian was updated. <code>jcurPtr[]=true</code> should be set if the Jacobian was updated, and <code>jcurPtr[]=false</code> should be set if the Jacobian was not updated.</li><li><code>gamma</code>: the <code>gamma</code> of <code>W = M - gamma*J</code></li></ul><p><code>psetup</code> is optional when <code>prec</code> is set.</p><h3 id="ODEInterface.jl"><a class="docs-heading-anchor" href="#ODEInterface.jl">ODEInterface.jl</a><a id="ODEInterface.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ODEInterface.jl" title="Permalink"></a></h3><p>The ODEInterface algorithms are the classic Fortran algorithms. While the non-stiff algorithms are superseded by the more featured and higher performance Julia implementations from OrdinaryDiffEq.jl, the stiff solvers such as <code>radau</code> are some of the most efficient methods available (but are restricted for use on arrays of Float64).</p><p>Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use ODEInterfaceDiffEq.jl:</p><pre><code class="language-julia hljs">]add ODEInterfaceDiffEq
using ODEInterfaceDiffEq</code></pre><ul><li><code>dopri5</code> - Hairer&#39;s classic implementation of the Dormand-Prince 4/5 method.</li><li><code>dop853</code> - Explicit Runge-Kutta 8(5,3) by Dormand-Prince.</li><li><code>odex</code> - GBS extrapolation-algorithm based on the midpoint rule.</li><li><code>seulex</code> - Extrapolation-algorithm based on the linear implicit Euler method.</li><li><code>radau</code> - Implicit Runge-Kutta (Radau IIA) of variable order between 5 and 13.</li><li><code>radau5</code> - Implicit Runge-Kutta method (Radau IIA) of order 5.</li><li><code>rodas</code> - Rosenbrock 4(3) method.</li><li><code>ddeabm</code> - Adams-Bashforth-Moulton Predictor-Corrector method (order between 1 and 12)</li><li><code>ddebdf</code> - Backward Differentiation Formula (orders between 1 and 5)</li></ul><p>Note that while the output only has a linear interpolation, a higher order interpolation is used for intermediate dense output for <code>saveat</code> and for event handling.</p><h3 id="LSODA.jl"><a class="docs-heading-anchor" href="#LSODA.jl">LSODA.jl</a><a id="LSODA.jl-1"></a><a class="docs-heading-anchor-permalink" href="#LSODA.jl" title="Permalink"></a></h3><p>This setup provides a wrapper to the algorithm LSODA, a well-known method which uses switching to solve both stiff and non-stiff equations.</p><ul><li><code>lsoda</code> - The LSODA wrapper algorithm.</li></ul><p>Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use LSODA.jl:</p><pre><code class="language-julia hljs">]add LSODA
using LSODA</code></pre><h3 id="IRKGaussLegendre.jl"><a class="docs-heading-anchor" href="#IRKGaussLegendre.jl">IRKGaussLegendre.jl</a><a id="IRKGaussLegendre.jl-1"></a><a class="docs-heading-anchor-permalink" href="#IRKGaussLegendre.jl" title="Permalink"></a></h3><p>This setup provides a specific solver, <code>IRKGL16</code>, which is a 16th order Symplectic Gauss-Legendre scheme. This scheme is highly efficient for precise integration of ODEs, specifically ODEs derived from Hamiltonian systems.</p><p>Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use IRKGaussLegendre.jl:</p><pre><code class="language-julia hljs">]add IRKGaussLegendre
using IRKGaussLegendre</code></pre><h3 id="SimpleDiffEq.jl"><a class="docs-heading-anchor" href="#SimpleDiffEq.jl">SimpleDiffEq.jl</a><a id="SimpleDiffEq.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SimpleDiffEq.jl" title="Permalink"></a></h3><p>This setup provides access to simplified versions of a few ODE solvers. They mostly exist for experimentation, but offer shorter compile times. They have limitations compared to OrdinaryDiffEq.jl and are not generally faster.</p><ul><li><code>SimpleTsit5</code> - A fixed timestep integrator form of Tsit5. Not compatible with events.</li><li><code>SimpleATsit5</code> - An adaptive Tsit5 with an interpolation in its simplest form. Not compatible with events.</li><li><code>GPUSimpleATsit5</code> - A version of <code>SimpleATsit5</code> without the integrator interface. Only allows <code>solve</code>.</li><li><code>SimpleRK4</code> - A fixed timestep barebones RK4 implementation with integrators.</li><li><code>LoopRK4</code> - A fixed timestep barebones RK4. Not compatible with events or the integrator interface.</li><li><code>GPURK4</code> - A fully static RK4 for specialized compilation to accelerators like GPUs and TPUs.</li></ul><p>Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use SimpleDiffEq.jl:</p><pre><code class="language-julia hljs">]add SimpleDiffEq
using SimpleDiffEq</code></pre><h3 id="ODE.jl"><a class="docs-heading-anchor" href="#ODE.jl">ODE.jl</a><a id="ODE.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ODE.jl" title="Permalink"></a></h3><p>Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use ODE.jl:</p><pre><code class="language-julia hljs">]add ODE
using ODE</code></pre><ul><li><code>ode23</code> - Bogacki-Shampine&#39;s order 2/3 Runge-Kutta  method</li><li><code>ode45</code> - A Dormand-Prince order 4/5 Runge-Kutta method</li><li><code>ode23s</code> - A modified Rosenbrock order 2/3 method due to Shampine</li><li><code>ode78</code> - A Fehlburg order 7/8 Runge-Kutta method</li><li><code>ode4</code> - The classic Runge-Kutta order 4 method</li><li><code>ode4ms</code> - A fixed-step, fixed order Adams-Bashforth-Moulton method†</li><li><code>ode4s</code> - A 4th order Rosenbrock method due to Shampine</li></ul><p>†: Does not step to the interval endpoint. This can cause issues with discontinuity detection, and <a href="../../features/diffeq_arrays/#diffeq_arrays">discrete variables need to be updated appropriately</a>.</p><h3 id="MATLABDiffEq.jl"><a class="docs-heading-anchor" href="#MATLABDiffEq.jl">MATLABDiffEq.jl</a><a id="MATLABDiffEq.jl-1"></a><a class="docs-heading-anchor-permalink" href="#MATLABDiffEq.jl" title="Permalink"></a></h3><p>Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use MATLABDiffEq.jl:</p><pre><code class="language-julia hljs">]add https://github.com/JuliaDiffEq/MATLABDiffEq.jl
using MATLABDiffEq</code></pre><p>This requires a licensed MATLAB installation. The available methods are:</p><ul><li><code>MATLABDiffEq.ode23</code></li><li><code>MATLABDiffEq.ode45</code></li><li><code>MATLABDiffEq.ode113</code></li><li><code>MATLABDiffEq.ode23s</code></li><li><code>MATLABDiffEq.ode23t</code></li><li><code>MATLABDiffEq.ode23tb</code></li><li><code>MATLABDiffEq.ode15s</code></li><li><code>MATLABDiffEq.ode15i</code></li></ul><p>For more information on these algorithms, see <a href="https://www.mathworks.com/help/matlab/math/choose-an-ode-solver.html">the MATLAB documentation</a>.</p><h3 id="SciPyDiffEq.jl"><a class="docs-heading-anchor" href="#SciPyDiffEq.jl">SciPyDiffEq.jl</a><a id="SciPyDiffEq.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SciPyDiffEq.jl" title="Permalink"></a></h3><p><a href="https://github.com/JuliaDiffEq/SciPyDiffEq.jl">SciPyDiffEq.jl</a> is a wrapper over SciPy for easing the transition of new users (same exact results!) and benchmarking. This wrapper uses Julia&#39;s JIT acceleration to accelerate about 3x over SciPy+Numba, but it is still around 1000x slower than the pure-Julia methods and thus should probably be used sparingly.</p><p>Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use SciPyDiffEq.jl:</p><pre><code class="language-julia hljs">]add https://github.com/JuliaDiffEq/SciPyDiffEq.jl
using SciPyDiffEq</code></pre><p>The available methods are:</p><ul><li><code>SciPyDiffEq.RK45</code></li><li><code>SciPyDiffEq.RK23</code></li><li><code>SciPyDiffEq.Radau</code></li><li><code>SciPyDiffEq.BDF</code></li><li><code>SciPyDiffEq.LSODA</code></li></ul><h3 id="deSolveDiffEq.jl"><a class="docs-heading-anchor" href="#deSolveDiffEq.jl">deSolveDiffEq.jl</a><a id="deSolveDiffEq.jl-1"></a><a class="docs-heading-anchor-permalink" href="#deSolveDiffEq.jl" title="Permalink"></a></h3><p><a href="https://github.com/JuliaDiffEq/deSolveDiffEq.jl">deSolveDiffEq.jl</a> is a wrapper over R&#39;s deSolve for easing the transition of new users (same exact results!) and benchmarking. This wrapper is around 1000x slower than the pure-Julia methods (~2x-3x overhead from directly using R) and thus should probably be used sparingly.</p><p>Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use deSolveDiffEq.jl:</p><pre><code class="language-julia hljs">]add https://github.com/JuliaDiffEq/deSolveDiffEq.jl
using deSolveDiffEq</code></pre><p>The available methods are:</p><ul><li><code>deSolveDiffEq.lsoda</code></li><li><code>deSolveDiffEq.lsode</code></li><li><code>deSolveDiffEq.lsodes</code></li><li><code>deSolveDiffEq.lsodar</code></li><li><code>deSolveDiffEq.vode</code></li><li><code>deSolveDiffEq.daspk</code></li><li><code>deSolveDiffEq.euler</code></li><li><code>deSolveDiffEq.rk4</code></li><li><code>deSolveDiffEq.ode23</code></li><li><code>deSolveDiffEq.ode45</code></li><li><code>deSolveDiffEq.radau</code></li><li><code>deSolveDiffEq.bdf</code></li><li><code>deSolveDiffEq.bdf_d</code></li><li><code>deSolveDiffEq.adams</code></li><li><code>deSolveDiffEq.impAdams</code></li><li><code>deSolveDiffEq.impAdams_d</code></li></ul><h3 id="GeometricIntegrators.jl"><a class="docs-heading-anchor" href="#GeometricIntegrators.jl">GeometricIntegrators.jl</a><a id="GeometricIntegrators.jl-1"></a><a class="docs-heading-anchor-permalink" href="#GeometricIntegrators.jl" title="Permalink"></a></h3><p>GeometricIntegrators.jl is a set of fixed timestep algorithms written in Julia. Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use GeometricIntegratorsDiffEq.jl:</p><pre><code class="language-julia hljs">]add https://github.com/JuliaDiffEq/GeometricIntegratorsDiffEq.jl
using GeometricIntegratorsDiffEq</code></pre><ul><li><code>GIEuler</code> - 1st order Euler method</li><li><code>GIMidpoint</code> - 2nd order explicit midpoint method</li><li><code>GIHeun2</code> - 2nd order Heun&#39;s method</li><li><code>GIRalston2</code> - 2nd order Ralston&#39;s method</li><li><code>GIHeun3</code> - 3rd order Heun&#39;s method</li><li><code>GIRalston3</code> - 3rd order Ralston&#39;s method</li><li><code>GIRunge</code> - 3rd order Kutta&#39;s method</li><li><code>GIKutta</code> - 3rd order Kutta&#39;s method</li><li><code>GIRK4</code> - standard 4th order Runge-Kutta</li><li><code>GIRK416</code></li><li><code>GIRK438</code> - 4th order Runge-Kutta, 3/8&#39;s rule</li><li><code>GIImplicitEuler</code> - 1st order implicit Euler method</li><li><code>GIImplicitMidpoint</code> - 2nd order implicit midpoint method</li><li><code>GIRadauIA(s)</code> - s-stage Radau-IA</li><li><code>GIRadauIIA(s)</code> - s-stage Radau-IA</li><li><code>GILobattoIIIA(s)</code></li><li><code>GILobattoIIIB(s)</code></li><li><code>GILobattoIIIC(s)</code></li><li><code>GILobattoIIIC̄(s)</code></li><li><code>GILobattoIIID(s)</code></li><li><code>GILobattoIIIE(s)</code></li><li><code>GILobattoIIIF(s)</code></li><li><code>GISRK3</code> - 3-stage order 4 symmetric Runge-Kutta method</li><li><code>GISSPRK3</code> - 3rd orer explicit SSP method</li><li>`GICrankNicholson</li><li><code>GIKraaijevangerSpijker</code></li><li><code>GIQinZhang</code></li><li><code>GICrouzeix</code></li><li><code>GIGLRK(s)</code> - Gauss-Legendre Runge-Kutta method of order 2s</li></ul><p>Note that all of these methods require the user supplies <code>dt</code>.</p><h3 id="BridgeDiffEq.jl"><a class="docs-heading-anchor" href="#BridgeDiffEq.jl">BridgeDiffEq.jl</a><a id="BridgeDiffEq.jl-1"></a><a class="docs-heading-anchor-permalink" href="#BridgeDiffEq.jl" title="Permalink"></a></h3><p>Bridge.jl is a set of fixed timestep algorithms written in Julia. These methods are made and optimized for out-of-place functions on immutable (static vector) types. Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use BridgeDiffEq.jl:</p><pre><code class="language-julia hljs">]add https://github.com/JuliaDiffEq/BridgeDiffEq.jl
using BridgeDiffEq</code></pre><ul><li><code>BridgeR3</code> - 3rd order Ralston method</li><li><code>BridgeBS3</code> - 3rd order Bogacki-Shampine method</li></ul><h3 id="TaylorIntegration.jl"><a class="docs-heading-anchor" href="#TaylorIntegration.jl">TaylorIntegration.jl</a><a id="TaylorIntegration.jl-1"></a><a class="docs-heading-anchor-permalink" href="#TaylorIntegration.jl" title="Permalink"></a></h3><p>TaylorIntegration.jl is a pure-Julia implementation of an adaptive order Taylor series method for high accuracy integration of ODEs. These methods are optimized when the absolute tolerance is required to be very low. Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use TaylorIntegration.jl:</p><pre><code class="language-julia hljs">]add TaylorIntegration
using TaylorIntegration</code></pre><ul><li><code>TaylorMethod(order)</code> - Taylor integration method with maximal <code>order</code> (required)</li></ul><p>Note: this method is much faster if you put <code>@taylorize</code> on your derivative function!</p><h3 id="QuDiffEq.jl"><a class="docs-heading-anchor" href="#QuDiffEq.jl">QuDiffEq.jl</a><a id="QuDiffEq.jl-1"></a><a class="docs-heading-anchor-permalink" href="#QuDiffEq.jl" title="Permalink"></a></h3><p>QuDiffEq.jl is a package for solving differential equations using quantum algorithm. It makes use of the Yao framework for simulating quantum circuits.</p><p>Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use QuDiffEq.jl:</p><pre><code class="language-julia hljs">]add https://github.com/QuantumBFS/QuDiffEq.jl
using QuDiffEq</code></pre><ul><li><code>QuLDE(k)</code> - Algorithm based on truncated Taylor series. The method linearizes a system of non-linear differential equations and solves the resultant by means of a quantum circuit. <code>k</code> selects the order in the Taylor series aprroximation (for the quantum circuit).</li><li><code>QuNLDE(k,ϵ)</code>- Algorithm uses forward Euler to solve quadratc differential equations. <code>k</code> selects the order in the Taylor series aprroximation (for the quantum circuit). <code>ϵ</code> sets the precision for Hamiltonian evolution.</li></ul><h3 id="NeuralPDE.jl"><a class="docs-heading-anchor" href="#NeuralPDE.jl">NeuralPDE.jl</a><a id="NeuralPDE.jl-1"></a><a class="docs-heading-anchor-permalink" href="#NeuralPDE.jl" title="Permalink"></a></h3><p>This method trains a neural network using Flux.jl to approximate the solution of the ODE. Currently this method isn&#39;t competitive but it is a fun curiosity that will be improved with future integration with Zygote.</p><p>Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use NeuralPDE.jl:</p><pre><code class="language-julia hljs">]add NeuralPDE
using NeuralPDE</code></pre><ul><li><code>nnode(chain,opt=ADAM(0.1))</code> - Defines a neural network solver which utilizes a Flux.jl <code>chain</code> under the hood which must be supplied by the user. Defaults to using the ADAM optimization method, but the user can pass any Flux.jl optimizer.</li></ul><h3 id="List-of-Supplied-Tableaus"><a class="docs-heading-anchor" href="#List-of-Supplied-Tableaus">List of Supplied Tableaus</a><a id="List-of-Supplied-Tableaus-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-Supplied-Tableaus" title="Permalink"></a></h3><p>A large variety of tableaus have been supplied by default, via DiffEqDevTools.jl. The list of tableaus can be found in <a href="https://devdocs.juliadiffeq.org/dev/internals/tableaus/">the developer docs</a>. To use them, note you must install the library:</p><pre><code class="language-julia hljs">]add DiffEqDevTools
using DiffEqDevTools</code></pre><p>For the most useful and common algorithms, a hand-optimized version is supplied in OrdinaryDiffEq.jl which is recommended for general uses (i.e. use <code>DP5</code> instead of <code>ExplicitRK</code> with <code>tableau=constructDormandPrince()</code>). However, these serve as a good method for comparing between tableaus and understanding the pros/cons of the methods. Implemented are every published tableau (that I know exists). Note that user-defined tableaus also are accepted. To see how to define a tableau, checkout the <a href="https://github.com/JuliaDiffEq/DiffEqDevTools.jl/blob/master/src/ode_tableaus.jl">premade tableau source code</a>. Tableau docstrings should have appropriate citations (if not, file an issue).</p><p>Plot recipes are provided which will plot the stability region for a given tableau.</p><h3 id="ProbNumDiffEq.jl"><a class="docs-heading-anchor" href="#ProbNumDiffEq.jl">ProbNumDiffEq.jl</a><a id="ProbNumDiffEq.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ProbNumDiffEq.jl" title="Permalink"></a></h3><p>ProbNumDiffEq.jl provides <em>probabilistic</em> numerical solvers for ODEs. By casting the solution of ODEs as a problem of Bayesian inference, they return a posterior probability distribution over ODE solutions and thereby provide estimates of their own numerical approximation error. The solvers have adaptive timestepping, their order can be freely specified, and the returned posterior distribution naturally enables dense output and sampling. The full documentation is available at <a href="https://nathanaelbosch.github.io/ProbNumDiffEq.jl/stable/">ProbNumDiffEq.jl</a>.</p><p>Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use ProbNumDiffEq.jl:</p><pre><code class="language-julia hljs">]add ProbNumDiffEq
using ProbNumDiffEq</code></pre><ul><li><code>EK1(order=3)</code> - A semi-implicit ODE solver based on extended Kalman filtering and smoothing with first order linearization. Recommended, but requires that the Jacobian of the vector field is specified.</li><li><code>EK0(order=3)</code> - An explicit ODE solver based on extended Kalman filtering and smoothing with zeroth order linearization.</li></ul><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Koskela, A. (2015). Approximating the matrix exponential of an advection-diffusion operator using the incomplete orthogonalization method. In Numerical Mathematics and Advanced Applications-ENUMATH 2013 (pp. 345-353). Springer, Cham.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../discrete_solve/">« Discrete Solvers</a><a class="docs-footer-nextpage" href="../nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group ODE Solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.16 on <span class="colophon-date" title="Monday 25 April 2022 10:29">Monday 25 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
