<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Continuous-Time Jump Processes and Gillespie Methods · DifferentialEquations.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://diffeq.sciml.ai/stable/tutorials/discrete_stochastic_example/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DifferentialEquations.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">DifferentialEquations.jl: Scientific Machine Learning (SciML) Enabled Simulation and Estimation</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../ode_example/">Ordinary Differential Equations</a></li><li><a class="tocitem" href="../faster_ode_example/">Code Optimization for Differential Equations</a></li><li><a class="tocitem" href="../advanced_ode_example/">Solving Large Stiff Equations</a></li><li><a class="tocitem" href="../sde_example/">Stochastic Differential Equations</a></li><li><a class="tocitem" href="../rode_example/">Random Ordinary Differential Equations</a></li><li><a class="tocitem" href="../dde_example/">Delay Differential Equations</a></li><li><a class="tocitem" href="../dae_example/">Differential Algebraic Equations</a></li><li class="is-active"><a class="tocitem" href>Continuous-Time Jump Processes and Gillespie Methods</a><ul class="internal"><li><a class="tocitem" href="#Illustrative-Model:-SIR-disease-dynamics"><span>Illustrative Model: SIR disease dynamics</span></a></li><li><a class="tocitem" href="#Defining-the-SIR-Model-using-Reactions-via-Catalyst"><span>Defining the SIR Model using Reactions via Catalyst</span></a></li><li><a class="tocitem" href="#Building-and-Simulating-the-Jump-Process-from-Catalyst-Models"><span>Building and Simulating the Jump Process from Catalyst Models</span></a></li><li><a class="tocitem" href="#Building-and-Simulating-the-Jump-Process-using-the-DiffEqJump-Low-level-Interface"><span>Building and Simulating the Jump Process using the DiffEqJump Low-level Interface</span></a></li><li><a class="tocitem" href="#ConstantRateJumpSect"><span>Defining the Jumps Directly: <code>ConstantRateJump</code></span></a></li><li><a class="tocitem" href="#SSAStepper"><span>SSAStepper</span></a></li><li><a class="tocitem" href="#save_positions_docs"><span>Reducing Memory Use: Controlling Saving Behavior</span></a></li><li><a class="tocitem" href="#MassActionJumpSect"><span>Defining the Jumps Directly: <code>MassActionJump</code></span></a></li><li><a class="tocitem" href="#Defining-the-Jumps-Directly:-Mixing-ConstantRateJump-and-MassActionJump"><span>Defining the Jumps Directly: Mixing <code>ConstantRateJump</code> and <code>MassActionJump</code></span></a></li><li><a class="tocitem" href="#Adding-Jumps-to-a-Differential-Equation"><span>Adding Jumps to a Differential Equation</span></a></li><li><a class="tocitem" href="#VariableRateJumpSect"><span>Adding a VariableRateJump</span></a></li><li><a class="tocitem" href="#RegularJumps-and-Tau-Leaping"><span>RegularJumps and Tau-Leaping</span></a></li><li><a class="tocitem" href="#FAQ"><span>FAQ</span></a></li></ul></li><li><a class="tocitem" href="../jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="tocitem" href="../bvp_example/">Boundary Value Problems</a></li><li><a class="tocitem" href="../additional/">Additional Tutorials</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../basics/common_solver_opts/">Common Solver Options</a></li><li><a class="tocitem" href="../../basics/solution/">Solution Handling</a></li><li><a class="tocitem" href="../../basics/plot/">Plot Functions</a></li><li><a class="tocitem" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="tocitem" href="../../basics/problem/">Problem Interface</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="tocitem">Problem Types</span><ul><li><a class="tocitem" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="tocitem" href="../../types/ode_types/">ODE Problems</a></li><li><a class="tocitem" href="../../types/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group Problems</a></li><li><a class="tocitem" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="tocitem" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="tocitem" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="tocitem" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="tocitem" href="../../types/sde_types/">SDE Problems</a></li><li><a class="tocitem" href="../../types/sdae_types/">SDAE Problems</a></li><li><a class="tocitem" href="../../types/rode_types/">RODE Problems</a></li><li><a class="tocitem" href="../../types/dde_types/">DDE Problems</a></li><li><a class="tocitem" href="../../types/sdde_types/">SDDE Problems</a></li><li><a class="tocitem" href="../../types/dae_types/">DAE Problems</a></li><li><a class="tocitem" href="../../types/jump_types/">Jump Problems</a></li></ul></li><li><span class="tocitem">Solver Algorithms</span><ul><li><a class="tocitem" href="../../solvers/discrete_solve/">Discrete Solvers</a></li><li><a class="tocitem" href="../../solvers/ode_solve/">ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/split_ode_solve/">Split ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/steady_state_solve/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/bvp_solve/">BVP Solvers</a></li><li><a class="tocitem" href="../../solvers/jump_solve/">Jump Problem and Jump Diffusion Solvers</a></li><li><a class="tocitem" href="../../solvers/sde_solve/">SDE Solvers</a></li><li><a class="tocitem" href="../../solvers/sdae_solve/">SDAE Solvers</a></li><li><a class="tocitem" href="../../solvers/rode_solve/">RODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dde_solve/">DDE Solvers</a></li><li><a class="tocitem" href="../../solvers/sdde_solve/">SDDE Solvers</a></li><li><a class="tocitem" href="../../solvers/dae_solve/">DAE Solvers</a></li><li><a class="tocitem" href="../../solvers/benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="tocitem">Additional Features</span><ul><li><a class="tocitem" href="../../features/performance_overloads/">Jacobians, Gradients, etc.</a></li><li><a class="tocitem" href="../../features/diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="tocitem" href="../../features/diffeq_operator/">DiffEqOperators</a></li><li><a class="tocitem" href="../../features/noise_process/">Noise Processes</a></li><li><a class="tocitem" href="../../features/linear_nonlinear/">Specifying (Non)Linear Solvers and Preconditioners</a></li><li><a class="tocitem" href="../../features/callback_functions/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../features/callback_library/">Callback Library</a></li><li><a class="tocitem" href="../../features/ensemble/">Parallel Ensemble Simulations</a></li><li><a class="tocitem" href="../../features/io/">I/O: Saving and Loading Solution Data</a></li><li><a class="tocitem" href="../../features/low_dep/">Low Dependency Usage</a></li><li><a class="tocitem" href="../../features/progress_bar/">Progress Bar Integration</a></li></ul></li><li><span class="tocitem">Analysis Tools</span><ul><li><a class="tocitem" href="../../analysis/parameterized_functions/">ParameterizedFunctions</a></li><li><a class="tocitem" href="../../analysis/parameter_estimation/">Parameter Estimation and Bayesian Analysis</a></li><li><a class="tocitem" href="../../analysis/bifurcation/">Bifurcation Analysis</a></li><li><a class="tocitem" href="../../analysis/sensitivity/">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li><a class="tocitem" href="../../analysis/global_sensitivity/">Global Sensitivity Analysis</a></li><li><a class="tocitem" href="../../analysis/uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="tocitem" href="../../analysis/neural_networks/">Neural Networks</a></li><li><a class="tocitem" href="../../analysis/dev_and_test/">Algorithm Development and Testing</a></li></ul></li><li><span class="tocitem">Domain Modeling Tools</span><ul><li><a class="tocitem" href="../../models/multiscale/">Multi-Scale Models</a></li><li><a class="tocitem" href="../../models/physical/">Physical Models</a></li><li><a class="tocitem" href="../../models/financial/">Financial Models</a></li><li><a class="tocitem" href="../../models/chemical_reactions/">Chemical Reactions</a></li><li><a class="tocitem" href="../../models/external_modeling/">External Modeling Packages</a></li></ul></li><li><span class="tocitem">Extra Details</span><ul><li><a class="tocitem" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li><li><a class="tocitem" href="../../extras/sensitivity_math/">Mathematics of Sensitivity Analysis</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Continuous-Time Jump Processes and Gillespie Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Continuous-Time Jump Processes and Gillespie Methods</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/DiffEqDocs.jl/blob/master/docs/src/tutorials/discrete_stochastic_example.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Continuous-Time-Jump-Processes-and-Gillespie-Methods"><a class="docs-heading-anchor" href="#Continuous-Time-Jump-Processes-and-Gillespie-Methods">Continuous-Time Jump Processes and Gillespie Methods</a><a id="Continuous-Time-Jump-Processes-and-Gillespie-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Continuous-Time-Jump-Processes-and-Gillespie-Methods" title="Permalink"></a></h1><p>In this tutorial we will describe how to define and simulate continuous-time jump processes, also known in biological fields as stochastic chemical kinetics (i.e. Gillespie) models. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This tutorial assumes you have read the <a href="../ode_example/#ode_example">Ordinary Differential Equations tutorial</a>. </p></div></div><p>The discrete stochastic simulations we consider are a form of jump equation with a &quot;trivial&quot; (non-existent) differential equation. We will first demonstrate how to build these types of models using the biological modeling functionality of <a href="https://github.com/SciML/Catalyst.jl">Catalyst.jl</a>, then describe how to build them directly and more generally using <a href="https://github.com/SciML/DiffEqJump.jl">DiffEqJump.jl</a> jump types, and finally show how to couple discrete stochastic simulations to differential equation models.</p><h2 id="Illustrative-Model:-SIR-disease-dynamics"><a class="docs-heading-anchor" href="#Illustrative-Model:-SIR-disease-dynamics">Illustrative Model: SIR disease dynamics</a><a id="Illustrative-Model:-SIR-disease-dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Illustrative-Model:-SIR-disease-dynamics" title="Permalink"></a></h2><p>To illustrate the jump process solvers, we will build an SIR model which matches the tutorial from <a href="https://github.com/sdwfrost/Gillespie.jl">Gillespie.jl</a>. SIR stands for susceptible, infected, and recovered, and is a model of disease spread. When a susceptible person comes in contact with an infected person, the disease has a chance of infecting the susceptible person. This &quot;chance&quot; is determined by the number of susceptible persons and the number of infected persons, since in larger populations there is a greater chance that two people come into contact. Every infected person will in turn have a rate at which they recover. In our model we&#39;ll assume there are no births or deaths, and a recovered individual is protected from reinfection.</p><p>We&#39;ll begin by giving the mathematical equations for the jump processes of the number of susceptible (<span>$S(t)$</span>), number of infected (<span>$I(t)$</span>), and number of recovered (<span>$R(t)$</span>). In the next section we give a more intuitive and biological description of the model for users that are less familiar with jump processes. Let <span>$Y_i(t)$</span>, <span>$i = 1,2$</span>, denote independent unit Poisson processes. Our basic mathematical model for the evolution of <span>$(S(t),I(t),R(t))$</span>, written using Kurtz&#39;s time-change representation, is then</p><p class="math-container">\[\begin{aligned}
S(t) &amp;= S(0) - Y_1\left(  \int_0^t \beta S(s^{-}) I(s^{-}) \, ds\right) \\
I(t) &amp;= I(0) + Y_1\left(  \int_0^t \beta S(s^{-}) I(s^{-}) \, ds\right) 
        - Y_2 \left( \int_0^t \nu I(s^-)  \, ds \right) \\
R(t) &amp;= R(0) + Y_2 \left( \int_0^t \nu I(s^-)  \, ds \right)
\end{aligned}\]</p><p>Notice, our model involves two jumps with rate functions, also known as intensities or propensities, given by <span>$\beta S(t) I(t)$</span> and <span>$\nu I(t)$</span> respectively. These model the infection of susceptible individuals and recovery of infected individuals.</p><h2 id="Defining-the-SIR-Model-using-Reactions-via-Catalyst"><a class="docs-heading-anchor" href="#Defining-the-SIR-Model-using-Reactions-via-Catalyst">Defining the SIR Model using Reactions via Catalyst</a><a id="Defining-the-SIR-Model-using-Reactions-via-Catalyst-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-SIR-Model-using-Reactions-via-Catalyst" title="Permalink"></a></h2><p>For those less-familiar with the time-change representation, we now give a more intuitive explanation of the model, and then demonstrate how it can be written as a serious of chemical reactions in <a href="https://github.com/SciML/Catalyst.jl">Catalyst.jl</a> and seamlessly converted into a form that can be used with the <a href="https://github.com/SciML/DiffEqJump.jl">DiffEqJump.jl</a> solvers. Users interested in how to directly define jumps using the lower-level DiffEqJump interface can skip to <a href="#Building-and-Simulating-the-Jump-Process-using-the-DiffEqJump-Low-level-Interface">Building and Simulating the Jump Process using the DiffEqJump Low-level Interface</a>.</p><p>The SIR model described above involves two basic chemical reactions,</p><p class="math-container">\[\begin{aligned}
S + I &amp;\overset{\beta}{\to} 2 I \\
I &amp;\overset{\nu}{\to} R,
\end{aligned}\]</p><p>where <span>$\beta$</span> and <span>$\nu$</span> are the rate constants of the reactions (with units of probability per time). In a jump process (stochastic chemical kinetics) model, we keep track of the non-negative integer number of each species at each time (i.e. <span>$(S(t), I(t), R(t))$</span> above). Each reaction has an associated rate function (i.e. intensity or propensity) giving the probability per time it can occur when the system is in state <span>$(S(t),I(t),R(t))$</span>:</p><p class="math-container">\[\begin{matrix}
\text{Reaction} &amp; \text{Rate Functions} \\
\hline
S + I \overset{\beta}{\to} 2 I &amp; \beta S(t) I(t) \\
I \overset{\nu}{\to} R &amp; \nu I(t).
\end{matrix}\]</p><p><span>$\beta$</span> is determined by factors like the type of the disease. It can be interpreted as the probability per time one pair of susceptible and infected people encounter each other, with the susceptible person becoming sick. The overall rate (i.e. probability per time) that some susceptible person gets sick is then given by the rate constant multiplied by the number of possible pairs of susceptible and infected people. This formulation is known as the <a href="https://en.wikipedia.org/wiki/Law_of_mass_action">law of mass action</a>. Similarly, we have that each individual infected person is assumed to recover with probability per time <span>$\nu$</span>, so that the probability per time <em>some</em> infected person becomes recovered is <span>$\nu$</span> times the number of infected people, i.e. <span>$\nu I(t)$</span>. </p><p>Rate functions give the probability per time for each of the two types of jumps to occur, and hence determine when the state of our system changes. To fully specify our model we also need to specify how the state changes when a jump occurs, giving what are called <code>affect</code> functions in DiffEqJump. For example, when the <span>$S + I \to 2 I$</span> reaction occurs and some susceptible person becomes infected, the subsequent (instantaneous) state change is that</p><p class="math-container">\[\begin{aligned}
S &amp;\to S - 1 &amp; I &amp;\to I + 1.
\end{aligned}\]</p><p>Likewise, when the <span>$I \to R$</span> reaction occurs so that some infected person becomes recovered the state change is</p><p class="math-container">\[\begin{aligned}
I &amp;\to I - 1 &amp; R \to R + 1.
\end{aligned}\]</p><p>Using <a href="https://github.com/SciML/Catalyst.jl">Catalyst.jl</a> we can input our full reaction network in a form that can be easily used with DiffEqJump&#39;s solvers:</p><pre><code class="language-julia hljs"># ]add Catalyst
using Catalyst
sir_model = @reaction_network begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end β ν</code></pre><p>Notice that the order the variables are introduced in the model is <code>S</code>, then <code>I</code>, then <code>R</code>, and thus this is the canonical ordering of the variables.</p><h2 id="Building-and-Simulating-the-Jump-Process-from-Catalyst-Models"><a class="docs-heading-anchor" href="#Building-and-Simulating-the-Jump-Process-from-Catalyst-Models">Building and Simulating the Jump Process from Catalyst Models</a><a id="Building-and-Simulating-the-Jump-Process-from-Catalyst-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Building-and-Simulating-the-Jump-Process-from-Catalyst-Models" title="Permalink"></a></h2><p>First, we have to define some kind of differential equation that we can &quot;solve&quot; to simulate the jump process. Since we want integer, discrete changes in the numbers of the different types of people, we will build a <code>DiscreteProblem</code>. We do this by giving the constructor <code>u0</code>, the initial condition, and <code>tspan</code>, the timespan. Here, we will start with <code>999</code> susceptible people, <code>1</code> infected person, and <code>0</code> recovered people, and solve the problem from <code>t=0.0</code> to <code>t=250.0</code>. We use the parameters <code>β = 0.1/1000</code> and <code>ν = 0.01</code>. Thus we build the problem via:</p><pre><code class="language-julia hljs">p     = (0.1/1000,0.01)   
u₀    = [999,1,0]
tspan = (0.0,250.0)
prob  = DiscreteProblem(sir_model, u₀, tspan, p)</code></pre><p><em>Notice, the initial populations are integers since we want the exact number of people in the different states.</em></p><p>The Catalyst reaction network can be converted into various DifferentialEquations.jl problem types, including <code>JumpProblem</code>s, <code>ODEProblem</code>s, or <code>SDEProblem</code>s. To turn it into a jump problem representing the SIR jump process model, we load DiffEqJump and simply do:</p><pre><code class="language-julia hljs">using DiffEqJump
jump_prob = JumpProblem(sir_model, prob, Direct())</code></pre><p>Here <code>Direct()</code> indicates that we will determine the random times and types of reactions using <a href="https://doi.org/10.1016/0021-9991(76)90041-3">Gillespie&#39;s Direct stochastic simulation algorithm (SSA)</a>. See <a href="../../types/jump_types/#Constant-Rate-Jump-Aggregators">Constant Rate Jump Aggregators</a> below for other supported SSAs.</p><p>We now have a problem that can be evolved in time using the DiffEqJump solvers. Since our model is a pure jump process (no continuously-varying components), we will use <code>SSAStepper()</code> to handle time-stepping the <code>Direct</code> method from jump to jump:</p><pre><code class="language-julia hljs">sol = solve(jump_prob, SSAStepper())</code></pre><p>This solve command takes the standard commands of the common interface, and the solution object acts just like any other differential equation solution. Thus there exists a plot recipe, which we can plot with:</p><pre><code class="language-julia hljs">using Plots; plot(sol)</code></pre><p><img src="../../assets/SIR.png" alt="SIR Solution"/></p><h2 id="Building-and-Simulating-the-Jump-Process-using-the-DiffEqJump-Low-level-Interface"><a class="docs-heading-anchor" href="#Building-and-Simulating-the-Jump-Process-using-the-DiffEqJump-Low-level-Interface">Building and Simulating the Jump Process using the DiffEqJump Low-level Interface</a><a id="Building-and-Simulating-the-Jump-Process-using-the-DiffEqJump-Low-level-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Building-and-Simulating-the-Jump-Process-using-the-DiffEqJump-Low-level-Interface" title="Permalink"></a></h2><p>We now show how to directly use DiffEqJump&#39;s low-level interface to construct and solve our jump process model for <span>$(S(t),I(t),R(t))$</span>. Each individual jump that can occur is represented through specifying two pieces of information; a <code>rate</code> function (i.e. intensity or propensity) for the jump and an <code>affect</code> function for the jump. The former gives the probability per time a particular jump can occur given the current state of the system, and hence determines the time at which jumps can happen. The later specifies the instantaneous change in the state of the system when the jump occurs. </p><p>In our SIR model we have two possible jumps that can occur (one for susceptibles becoming infected and one for infected becoming recovered), with the corresponding (mathematical) rates and affects given by</p><p class="math-container">\[\begin{matrix}
\text{Rates} &amp; \text{Affects}\\
\hline 
\beta S(t) I(t) &amp; S \to S - 1,\, I \to I + 1 \\
\nu I(t) &amp; I \to I - 1, \, R \to R + 1.
\end{matrix}\]</p><p>DiffEqJump offers three different ways to represent jumps: <code>MassActionJump</code>, <code>ConstantRateJump</code>, and <code>VariableRateJump</code>. Choosing which to use is a trade off between the desired generality of the <code>rate</code> and <code>affect</code> functions vs. the computational performance of the resulting simulated system. In general</p><table><tr><th style="text-align: center">Jump Type</th><th style="text-align: center">Performance</th><th style="text-align: center">Generality</th></tr><tr><td style="text-align: center"><a href="#MassActionJumpSect"><code>MassActionJump</code></a></td><td style="text-align: center">Fastest</td><td style="text-align: center">Restrictive rates/affects</td></tr><tr><td style="text-align: center"><a href="#ConstantRateJumpSect"><code>ConstantRateJump</code></a></td><td style="text-align: center">Somewhat Slower</td><td style="text-align: center">Much more general</td></tr><tr><td style="text-align: center"><a href="#VariableRateJumpSect"><code>VariableRateJump</code></a></td><td style="text-align: center">Slowest</td><td style="text-align: center">Completely general</td></tr></table><p>It is recommended to try to encode jumps using the most performant option that supports the desired generality of the underlying <code>rate</code> and <code>affect</code> functions. Below we describe the different jump types, and show how the SIR model can be formulated using first <code>ConstantRateJump</code>s and then <code>MassActionJump</code>s (<code>VariableRateJump</code>s are considered later).</p><h2 id="ConstantRateJumpSect"><a class="docs-heading-anchor" href="#ConstantRateJumpSect">Defining the Jumps Directly: <code>ConstantRateJump</code></a><a id="ConstantRateJumpSect-1"></a><a class="docs-heading-anchor-permalink" href="#ConstantRateJumpSect" title="Permalink"></a></h2><p>The constructor for a <code>ConstantRateJump</code> is:</p><pre><code class="language-julia hljs">jump = ConstantRateJump(rate, affect!)</code></pre><p>where <code>rate</code> is a function <code>rate(u,p,t)</code> and <code>affect!</code> is a function of the integrator <code>affect!(integrator)</code> (for details on the integrator, see the <a href="../../basics/integrator/#integrator">integrator interface docs</a>). Here <code>u</code> corresponds to the current state of the system; for our SIR model <code>u[1]=S(t)</code>, <code>u[2]=I(t)</code> and <code>u[3]=R(t)</code>. <code>p</code> corresponds to the parameters of the model, just as used for passing parameters to derivative functions in ODE solvers. Thus, to define the two possible jumps for our model we take (with <code>β=.1/1000.0</code> and <code>ν=.01</code>).</p><pre><code class="language-julia hljs">using DiffEqJump
β = 0.1 / 1000.0; ν = .01;
p = (β,ν)
rate1(u,p,t) = p[1]*u[1]*u[2]  # β*S*I
function affect1!(integrator)
  integrator.u[1] -= 1         # S -&gt; S - 1
  integrator.u[2] += 1         # I -&gt; I + 1
end
jump = ConstantRateJump(rate1,affect1!)

rate2(u,p,t) = p[2]*u[2]      # ν*I
function affect2!(integrator)
  integrator.u[2] -= 1        # I -&gt; I - 1
  integrator.u[3] += 1        # R -&gt; R + 1
end
jump2 = ConstantRateJump(rate2,affect2!)</code></pre><p>We will start with <code>999</code> susceptible people, <code>1</code> infected person, and <code>0</code> recovered people, and solve the problem from <code>t=0.0</code> to <code>t=250.0</code> so that</p><pre><code class="language-julia hljs">u₀    = [999,1,0]
tspan = (0.0,250.0)</code></pre><p><em>Notice, the initial populations are integers since we want the exact number of people in the different states.</em></p><p>Since we want integer, discrete changes in the numbers of the different types of people, we will build a <code>DiscreteProblem</code>. </p><pre><code class="language-julia hljs">prob = DiscreteProblem(u₀, tspan, p)</code></pre><p>We can then use <code>JumpProblem</code> from DiffEqJump to augment the discrete problem with jumps and select the stochastic simulation algorithm (SSA) to use in sampling the jump processes. To create a <code>JumpProblem</code> we would simply do:</p><pre><code class="language-julia hljs">jump_prob = JumpProblem(prob, Direct(), jump, jump2)</code></pre><p>Here <code>Direct()</code> indicates that we will determine the random times and types of jumps that occur using <a href="https://doi.org/10.1016/0021-9991(76)90041-3">Gillespie&#39;s Direct stochastic simulation algorithm (SSA)</a>. See <a href="../../types/jump_types/#Constant-Rate-Jump-Aggregators">Constant Rate Jump Aggregators</a> for other supported SSAs.</p><p>We now have a problem that can be evolved in time using the DiffEqJump solvers. Since our model is a pure jump process (no continuously-varying components), we will use <code>SSAStepper()</code> to handle time-stepping the <code>Direct</code> method from jump to jump:</p><pre><code class="language-julia hljs">sol = solve(jump_prob, SSAStepper())</code></pre><p>This solve command takes the standard commands of the common interface, and the solution object acts just like any other differential equation solution. Thus there exists a plot recipe, which we can plot with:</p><pre><code class="language-julia hljs">using Plots; plot(sol)</code></pre><p><img src="../../assets/SIR.png" alt="SIR Solution"/></p><p>Note, in systems with more than a few jumps (more than ~10), it can be advantageous to use more sophisticated SSAs than <code>Direct</code>. For such systems it is recommended to use <code>SortingDirect</code>, <code>RSSA</code> or <code>RSSACR</code>, see the list of DiffEqJump SSAs at <a href="../../types/jump_types/#Constant-Rate-Jump-Aggregators">Constant Rate Jump Aggregators</a>.</p><h3 id="*Caution-about-Constant-Rate-Jumps*"><a class="docs-heading-anchor" href="#*Caution-about-Constant-Rate-Jumps*"><em>Caution about Constant Rate Jumps</em></a><a id="*Caution-about-Constant-Rate-Jumps*-1"></a><a class="docs-heading-anchor-permalink" href="#*Caution-about-Constant-Rate-Jumps*" title="Permalink"></a></h3><p><code>ConstantRateJump</code>s are quite general, but they do have one restriction. They assume that the rate functions are constant at all times between two consecutive jumps of the system. i.e. any species/states or parameters that the rate function depends on must not change between the times at which two consecutive jumps occur. Such conditions are violated if one has a time dependent parameter like <span>$\beta(t)$</span> or if some of the solution components, say <code>u[2]</code>, may also evolve through a coupled ODE or SDE (see below for examples). For problems where the rate function may change between consecutive jumps, <code>VariableRateJump</code>s must be used.</p><p>Thus in the examples above,</p><pre><code class="language-julia hljs">rate1(u,p,t) = p[1]*u[1]*u[2]
rate2(u,p,t) = p[2]*u[2]</code></pre><p>both must be constant other than changes due to some other <code>ConstantRateJump</code> or <code>MassActionJump</code> (the same restriction applies to <code>MassActionJump</code>s). Since these rates only change when <code>u[1]</code> or <code>u[2]</code> is changed, and <code>u[1]</code> and <code>u[2]</code> only change when one of the jumps occur, this setup is valid. However, a rate of <code>t*p[1]*u[1]*u[2]</code> would not be valid because the rate would change during the interval, as would <code>p[2]*u[1]*u[4]</code> when <code>u[4]</code> is the solution to a continuous problem such as an ODE or SDE. Thus one must be careful to follow this rule when choosing rates.</p><p>If your problem must have the rates depend on a continuously changing quantity, you need to use the <code>VariableRateJump</code>.</p><h2 id="SSAStepper"><a class="docs-heading-anchor" href="#SSAStepper">SSAStepper</a><a id="SSAStepper-1"></a><a class="docs-heading-anchor-permalink" href="#SSAStepper" title="Permalink"></a></h2><p>Any common interface algorithm can be used to perform the time-stepping since it is implemented over the callback interface. This allows for hybrid systems that mix ODEs, SDEs and jumps. In many cases we may have a pure jump system that only involves <code>ConstantRateJump</code>s and/or <code>MassActionJump</code>s (see below). When that&#39;s the case, a substantial performance benefit may be gained by using <code>SSAStepper()</code>. Note, <code>SSAStepper</code> is a more limited time-stepper which only supports discrete events, and does not allow simultaneous coupled ODEs or SDEs. It is, however, very efficient for pure jump problems.</p><h2 id="save_positions_docs"><a class="docs-heading-anchor" href="#save_positions_docs">Reducing Memory Use: Controlling Saving Behavior</a><a id="save_positions_docs-1"></a><a class="docs-heading-anchor-permalink" href="#save_positions_docs" title="Permalink"></a></h2><p>Note that jumps act via the callback interface which defaults to saving at each event. The reason is because this is required in order to accurately resolve every discontinuity exactly (and this is what allows for perfectly vertical lines in plots!). However, in many cases when using jump problems you may wish to decrease the saving pressure given by large numbers of jumps. To do this, you set <code>save_positions</code> in the <code>JumpProblem</code>. Just like for other callbacks, this is a tuple <code>(bool1,bool2)</code> which sets whether to save before or after a jump. If we do not want to save at every jump, we would thus pass:</p><pre><code class="language-julia hljs">jump_prob = JumpProblem(prob, Direct(), jump, jump2, save_positions=(false,false))</code></pre><p>Now the saving controls associated with the integrator are the only ones to note. For example, we can use <code>saveat=0.5</code> to save at an evenly spaced grid:</p><pre><code class="language-julia hljs">sol = solve(jump_prob, SSAStepper(), saveat=0.5)</code></pre><h2 id="MassActionJumpSect"><a class="docs-heading-anchor" href="#MassActionJumpSect">Defining the Jumps Directly: <code>MassActionJump</code></a><a id="MassActionJumpSect-1"></a><a class="docs-heading-anchor-permalink" href="#MassActionJumpSect" title="Permalink"></a></h2><p>For jumps that can be represented as mass action reactions, a further specialization of the jump type is possible that offers improved computational performance; <code>MassActionJump</code>. Suppose the system has <span>$N$</span> chemical species <span>$\{S_1,\dots,S_N\}$</span>. A general mass action reaction has the form</p><p class="math-container">\[R_1 S_1 + R_2 S_2 + \dots + R_N S_N \overset{k}{\rightarrow} P_1 S_1 + P_2 S_2 + \dots + P_N S_N\]</p><p>where the non-negative integers <span>$(R_1,\dots,R_N)$</span> denote the <em>reactant stoichiometry</em> of the reaction, and the non-negative integers <span>$(P_1,\dots,P_N)$</span> the <em>product stoichiometry</em>. The <em>net stoichiometry</em> is the net change in each chemical species from the reaction occurring one time, given by <span>$(P_1-R_1,\dots,P_N-R_N)$</span>.</p><p>As an example, consider again the SIR model defined in the <code>@reaction_network</code> above. The species are then <code>(S,I,R)</code>. The first reaction has rate <code>β</code>, reactant stoichiometry <code>(1,1,0)</code>, product stoichiometry <code>(0,2,0)</code>, and net stoichiometry <code>(-1,1,0)</code>. The second reaction has rate <code>ν</code>, reactant stoichiometry <code>(0,1,0)</code>, product stoichiometry <code>(0,0,1)</code>, and net stoichiometry <code>(0,-1,1)</code>.</p><p>We can manually encode this system as a mass action jump by specifying the indexes of the rate constants in <code>p</code>, the reactant stoichiometry, and the net stoichiometry as follows:</p><pre><code class="language-julia hljs">rateidxs = [1, 2]    # i.e. [β,ν]
reactant_stoich =
[
  [1 =&gt; 1, 2 =&gt; 1],         # 1*S and 1*I
  [2 =&gt; 1]                  # 1*I
]
net_stoich =
[
  [1 =&gt; -1, 2 =&gt; 1],        # -1*S and 1*I
  [2 =&gt; -1, 3 =&gt; 1]         # -1*I and 1*R
]
mass_act_jump = MassActionJump(reactant_stoich, net_stoich; param_idxs=rateidxs)</code></pre><p>Notice, one typically should define one <code>MassActionJump</code> that encodes each possible jump that can be represented via a mass action reaction. This is in contrast to <code>ConstantRateJump</code>s or <code>VariableRateJump</code>s where separate instances are created for each distinct jump type.</p><p>Just like for <code>ConstantRateJumps</code>, to then simulate the system we create a <code>JumpProblem</code> and call <code>solve</code>:</p><pre><code class="language-julia hljs">jump_prob = JumpProblem(prob, Direct(), mass_act_jump)
sol = solve(jump_prob, SSAStepper())</code></pre><p>For more details about MassActionJumps see <a href="../../types/jump_types/#Defining-a-Mass-Action-Jump">Defining a Mass Action Jump</a>. </p><p>Note, for chemical reaction systems, Catalyst.jl automatically groups reactions into their optimal jump representation.</p><h2 id="Defining-the-Jumps-Directly:-Mixing-ConstantRateJump-and-MassActionJump"><a class="docs-heading-anchor" href="#Defining-the-Jumps-Directly:-Mixing-ConstantRateJump-and-MassActionJump">Defining the Jumps Directly: Mixing <code>ConstantRateJump</code> and <code>MassActionJump</code></a><a id="Defining-the-Jumps-Directly:-Mixing-ConstantRateJump-and-MassActionJump-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-Jumps-Directly:-Mixing-ConstantRateJump-and-MassActionJump" title="Permalink"></a></h2><p>Suppose we now want to add in to the SIR model another jump that can not be represented as a mass action reaction. We can create a new <code>ConstantRateJump</code> and simulate a hybrid system using both the <code>MassActionJump</code> for the two previous reactions, and the new <code>ConstantRateJump</code>. Let&#39;s suppose we want to let susceptible people be born with the following jump rate:</p><pre><code class="language-julia hljs">birth_rate(u,p,t) = 10.0*u[1]/(200. + u[1]) + 10.
function birth_affect!(integrator)
  integrator.u[1] += 1
end
birth_jump = ConstantRateJump(birth_rate, birth_affect!)</code></pre><p>We can then simulate the hybrid system as</p><pre><code class="language-julia hljs">jump_prob = JumpProblem(prob, Direct(), mass_act_jump, birth_jump)
sol = solve(jump_prob, SSAStepper())</code></pre><p><img src="../../assets/gillespie_hybrid_jumps.png" alt="gillespie_hybrid_jumps"/></p><h2 id="Adding-Jumps-to-a-Differential-Equation"><a class="docs-heading-anchor" href="#Adding-Jumps-to-a-Differential-Equation">Adding Jumps to a Differential Equation</a><a id="Adding-Jumps-to-a-Differential-Equation-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Jumps-to-a-Differential-Equation" title="Permalink"></a></h2><p>If we instead used some form of differential equation instead of a <code>DiscreteProblem</code>, we would couple the jumps/reactions to the differential equation. Let&#39;s define an ODE problem, where the continuous part only acts on some new 4th component:</p><pre><code class="language-julia hljs">using OrdinaryDiffEq
function f(du,u,p,t)
  du[4] = u[2]*u[3]/100000 - u[1]*u[4]/100000
end
u₀   = [999.0,1.0,0.0,100.0]
prob = ODEProblem(f,u₀,tspan,p)</code></pre><p>Notice we gave the 4th component a starting value of 100.0, and used floating point numbers for the initial condition since some solution components now evolve continuously. The same steps as above will allow us to solve this hybrid equation when using <code>ConstantRateJumps</code> (or <code>MassActionJump</code>s). For example, we can solve it using the <code>Tsit5()</code> method via:</p><pre><code class="language-julia hljs">jump_prob = JumpProblem(prob,Direct(),jump,jump2)
sol = solve(jump_prob,Tsit5())</code></pre><p><img src="../../assets/gillespie_ode.png" alt="gillespie_ode"/></p><h2 id="VariableRateJumpSect"><a class="docs-heading-anchor" href="#VariableRateJumpSect">Adding a VariableRateJump</a><a id="VariableRateJumpSect-1"></a><a class="docs-heading-anchor-permalink" href="#VariableRateJumpSect" title="Permalink"></a></h2><p>Now let&#39;s consider adding a reaction whose rate changes continuously with the differential equation. To continue our example, let&#39;s let there be a new jump/reaction with rate depending on <code>u[4]</code></p><pre><code class="language-julia hljs">rate3(u,p,t) = 1e-2*u[4]
function affect3!(integrator)
  integrator.u[2] += 1
end
jump3 = VariableRateJump(rate3,affect3!)</code></pre><p>Notice, since <code>rate3</code> depends on a variable that evolves continuously, and hence is not constant between jumps, we must use a <code>VariableRateJump</code>.</p><p>Solving the equation is exactly the same:</p><pre><code class="language-julia hljs">u₀   = [999.0,1.0,0.0,1.0]
prob = ODEProblem(f,u₀,tspan,p)
jump_prob = JumpProblem(prob,Direct(),jump,jump2,jump3)
sol = solve(jump_prob,Tsit5())</code></pre><p><img src="../../assets/variable_rate_gillespie.png" alt="variable_rate_gillespie"/></p><p><em>Note that <code>VariableRateJump</code>s require a continuous problem, like an ODE/SDE/DDE/DAE problem.</em></p><p>Lastly, we are not restricted to ODEs. For example, we can solve the same jump problem except with multiplicative noise on <code>u[4]</code> by using an <code>SDEProblem</code> instead:</p><pre><code class="language-julia hljs">using StochasticDiffEq
function g(du,u,p,t)
  du[4] = 0.1u[4]
end

prob = SDEProblem(f,g,[999.0,1.0,0.0,1.0],(0.0,250.0), p)
jump_prob = JumpProblem(prob,Direct(),jump,jump2,jump3)
sol = solve(jump_prob,SRIW1())</code></pre><p><img src="../../assets/sde_gillespie.png" alt="sde_gillespie"/></p><p>For more details about <code>VariableRateJump</code>s see <a href="../../types/jump_types/#Defining-a-Variable-Rate-Jump">Defining a Variable Rate Jump</a>.</p><h2 id="RegularJumps-and-Tau-Leaping"><a class="docs-heading-anchor" href="#RegularJumps-and-Tau-Leaping">RegularJumps and Tau-Leaping</a><a id="RegularJumps-and-Tau-Leaping-1"></a><a class="docs-heading-anchor-permalink" href="#RegularJumps-and-Tau-Leaping" title="Permalink"></a></h2><p>The previous parts described how to use <code>ConstantRateJump</code>s, <code>MassActionJump</code>s, and <code>VariableRateJump</code>s to add jumps to differential equation algorithms over the callback interface. However, in many cases you do not need to step to every jump time. Instead, regular jumping allows you to pool together jumps and perform larger updates in a statistically-correct but more efficient manner.</p><p>For <code>RegularJump</code>s, we pool together the jumps we wish to perform. Here our <code>rate</code> is a vector equation which computes the rates of each jump process together:</p><pre><code class="language-julia hljs">function rate(out,u,p,t)
    out[1] = (0.1/1000.0)*u[1]*u[2]
    out[2] = 0.01u[2]
end</code></pre><p>and then we compute the total change matrix <code>c</code></p><pre><code class="language-julia hljs">function c(dc,u,p,t,mark)
    dc[1,1] = -1
    dc[2,1] = 1
    dc[2,2] = -1
    dc[3,2] = 1
end</code></pre><p>where each column is a different jump process. We then declare the form of <code>dc</code> and build a <code>RegularJump</code>:</p><pre><code class="language-julia hljs">dc = zeros(3,2)
rj = RegularJump(rate,c,dc;constant_c=true)</code></pre><p>From there we build a <code>JumpProblem</code>:</p><pre><code class="language-julia hljs">prob = DiscreteProblem([999.0,1.0,0.0],(0.0,250.0))
jump_prob = JumpProblem(prob,Direct(),rj)</code></pre><p>Note that when a <code>JumpProblem</code> has a <code>RegularJump</code>, special algorithms are required. This is detailed on <a href="../../solvers/jump_solve/#jump_solve">the jump solvers page</a>. One such algorithm is <code>SimpleTauLeaping</code>, which we use as follows:</p><pre><code class="language-julia hljs">sol = solve(jump_prob,SimpleTauLeaping();dt=1.0)</code></pre><h2 id="FAQ"><a class="docs-heading-anchor" href="#FAQ">FAQ</a><a id="FAQ-1"></a><a class="docs-heading-anchor-permalink" href="#FAQ" title="Permalink"></a></h2><h4 id="*1.-My-simulation-is-really-slow-and/or-using-a-lot-of-memory,-what-can-I-do?*"><a class="docs-heading-anchor" href="#*1.-My-simulation-is-really-slow-and/or-using-a-lot-of-memory,-what-can-I-do?*"><em>1. My simulation is really slow and/or using a lot of memory, what can I do?</em></a><a id="*1.-My-simulation-is-really-slow-and/or-using-a-lot-of-memory,-what-can-I-do?*-1"></a><a class="docs-heading-anchor-permalink" href="#*1.-My-simulation-is-really-slow-and/or-using-a-lot-of-memory,-what-can-I-do?*" title="Permalink"></a></h4><p>To reduce memory use, use <code>save_positions=(false,false)</code> in the <code>JumpProblem</code> constructor as described <a href="#save_positions_docs">earlier</a> to turn off saving the system state before and after every jump. Combined with use of <code>saveat</code> in the call to <code>solve</code> this can dramatically reduce memory usage.</p><p>While <code>Direct</code> is often fastest for systems with 10 or less <code>ConstantRateJump</code>s or <code>MassActionJump</code>s, if your system has many jumps or one jump occurs most frequently, other stochastic simulation algorithms may be faster. See <a href="../../types/jump_types/#Constant-Rate-Jump-Aggregators">Constant Rate Jump Aggregators</a> and the subsequent sections there for guidance on choosing different SSAs (called aggregators in DiffEqJump).</p><h4 id="*2.-When-running-many-consecutive-simulations,-for-example-within-an-EnsembleProblem-or-loop,-how-can-I-update-JumpProblems?*"><a class="docs-heading-anchor" href="#*2.-When-running-many-consecutive-simulations,-for-example-within-an-EnsembleProblem-or-loop,-how-can-I-update-JumpProblems?*"><em>2. When running many consecutive simulations, for example within an <code>EnsembleProblem</code> or loop, how can I update <code>JumpProblem</code>s?</em></a><a id="*2.-When-running-many-consecutive-simulations,-for-example-within-an-EnsembleProblem-or-loop,-how-can-I-update-JumpProblems?*-1"></a><a class="docs-heading-anchor-permalink" href="#*2.-When-running-many-consecutive-simulations,-for-example-within-an-EnsembleProblem-or-loop,-how-can-I-update-JumpProblems?*" title="Permalink"></a></h4><p>In <a href="../../types/jump_types/#Remaking-JumpProblems">Remaking <code>JumpProblem</code>s</a> we show how to modify parameters, the initial condition, and other components of a generated <code>JumpProblem</code>. This can be useful when trying to call <code>solve</code> many times while avoiding reallocations of the internal aggregators for each new parameter value or initial condition.</p><h4 id="*3.-How-do-I-use-callbacks-with-ConstantRateJump-or-MassActionJump-systems?*"><a class="docs-heading-anchor" href="#*3.-How-do-I-use-callbacks-with-ConstantRateJump-or-MassActionJump-systems?*"><em>3. How do I use callbacks with <code>ConstantRateJump</code> or <code>MassActionJump</code> systems?</em></a><a id="*3.-How-do-I-use-callbacks-with-ConstantRateJump-or-MassActionJump-systems?*-1"></a><a class="docs-heading-anchor-permalink" href="#*3.-How-do-I-use-callbacks-with-ConstantRateJump-or-MassActionJump-systems?*" title="Permalink"></a></h4><p>Callbacks can be used with <code>ConstantRateJump</code>s and <code>MassActionJump</code>s. When solving a pure jump system with <code>SSAStepper</code>, only discrete callbacks can be used (otherwise a different time stepper is needed). </p><p><em>Note, when modifying <code>u</code> or <code>p</code> within a callback, you must call <code>reset_aggregated_jumps!(integrator)</code> after making updates.</em> This ensures that the underlying jump simulation algorithms know to reinitialize their internal data structures. Leaving out this call will lead to incorrect behavior!</p><p>A simple example that uses a <code>MassActionJump</code> and changes the parameters at a specified time in the simulation using a <code>DiscreteCallback</code> is</p><pre><code class="language-julia hljs">using DiffEqJump
rs = [[1 =&gt; 1],[2=&gt;1]]
ns = [[1 =&gt; -1, 2 =&gt; 1],[1=&gt;1,2=&gt;-1]]
p  = [1.0,0.0]
maj = MassActionJump(rs, ns; param_idxs=[1,2])
u₀ = [100,0]
tspan = (0.0,40.0)
dprob = DiscreteProblem(u₀,tspan,p)
jprob = JumpProblem(dprob,Direct(),maj)
pcondit(u,t,integrator) = t==20.0
function paffect!(integrator)
  integrator.p[1] = 0.0
  integrator.p[2] = 1.0
  reset_aggregated_jumps!(integrator)
end
sol = solve(jprob, SSAStepper(), tstops=[20.0], callback=DiscreteCallback(pcondit,paffect!))</code></pre><p>Here at time <code>20.0</code> we turn off production of <code>u[2]</code> while activating production of <code>u[1]</code>, giving</p><p><img src="../../assets/callback_gillespie.png" alt="callback_gillespie"/></p><h4 id="*4.-How-can-I-define-collections-of-many-different-jumps-and-pass-them-to-JumpProblem?*"><a class="docs-heading-anchor" href="#*4.-How-can-I-define-collections-of-many-different-jumps-and-pass-them-to-JumpProblem?*"><em>4. How can I define collections of many different jumps and pass them to <code>JumpProblem</code>?</em></a><a id="*4.-How-can-I-define-collections-of-many-different-jumps-and-pass-them-to-JumpProblem?*-1"></a><a class="docs-heading-anchor-permalink" href="#*4.-How-can-I-define-collections-of-many-different-jumps-and-pass-them-to-JumpProblem?*" title="Permalink"></a></h4><p>We can use <code>JumpSet</code>s to collect jumps together, and then pass them into <code>JumpProblem</code>s directly. For example, using the <code>MassActionJump</code> and <code>ConstantRateJump</code> defined earlier we can write</p><pre><code class="language-julia hljs">jset = JumpSet(mass_act_jump, birth_jump)
jump_prob = JumpProblem(prob, Direct(), jset)
sol = solve(jump_prob, SSAStepper())</code></pre><p>If you have many jumps in tuples or vectors it is easiest to use the keyword argument-based constructor:</p><pre><code class="language-julia hljs">cj1 = ConstantRateJump(rate1,affect1!)
cj2 = ConstantRateJump(rate2,affect2!)
cjvec = [cj1,cj2]

vj1 = VariableRateJump(rate3,affect3!)
vj2 = VariableRateJump(rate4,affect4!)
vjtuple = (vj1,vj2)

jset = JumpSet(; constant_jumps=cjvec, variable_jumps=vjtuple, 
                 massaction_jumps=mass_act_jump)</code></pre><h4 id="*5.-How-can-I-set-the-random-number-generator-used-in-the-jump-process-sampling-algorithms-(SSAs)?*"><a class="docs-heading-anchor" href="#*5.-How-can-I-set-the-random-number-generator-used-in-the-jump-process-sampling-algorithms-(SSAs)?*"><em>5. How can I set the random number generator used in the jump process sampling algorithms (SSAs)?</em></a><a id="*5.-How-can-I-set-the-random-number-generator-used-in-the-jump-process-sampling-algorithms-(SSAs)?*-1"></a><a class="docs-heading-anchor-permalink" href="#*5.-How-can-I-set-the-random-number-generator-used-in-the-jump-process-sampling-algorithms-(SSAs)?*" title="Permalink"></a></h4><p>Random number generators can be passed to <code>JumpProblem</code> via the <code>rng</code> keyword argument. Continuing the previous example:</p><pre><code class="language-julia hljs">#] add RandomNumbers
using RandomNumbers
jprob = JumpProblem(dprob, Direct(), maj, rng=Xorshifts.Xoroshiro128Star(rand(UInt64)))</code></pre><p>uses the <code>Xoroshiro128Star</code> generator from <a href="https://github.com/JuliaRandom/RandomNumbers.jl">RandomNumbers.jl</a>.</p><h4 id="*6.-What-are-these-aggregators-and-aggregations-in-DiffEqJump?*"><a class="docs-heading-anchor" href="#*6.-What-are-these-aggregators-and-aggregations-in-DiffEqJump?*"><em>6. What are these aggregators and aggregations in DiffEqJump?</em></a><a id="*6.-What-are-these-aggregators-and-aggregations-in-DiffEqJump?*-1"></a><a class="docs-heading-anchor-permalink" href="#*6.-What-are-these-aggregators-and-aggregations-in-DiffEqJump?*" title="Permalink"></a></h4><p>DiffEqJump provides a variety of methods for sampling the time the next <code>ConstantRateJump</code> or <code>MassActionJump</code> occurs, and which jump type happens at that time. These methods are examples of stochastic simulation algorithms (SSAs), also known as Gillespie methods, Doob&#39;s method, or Kinetic Monte Carlo methods. In the DiffEqJump terminology we call such methods &quot;aggregators&quot;, and the cache structures that hold their basic data &quot;aggregations&quot;. See <a href="../../types/jump_types/#Constant-Rate-Jump-Aggregators">Constant Rate Jump Aggregators</a> for a list of the available SSA aggregators.</p><h4 id="*7.-How-should-jumps-be-ordered-in-dependency-graphs?*"><a class="docs-heading-anchor" href="#*7.-How-should-jumps-be-ordered-in-dependency-graphs?*"><em>7. How should jumps be ordered in dependency graphs?</em></a><a id="*7.-How-should-jumps-be-ordered-in-dependency-graphs?*-1"></a><a class="docs-heading-anchor-permalink" href="#*7.-How-should-jumps-be-ordered-in-dependency-graphs?*" title="Permalink"></a></h4><p>Internally, DiffEqJump SSAs (aggregators) order all <code>MassActionJump</code>s first, then all <code>ConstantRateJumps</code>. i.e. in the example</p><pre><code class="language-julia hljs">using DiffEqJump
rs = [[1 =&gt; 1],[2=&gt;1]]
ns = [[1 =&gt; -1, 2 =&gt; 1],[1=&gt;1,2=&gt;-1]]
p  = [1.0,0.0]
maj = MassActionJump(rs, ns; param_idxs=[1,2])
rate1(u,p,t) = u[1]
function affect1!(integrator) 
  u[1] -= 1
end
cj1 = ConstantRateJump(rate1,affect1)
rate2(u,p,t) = u[2]
function affect2!(integrator)
  u[2] -= 1
end 
cj2 = ConstantRateJump(rate2,affect2)
jset = JumpSet(; constant_jumps=[cj1,cj2], massaction_jump=maj)</code></pre><p>The four jumps would be ordered by the first jump in <code>maj</code>, the second jump in <code>maj</code>, <code>cj1</code>, and finally <code>cj2</code>. Any user-generated dependency graphs should then follow this ordering when assigning an integer id to each jump. </p><p>See also <a href="../../types/jump_types/#Constant-Rate-Jump-Aggregators-Requiring-Dependency-Graphs">Constant Rate Jump Aggregators Requiring Dependency Graphs</a> for more on dependency graphs needed for the various SSAs.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dae_example/">« Differential Algebraic Equations</a><a class="docs-footer-nextpage" href="../jump_diffusion/">Jump Diffusion Equations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Monday 10 January 2022 01:41">Monday 10 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
