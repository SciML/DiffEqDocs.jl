<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solving Stiff Equations · DifferentialEquations.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-90474609-3', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://diffeq.sciml.ai/stable/tutorials/advanced_ode_example/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DifferentialEquations.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">DifferentialEquations.jl: Scientific Machine Learning (SciML) Enabled Simulation and Estimation</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../ode_example/">Ordinary Differential Equations</a></li><li class="is-active"><a class="tocitem" href>Solving Stiff Equations</a><ul class="internal"><li><a class="tocitem" href="#Code-Optimization-for-Differential-Equations"><span>Code Optimization for Differential Equations</span></a></li><li><a class="tocitem" href="#Speeding-Up-Jacobian-Calculations"><span>Speeding Up Jacobian Calculations</span></a></li><li><a class="tocitem" href="#Defining-Linear-Solver-Routines-and-Jacobian-Free-Newton-Krylov"><span>Defining Linear Solver Routines and Jacobian-Free Newton-Krylov</span></a></li><li><a class="tocitem" href="#Using-Structured-Matrix-Types"><span>Using Structured Matrix Types</span></a></li><li><a class="tocitem" href="#Sundials-Specific-Handling"><span>Sundials-Specific Handling</span></a></li><li><a class="tocitem" href="#Handling-Mass-Matrices"><span>Handling Mass Matrices</span></a></li></ul></li><li><a class="tocitem" href="../sde_example/">Stochastic Differential Equations</a></li><li><a class="tocitem" href="../rode_example/">Random Ordinary Differential Equations</a></li><li><a class="tocitem" href="../dde_example/">Delay Differential Equations</a></li><li><a class="tocitem" href="../dae_example/">Differential Algebraic Equations</a></li><li><a class="tocitem" href="../discrete_stochastic_example/">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="tocitem" href="../jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="tocitem" href="../bvp_example/">Boundary Value Problems</a></li><li><a class="tocitem" href="../additional/">Additional Tutorials</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../basics/common_solver_opts/">Common Solver Options</a></li><li><a class="tocitem" href="../../basics/solution/">Solution Handling</a></li><li><a class="tocitem" href="../../basics/plot/">Plot Functions</a></li><li><a class="tocitem" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="tocitem" href="../../basics/problem/">Problem Interface</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="tocitem">Problem Types</span><ul><li><a class="tocitem" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="tocitem" href="../../types/ode_types/">ODE Problems</a></li><li><a class="tocitem" href="../../types/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group Problems</a></li><li><a class="tocitem" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="tocitem" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="tocitem" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="tocitem" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="tocitem" href="../../types/sde_types/">SDE Problems</a></li><li><a class="tocitem" href="../../types/sdae_types/">SDAE Problems</a></li><li><a class="tocitem" href="../../types/rode_types/">RODE Problems</a></li><li><a class="tocitem" href="../../types/dde_types/">DDE Problems</a></li><li><a class="tocitem" href="../../types/sdde_types/">SDDE Problems</a></li><li><a class="tocitem" href="../../types/dae_types/">DAE Problems</a></li><li><a class="tocitem" href="../../types/jump_types/">Jump Problems</a></li></ul></li><li><span class="tocitem">Solver Algorithms</span><ul><li><a class="tocitem" href="../../solvers/discrete_solve/">Discrete Solvers</a></li><li><a class="tocitem" href="../../solvers/ode_solve/">ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/split_ode_solve/">Split ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/steady_state_solve/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/bvp_solve/">BVP Solvers</a></li><li><a class="tocitem" href="../../solvers/jump_solve/">Jump Problem and Jump Diffusion Solvers</a></li><li><a class="tocitem" href="../../solvers/sde_solve/">SDE Solvers</a></li><li><a class="tocitem" href="../../solvers/sdae_solve/">SDAE Solvers</a></li><li><a class="tocitem" href="../../solvers/rode_solve/">RODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dde_solve/">DDE Solvers</a></li><li><a class="tocitem" href="../../solvers/sdde_solve/">SDDE Solvers</a></li><li><a class="tocitem" href="../../solvers/dae_solve/">DAE Solvers</a></li><li><a class="tocitem" href="../../solvers/benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="tocitem">Additional Features</span><ul><li><a class="tocitem" href="../../features/performance_overloads/">DiffEqFunctions (Jacobians, Gradients, etc.) and Jacobian Types</a></li><li><a class="tocitem" href="../../features/diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="tocitem" href="../../features/diffeq_operator/">DiffEqOperators</a></li><li><a class="tocitem" href="../../features/noise_process/">Noise Processes</a></li><li><a class="tocitem" href="../../features/linear_nonlinear/">Specifying (Non)Linear Solvers</a></li><li><a class="tocitem" href="../../features/callback_functions/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../features/callback_library/">Callback Library</a></li><li><a class="tocitem" href="../../features/ensemble/">Parallel Ensemble Simulations</a></li><li><a class="tocitem" href="../../features/io/">I/O: Saving and Loading Solution Data</a></li><li><a class="tocitem" href="../../features/low_dep/">Low Dependency Usage</a></li><li><a class="tocitem" href="../../features/progress_bar/">Progress Bar Integration</a></li></ul></li><li><span class="tocitem">Analysis Tools</span><ul><li><a class="tocitem" href="../../analysis/parameterized_functions/">ParameterizedFunctions</a></li><li><a class="tocitem" href="../../analysis/parameter_estimation/">Parameter Estimation and Bayesian Analysis</a></li><li><a class="tocitem" href="../../analysis/bifurcation/">Bifurcation Analysis</a></li><li><a class="tocitem" href="../../analysis/sensitivity/">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li><a class="tocitem" href="../../analysis/global_sensitivity/">Global Sensitivity Analysis</a></li><li><a class="tocitem" href="../../analysis/uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="tocitem" href="../../analysis/neural_networks/">Neural Networks</a></li><li><a class="tocitem" href="../../analysis/dev_and_test/">Algorithm Development and Testing</a></li></ul></li><li><span class="tocitem">Domain Modeling Tools</span><ul><li><a class="tocitem" href="../../models/multiscale/">Multi-Scale Models</a></li><li><a class="tocitem" href="../../models/physical/">Physical Models</a></li><li><a class="tocitem" href="../../models/financial/">Financial Models</a></li><li><a class="tocitem" href="../../models/chemical_reactions/">Chemical Reactions</a></li><li><a class="tocitem" href="../../models/external_modeling/">External Modeling Packages</a></li></ul></li><li><span class="tocitem">Extra Details</span><ul><li><a class="tocitem" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li><li><a class="tocitem" href="../../extras/sensitivity_math/">Mathematics of Sensitivity Analysis</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Solving Stiff Equations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solving Stiff Equations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/DiffEqDocs.jl/blob/master/docs/src/tutorials/advanced_ode_example.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="stiff"><a class="docs-heading-anchor" href="#stiff">Solving Stiff Equations</a><a id="stiff-1"></a><a class="docs-heading-anchor-permalink" href="#stiff" title="Permalink"></a></h1><p>This tutorial is for getting into the extra features for solving stiff ordinary differential equations in an efficient manner. Solving stiff ordinary differential equations requires specializing the linear solver on properties of the Jacobian in order to cut down on the <span>$\mathcal{O}(n^3)$</span> linear solve and the <span>$\mathcal{O}(n^2)$</span> back-solves. Note that these same functions and controls also extend to stiff SDEs, DDEs, DAEs, etc.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This tutorial is for advanced users to dive into advanced features!</p></div></div><h2 id="Code-Optimization-for-Differential-Equations"><a class="docs-heading-anchor" href="#Code-Optimization-for-Differential-Equations">Code Optimization for Differential Equations</a><a id="Code-Optimization-for-Differential-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Code-Optimization-for-Differential-Equations" title="Permalink"></a></h2><p>Solving stiff differential equations requires speed. Here&#39;s a few things to keep in mind.</p><h3 id="Writing-Efficient-Code"><a class="docs-heading-anchor" href="#Writing-Efficient-Code">Writing Efficient Code</a><a id="Writing-Efficient-Code-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-Efficient-Code" title="Permalink"></a></h3><p>For a detailed tutorial on how to optimize one&#39;s DifferentialEquations.jl code, please see the <a href="http://tutorials.juliadiffeq.org/html/introduction/03-optimizing_diffeq_code.html">Optimizing DiffEq Code tutorial</a>.</p><h3 id="Choosing-a-Good-Solver"><a class="docs-heading-anchor" href="#Choosing-a-Good-Solver">Choosing a Good Solver</a><a id="Choosing-a-Good-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-a-Good-Solver" title="Permalink"></a></h3><p>Choosing a good solver is required for getting top notch speed. General recommendations can be found on the solver page (for example, the <a href="../../solvers/ode_solve/#ode_solve">ODE Solver Recommendations</a>). The current recommendations can be simplified to a Rosenbrock method (<code>Rosenbrock23</code> or <code>Rodas5</code>) for smaller (&lt;50 ODEs) problems, ESDIRK methods for slightly larger (<code>TRBDF2</code> or <code>KenCarp4</code> for &lt;2000 ODEs), and Sundials <code>CVODE_BDF</code> for even larger problems. <code>lsoda</code> from <a href="https://github.com/rveltz/LSODA.jl">LSODA.jl</a> is generally worth a try.</p><p>More details on the solver to choose can be found by benchmarking. See the <a href="https://github.com/JuliaDiffEq/DiffEqBenchmarks.jl">DiffEqBenchmarks</a> to compare many solvers on many problems.</p><h3 id="Check-Out-the-Speed-FAQ"><a class="docs-heading-anchor" href="#Check-Out-the-Speed-FAQ">Check Out the Speed FAQ</a><a id="Check-Out-the-Speed-FAQ-1"></a><a class="docs-heading-anchor-permalink" href="#Check-Out-the-Speed-FAQ" title="Permalink"></a></h3><p>See <a href="../../basics/faq/#faq_performance">this FAQ</a> for information on common pitfalls and how to improve performance.</p><h3 id="Setting-Up-Your-Julia-Installation-for-Speed"><a class="docs-heading-anchor" href="#Setting-Up-Your-Julia-Installation-for-Speed">Setting Up Your Julia Installation for Speed</a><a id="Setting-Up-Your-Julia-Installation-for-Speed-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-Up-Your-Julia-Installation-for-Speed" title="Permalink"></a></h3><p>Julia uses an underlying BLAS implementation for its matrix multiplications and factorizations. This library is automatically multithreaded and accelerates the internal linear algebra of DifferentialEquations.jl. However, for optimality, you should make sure that the number of BLAS threads that you are using matches the number of physical cores and not the number of logical cores. See <a href="https://github.com/JuliaLang/julia/issues/33409">this issue for more details</a>.</p><p>To check the number of BLAS threads, use:</p><pre><code class="language-julia">ccall((:openblas_get_num_threads64_, Base.libblas_name), Cint, ())</code></pre><p>If I want to set this directly to 4 threads, I would use:</p><pre><code class="language-julia">using LinearAlgebra
LinearAlgebra.BLAS.set_num_threads(4)</code></pre><p>Additionally, in some cases Intel&#39;s MKL might be a faster BLAS than the standard BLAS that ships with Julia (OpenBLAS). To switch your BLAS implementation, you can use <a href="https://github.com/JuliaComputing/MKL.jl">MKL.jl</a> which will accelerate the linear algebra routines. Please see the package for the limitations.</p><h3 id="Use-Accelerator-Hardware"><a class="docs-heading-anchor" href="#Use-Accelerator-Hardware">Use Accelerator Hardware</a><a id="Use-Accelerator-Hardware-1"></a><a class="docs-heading-anchor-permalink" href="#Use-Accelerator-Hardware" title="Permalink"></a></h3><p>When possible, use GPUs. If your ODE system is small and you need to solve it with very many different parameters, see the <a href="../../features/ensemble/#ensemble">ensembles interface</a> and <a href="https://github.com/JuliaDiffEq/DiffEqGPU.jl">DiffEqGPU.jl</a>. If your problem is large, consider using a <a href="https://github.com/JuliaGPU/CuArrays.jl">CuArray</a> for the state to allow for GPU-parallelism of the internal linear algebra.</p><h2 id="Speeding-Up-Jacobian-Calculations"><a class="docs-heading-anchor" href="#Speeding-Up-Jacobian-Calculations">Speeding Up Jacobian Calculations</a><a id="Speeding-Up-Jacobian-Calculations-1"></a><a class="docs-heading-anchor-permalink" href="#Speeding-Up-Jacobian-Calculations" title="Permalink"></a></h2><p>When one is using an implicit or semi-implicit differential equation solver, the Jacobian must be built at many iterations and this can be one of the most expensive steps. There are two pieces that must be optimized in order to reach maximal efficiency when solving stiff equations: the sparsity pattern and the construction of the Jacobian. The construction is filling the matrix <code>J</code> with values, while the sparsity pattern is what <code>J</code> to use.</p><p>The sparsity pattern is given by a prototype matrix, the <code>jac_prototype</code>, which will be copied to be used as <code>J</code>. The default is for <code>J</code> to be a <code>Matrix</code>, i.e. a dense matrix. However, if you know the sparsity of your problem, then you can pass a different matrix type. For example, a <code>SparseMatrixCSC</code> will give a sparse matrix. Additionally, structured matrix types like <code>Tridiagonal</code>, <code>BandedMatrix</code> (from <a href="https://github.com/JuliaMatrices/BandedMatrices.jl">BandedMatrices.jl</a>), <code>BlockBandedMatrix</code> (from <a href="https://github.com/JuliaMatrices/BlockBandedMatrices.jl">BlockBandedMatrices.jl</a>), and more can be given. DifferentialEquations.jl will internally use this matrix type, making the factorizations faster by utilizing the specialized forms.</p><p>For the construction, there are 3 ways to fill <code>J</code>:</p><ul><li>The default, which uses normal finite/automatic differentiation</li><li>A function <code>jac(J,u,p,t)</code> which directly computes the values of <code>J</code></li><li>A <code>colorvec</code> which defines a sparse differentiation scheme.</li></ul><p>We will now showcase how to make use of this functionality with growing complexity.</p><h3 id="Declaring-Jacobian-Functions"><a class="docs-heading-anchor" href="#Declaring-Jacobian-Functions">Declaring Jacobian Functions</a><a id="Declaring-Jacobian-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Declaring-Jacobian-Functions" title="Permalink"></a></h3><p>Let&#39;s solve the Rober equations:</p><div>\[\begin{aligned}
\frac{dy_1}{dt} &amp;= -0.04y₁ + 10^4 y_2 y_3 \\
\frac{dy_2}{dt} &amp;= 0.04 y_1 - 10^4 y_2 y_3 - 3*10^7 y_{2}^2 \\
\frac{dy_3}{dt} &amp;= 3*10^7 y_{2}^2 \\
\end{aligned}\]</div><p>In order to reduce the Jacobian construction cost, one can describe a Jacobian function by using the <code>jac</code> argument for the <code>ODEFunction</code>. First, let&#39;s do a standard <code>ODEProblem</code>:</p><pre><code class="language-julia">using DifferentialEquations
function rober(du,u,p,t)
  y₁,y₂,y₃ = u
  k₁,k₂,k₃ = p
  du[1] = -k₁*y₁+k₃*y₂*y₃
  du[2] =  k₁*y₁-k₂*y₂^2-k₃*y₂*y₃
  du[3] =  k₂*y₂^2
  nothing
end
prob = ODEProblem(rober,[1.0,0.0,0.0],(0.0,1e5),[0.04,3e7,1e4])
sol = solve(prob)
plot(sol,tspan=(1e-2,1e5),xscale=:log10)</code></pre><p><img src="../../assets/intro_dae_plot.png" alt="IntroDAEPlot"/></p><pre><code class="language-julia-repl">julia&gt; using BenchmarkTools
julia&gt; @btime solve(prob)
415.800 μs (3053 allocations: 161.64 KiB)</code></pre><p>Now we want to add the Jacobian. First we have to derive the Jacobian <span>$\frac{df_i}{du_j}$</span> which is <code>J[i,j]</code>. From this we get:</p><pre><code class="language-julia">function rober_jac(J,u,p,t)
  y₁,y₂,y₃ = u
  k₁,k₂,k₃ = p
  J[1,1] = k₁ * -1
  J[2,1] = k₁
  J[3,1] = 0
  J[1,2] = y₃ * k₃
  J[2,2] = y₂ * k₂ * -2 + y₃ * k₃ * -1
  J[3,2] = y₂ * 2 * k₂
  J[1,3] = k₃ * y₂
  J[2,3] = k₃ * y₂ * -1
  J[3,3] = 0
  nothing
end
f = ODEFunction(rober, jac=rober_jac)
prob_jac = ODEProblem(f,[1.0,0.0,0.0],(0.0,1e5),(0.04,3e7,1e4))</code></pre><pre><code class="language-julia-repl">julia&gt; @btime solve(prob_jac)
305.400 μs (2599 allocations: 153.11 KiB)</code></pre><h3 id="Automatic-Derivation-of-Jacobian-Functions"><a class="docs-heading-anchor" href="#Automatic-Derivation-of-Jacobian-Functions">Automatic Derivation of Jacobian Functions</a><a id="Automatic-Derivation-of-Jacobian-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Derivation-of-Jacobian-Functions" title="Permalink"></a></h3><p>But that was hard! If you want to take the symbolic Jacobian of numerical code, we can make use of <a href="https://github.com/JuliaDiffEq/ModelingToolkit.jl">ModelingToolkit.jl</a> to symbolicify the numerical code and do the symbolic calculation and return the Julia code for this.</p><pre><code class="language-julia">using ModelingToolkit
de = modelingtoolkitize(prob)
ModelingToolkit.generate_jacobian(de)[2] # Second is in-place</code></pre><p>which outputs:</p><pre><code class="language-julia">:((##MTIIPVar#376, u, p, t)-&gt;begin
          #= C:\Users\accou\.julia\packages\ModelingToolkit\czHtj\src\utils.jl:65 =#
          #= C:\Users\accou\.julia\packages\ModelingToolkit\czHtj\src\utils.jl:66 =#
          let (x₁, x₂, x₃, α₁, α₂, α₃) = (u[1], u[2], u[3], p[1], p[2], p[3])
              ##MTIIPVar#376[1] = α₁ * -1
              ##MTIIPVar#376[2] = α₁
              ##MTIIPVar#376[3] = 0
              ##MTIIPVar#376[4] = x₃ * α₃
              ##MTIIPVar#376[5] = x₂ * α₂ * -2 + x₃ * α₃ * -1
              ##MTIIPVar#376[6] = x₂ * 2 * α₂
              ##MTIIPVar#376[7] = α₃ * x₂
              ##MTIIPVar#376[8] = α₃ * x₂ * -1
              ##MTIIPVar#376[9] = 0
          end
          #= C:\Users\accou\.julia\packages\ModelingToolkit\czHtj\src\utils.jl:67 =#
          nothing
      end)</code></pre><p>Now let&#39;s use that to give the analytical solution Jacobian:</p><pre><code class="language-julia">jac = eval(ModelingToolkit.generate_jacobian(de)[2])
f = ODEFunction(rober, jac=jac)
prob_jac = ODEProblem(f,[1.0,0.0,0.0],(0.0,1e5),(0.04,3e7,1e4))</code></pre><h3 id="Declaring-a-Sparse-Jacobian"><a class="docs-heading-anchor" href="#Declaring-a-Sparse-Jacobian">Declaring a Sparse Jacobian</a><a id="Declaring-a-Sparse-Jacobian-1"></a><a class="docs-heading-anchor-permalink" href="#Declaring-a-Sparse-Jacobian" title="Permalink"></a></h3><p>Jacobian sparsity is declared by the <code>jac_prototype</code> argument in the <code>ODEFunction</code>. Note that you should only do this if the sparsity is high, for example, 0.1% of the matrix is non-zeros, otherwise the overhead of sparse matrices can be higher than the gains from sparse differentiation!</p><p>But as a demonstration, let&#39;s build a sparse matrix for the Rober problem. We can do this by gathering the <code>I</code> and <code>J</code> pairs for the non-zero components, like:</p><pre><code class="language-julia">I = [1,2,1,2,3,1,2]
J = [1,1,2,2,2,3,3]

using SparseArrays
jac_prototype = sparse(I,J,1.0)</code></pre><p>Now this is the sparse matrix prototype that we want to use in our solver, which we then pass like:</p><pre><code class="language-julia">f = ODEFunction(rober, jac=jac, jac_prototype=jac_prototype)
prob_jac = ODEProblem(f,[1.0,0.0,0.0],(0.0,1e5),(0.04,3e7,1e4))</code></pre><h3 id="Automatic-Sparsity-Detection"><a class="docs-heading-anchor" href="#Automatic-Sparsity-Detection">Automatic Sparsity Detection</a><a id="Automatic-Sparsity-Detection-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Sparsity-Detection" title="Permalink"></a></h3><p>One of the useful companion tools for DifferentialEquations.jl is <a href="https://github.com/JuliaDiffEq/SparsityDetection.jl">SparsityDetection.jl</a>. This allows for automatic declaration of Jacobian sparsity types. To see this in action, let&#39;s look at the 2-dimensional Brusselator equation:</p><pre><code class="language-julia">const N = 32
const xyd_brusselator = range(0,stop=1,length=N)
brusselator_f(x, y, t) = (((x-0.3)^2 + (y-0.6)^2) &lt;= 0.1^2) * (t &gt;= 1.1) * 5.
limit(a, N) = a == N+1 ? 1 : a == 0 ? N : a
function brusselator_2d_loop(du, u, p, t)
  A, B, alpha, dx = p
  alpha = alpha/dx^2
  @inbounds for I in CartesianIndices((N, N))
    i, j = Tuple(I)
    x, y = xyd_brusselator[I[1]], xyd_brusselator[I[2]]
    ip1, im1, jp1, jm1 = limit(i+1, N), limit(i-1, N), limit(j+1, N), limit(j-1, N)
    du[i,j,1] = alpha*(u[im1,j,1] + u[ip1,j,1] + u[i,jp1,1] + u[i,jm1,1] - 4u[i,j,1]) +
                B + u[i,j,1]^2*u[i,j,2] - (A + 1)*u[i,j,1] + brusselator_f(x, y, t)
    du[i,j,2] = alpha*(u[im1,j,2] + u[ip1,j,2] + u[i,jp1,2] + u[i,jm1,2] - 4u[i,j,2]) +
                A*u[i,j,1] - u[i,j,1]^2*u[i,j,2]
    end
end
p = (3.4, 1., 10., step(xyd_brusselator))</code></pre><p>Given this setup, we can give and example <code>input</code> and <code>output</code> and call <code>jacobian_sparsity</code> on our function with the example arguments and it will kick out a sparse matrix with our pattern, that we can turn into our <code>jac_prototype</code>.</p><pre><code class="language-julia">using SparsityDetection, SparseArrays
input = rand(32,32,2)
output = similar(input)
sparsity_pattern = jacobian_sparsity(brusselator_2d_loop,output,input,p,0.0)
jac_sparsity = Float64.(sparse(sparsity_pattern))</code></pre><p>Let&#39;s double check what our sparsity pattern looks like:</p><pre><code class="language-julia">using Plots
spy(jac_sparsity,markersize=1,colorbar=false,color=:deep)</code></pre><p><img src="../../assets/bruss_sparsity.png" alt="Bruss Sparsity"/></p><p>That&#39;s neat, and would be tedius to build by hand! Now we just pass it to the <code>ODEFunction</code> like as before:</p><pre><code class="language-julia">f = ODEFunction(brusselator_2d_loop;jac_prototype=jac_sparsity)</code></pre><p>Build the <code>ODEProblem</code>:</p><pre><code class="language-julia">function init_brusselator_2d(xyd)
  N = length(xyd)
  u = zeros(N, N, 2)
  for I in CartesianIndices((N, N))
    x = xyd[I[1]]
    y = xyd[I[2]]
    u[I,1] = 22*(y*(1-y))^(3/2)
    u[I,2] = 27*(x*(1-x))^(3/2)
  end
  u
end
u0 = init_brusselator_2d(xyd_brusselator)
prob_ode_brusselator_2d = ODEProblem(brusselator_2d_loop,
                                     u0,(0.,11.5),p)

prob_ode_brusselator_2d_sparse = ODEProblem(f,
                                     u0,(0.,11.5),p)</code></pre><p>Now let&#39;s see how the version with sparsity compares to the version without:</p><pre><code class="language-julia">@btime solve(prob_ode_brusselator_2d,save_everystep=false) # 51.714 s (7317 allocations: 70.12 MiB)
@btime solve(prob_ode_brusselator_2d_sparse,save_everystep=false) # 2.880 s (55533 allocations: 885.09 MiB)
@btime solve(prob_ode_brusselator_2d_sparse,TRBDF2(),save_everystep=false) # 1.185 s (55081 allocations: 347.79 MiB)</code></pre><p>From some automated tooling an a choice of an algorithm, we went from almost a minute to almost a second!</p><h2 id="Defining-Linear-Solver-Routines-and-Jacobian-Free-Newton-Krylov"><a class="docs-heading-anchor" href="#Defining-Linear-Solver-Routines-and-Jacobian-Free-Newton-Krylov">Defining Linear Solver Routines and Jacobian-Free Newton-Krylov</a><a id="Defining-Linear-Solver-Routines-and-Jacobian-Free-Newton-Krylov-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Linear-Solver-Routines-and-Jacobian-Free-Newton-Krylov" title="Permalink"></a></h2><p>A completely different way to optimize the linear solvers for large sparse matrices is to use a Krylov subpsace method. This requires choosing a linear solver for changing to a Krylov method. Optionally, one can use a Jacobian-free operator to reduce the memory requirements.</p><h3 id="Declaring-a-Jacobian-Free-Newton-Krylov-Implementation"><a class="docs-heading-anchor" href="#Declaring-a-Jacobian-Free-Newton-Krylov-Implementation">Declaring a Jacobian-Free Newton-Krylov Implementation</a><a id="Declaring-a-Jacobian-Free-Newton-Krylov-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Declaring-a-Jacobian-Free-Newton-Krylov-Implementation" title="Permalink"></a></h3><p>To swap the linear solver out, we use the <code>linsolve</code> command and choose the GMRES linear solver.</p><pre><code class="language-julia">@btime solve(prob_ode_brusselator_2d,TRBDF2(linsolve=LinSolveGMRES()),save_everystep=false) # 469.174 s (1266049 allocations: 120.80 MiB)
@btime solve(prob_ode_brusselator_2d_sparse,TRBDF2(linsolve=LinSolveGMRES()),save_everystep=false) 10.928 s (1327264 allocations: 59.92 MiB)</code></pre><p>For more information on linear solver choices, see the <a href="../../features/linear_nonlinear/#linear_nonlinear">linear solver documentation</a>.</p><p>We can also enhance this by using a Jacobian-Free implementation of <code>f&#39;(x)*v</code>. To define the Jacobian-Free operator, we can use <a href="https://github.com/JuliaDiffEq/DiffEqOperators.jl">DiffEqOperators.jl</a> to generate an operator <code>JacVecOperator</code> such that <code>Jv*v</code> performs <code>f&#39;(x)*v</code> without building the Jacobian matrix.</p><pre><code class="language-julia">using DiffEqOperators
Jv = JacVecOperator(brusselator_2d_loop,u0,p,0.0)</code></pre><p>and then we can use this by making it our <code>jac_prototype</code>:</p><pre><code class="language-julia">f2 = ODEFunction(brusselator_2d_loop;jac_prototype=Jv);
prob_ode_brusselator_2d_jacfree = ODEProblem(f2,u0,(0.,11.5),p);
@btime solve(prob_ode_brusselator_2d_jacfree,TRBDF2(linsolve=LinSolveGMRES()),save_everystep=false) # 8.352 s (1875298 allocations: 78.86 MiB)</code></pre><h3 id="Adding-a-Preconditioner"><a class="docs-heading-anchor" href="#Adding-a-Preconditioner">Adding a Preconditioner</a><a id="Adding-a-Preconditioner-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-a-Preconditioner" title="Permalink"></a></h3><p>The <a href="../../features/linear_nonlinear/#iterativesolvers-jl">linear solver documentation</a> shows how you can add a preconditioner to the GMRES. For example, you can use packages like <a href="https://github.com/JuliaLinearAlgebra/AlgebraicMultigrid.jl">AlgebraicMultigrid.jl</a> to add an algebraic multigrid (AMG) or <a href="https://github.com/haampie/IncompleteLU.jl">IncompleteLU.jl</a> for an incomplete LU-factorization (iLU).</p><pre><code class="language-julia">using AlgebraicMultigrid
pc = aspreconditioner(ruge_stuben(jac_sparsity));
@btime solve(prob_ode_brusselator_2d_jacfree,TRBDF2(linsolve=LinSolveGMRES(Pl=pc)),save_everystep=false) # 5.247 s (233048 allocations: 139.27 MiB)</code></pre><h2 id="Using-Structured-Matrix-Types"><a class="docs-heading-anchor" href="#Using-Structured-Matrix-Types">Using Structured Matrix Types</a><a id="Using-Structured-Matrix-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Structured-Matrix-Types" title="Permalink"></a></h2><p>If your sparsity pattern follows a specific structure, for example a banded matrix, then you can declare <code>jac_prototype</code> to be of that structure and then additional optimizations will come for free. Note that in this case, it is not necessary to provide a <code>colorvec</code> since the color vector will be analytically derived from the structure of the matrix.</p><p>The matrices which are allowed are those which satisfy the <a href="https://github.com/JuliaDiffEq/ArrayInterface.jl">ArrayInterface.jl</a> interface for automatically-colorable matrices. These include:</p><ul><li>Bidiagonal</li><li>Tridiagonal</li><li>SymTridiagonal</li><li>BandedMatrix (<a href="https://github.com/JuliaMatrices/BandedMatrices.jl">BandedMatrices.jl</a>)</li><li>BlockBandedMatrix (<a href="https://github.com/JuliaMatrices/BlockBandedMatrices.jl">BlockBandedMatrices.jl</a>)</li></ul><p>Matrices which do not satisfy this interface can still be used, but the matrix coloring will not be automatic, and an appropriate linear solver may need to be given (otherwise it will default to attempting an LU-decomposition).</p><h2 id="Sundials-Specific-Handling"><a class="docs-heading-anchor" href="#Sundials-Specific-Handling">Sundials-Specific Handling</a><a id="Sundials-Specific-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Sundials-Specific-Handling" title="Permalink"></a></h2><p>While much of the setup makes the transition to using Sundials automatic, there are some differences between the pure Julia implementations and the Sundials implementations which must be taken note of. These are all detailed in the <a href="http://docs.juliadiffeq.org/dev/solvers/ode_solve#Sundials.jl-1">Sundials solver documentation</a>, but here we will highlight the main details which one should make note of.</p><p>Defining a sparse matrix and a Jacobian for Sundials works just like any other package. The core difference is in the choice of the linear solver. With Sundials, the linear solver choice is done with a Symbol in the <code>linear_solver</code> from a preset list. Particular choices of note are <code>:Band</code> for a banded matrix and <code>:GMRES</code> for using GMRES. If you are using Sundials, <code>:GMRES</code> will not require defining the JacVecOperator, and instead will always make use of a Jacobian-Free Newton Krylov (with numerical differentiation). Thus on this problem we could do:</p><pre><code class="language-julia">using Sundials
# Sparse Version
@btime solve(prob_ode_brusselator_2d_sparse,CVODE_BDF(),save_everystep=false) # 42.804 s (51388 allocations: 3.20 MiB)
# GMRES Version: Doesn&#39;t require any extra stuff!
@btime solve(prob_ode_brusselator_2d,CVODE_BDF(linear_solver=:GMRES),save_everystep=false) # 485.671 ms (61058 allocations: 3.63 MiB)</code></pre><p>Details for setting up a preconditioner with Sundials can be found at the <a href="../../solvers/ode_solve/#ode_solve_sundials">Sundials solver page</a>.</p><h2 id="Handling-Mass-Matrices"><a class="docs-heading-anchor" href="#Handling-Mass-Matrices">Handling Mass Matrices</a><a id="Handling-Mass-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-Mass-Matrices" title="Permalink"></a></h2><p>Instead of just defining an ODE as <span>$u&#39; = f(u,p,t)$</span>, it can be common to express the differential equation in the form with a mass matrix:</p><div>\[Mu&#39; = f(u,p,t)\]</div><p>where <span>$M$</span> is known as the mass matrix. Let&#39;s solve the Robertson equation. At the top we wrote this equation as:</p><div>\[\begin{aligned}
dy_1 &amp;= -0.04 y_1 + 10^4 y_2 y_3 \\
dy_2 &amp;=  0.04 y_1 - 10^4 y_2 y_3 - 3*10^7 y_{2}^2 \\
dy_3 &amp;= 3*10^7 y_{2}^2 \\
\end{aligned}\]</div><p>But we can instead write this with a conservation relation:</p><div>\[\begin{aligned}
\frac{dy_1}{dt} &amp;= -0.04 y_1 + 10^4 y_2 y_3 \\
\frac{dy_2}{dt} &amp;=  0.04 y_1 - 10^4 y_2 y_3 - 3*10^7 y_{2}^2 \\
1 &amp;=  y_{1} + y_{2} + y_{3} \\
\end{aligned}\]</div><p>In this form, we can write this as a mass matrix ODE where <span>$M$</span> is singular (this is another form of a differential-algebraic equation (DAE)). Here, the last row of <code>M</code> is just zero. We can implement this form as:</p><pre><code class="language-julia">using DifferentialEquations
function rober(du,u,p,t)
  y₁,y₂,y₃ = u
  k₁,k₂,k₃ = p
  du[1] = -k₁*y₁ + k₃*y₂*y₃
  du[2] =  k₁*y₁ - k₃*y₂*y₃ - k₂*y₂^2
  du[3] =  y₁ + y₂ + y₃ - 1
  nothing
end
M = [1. 0  0
     0  1. 0
     0  0  0]
f = ODEFunction(rober,mass_matrix=M)
prob_mm = ODEProblem(f,[1.0,0.0,0.0],(0.0,1e5),(0.04,3e7,1e4))
sol = solve(prob_mm,Rodas5(),reltol=1e-8,abstol=1e-8)

plot(sol, xscale=:log10, tspan=(1e-6, 1e5), layout=(3,1))</code></pre><p><img src="../../assets/intro_dae_plot.png" alt="IntroDAEPlot"/></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If your mass matrix is singular, i.e. your system is a DAE, then you need to make sure you choose <a href="../../solvers/dae_solve/#dae_solve_full">a solver that is compatible with DAEs</a></p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ode_example/">« Ordinary Differential Equations</a><a class="docs-footer-nextpage" href="../sde_example/">Stochastic Differential Equations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 2 September 2020 05:56">Wednesday 2 September 2020</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
