<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Delay Differential Equations · DifferentialEquations.jl</title><meta name="title" content="Delay Differential Equations · DifferentialEquations.jl"/><meta property="og:title" content="Delay Differential Equations · DifferentialEquations.jl"/><meta property="twitter:title" content="Delay Differential Equations · DifferentialEquations.jl"/><meta name="description" content="Documentation for DifferentialEquations.jl."/><meta property="og:description" content="Documentation for DifferentialEquations.jl."/><meta property="twitter:description" content="Documentation for DifferentialEquations.jl."/><meta property="og:url" content="https://docs.sciml.ai/DiffEqDocs/stable/tutorials/dde_example/"/><meta property="twitter:url" content="https://docs.sciml.ai/DiffEqDocs/stable/tutorials/dde_example/"/><link rel="canonical" href="https://docs.sciml.ai/DiffEqDocs/stable/tutorials/dde_example/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DifferentialEquations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">DifferentialEquations.jl: Efficient Differential Equation Solving in Julia</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started with Differential Equations in Julia</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../faster_ode_example/">Code Optimization for Differential Equations</a></li><li><a class="tocitem" href="../advanced_ode_example/">Solving Large Stiff Equations</a></li><li><a class="tocitem" href="../sde_example/">Stochastic Differential Equations</a></li><li><a class="tocitem" href="../rode_example/">Random Ordinary Differential Equations</a></li><li class="is-active"><a class="tocitem" href>Delay Differential Equations</a></li><li><a class="tocitem" href="../dae_example/">Differential Algebraic Equations</a></li><li><a class="tocitem" href="../jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="tocitem" href="../bvp_example/">Boundary Value Problems</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Beginner</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/classical_physics/">Classical Physics Models</a></li><li><a class="tocitem" href="../../examples/conditional_dosing/">Conditional Dosing in Pharmacometrics</a></li><li><a class="tocitem" href="../../examples/kepler_problem/">The Kepler Problem</a></li><li><a class="tocitem" href="../../examples/outer_solar_system/">Simulating the Outer Solar System</a></li><li><a class="tocitem" href="../../examples/min_and_max/">Finding Maxima and Minima of ODEs Solutions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Advanced</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/spiking_neural_systems/">Spiking Neural Systems</a></li><li><a class="tocitem" href="../../examples/beeler_reuter/">An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model</a></li><li><a class="tocitem" href="../../examples/diffusion_implicit_heat_equation/">Solving the heat equation with diffusion-implicit time-stepping</a></li></ul></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../basics/common_solver_opts/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../basics/solution/">Solution Handling</a></li><li><a class="tocitem" href="../../basics/plot/">Plot Functions</a></li><li><a class="tocitem" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="tocitem" href="../../basics/problem/">Problem Interface</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="tocitem">Problem Types</span><ul><li><a class="tocitem" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="tocitem" href="../../types/ode_types/">ODE Problems</a></li><li><a class="tocitem" href="../../types/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group Problems</a></li><li><a class="tocitem" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="tocitem" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="tocitem" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="tocitem" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="tocitem" href="../../types/sde_types/">SDE Problems</a></li><li><a class="tocitem" href="../../types/sdae_types/">SDAE Problems</a></li><li><a class="tocitem" href="../../types/rode_types/">RODE Problems</a></li><li><a class="tocitem" href="../../types/dde_types/">DDE Problems</a></li><li><a class="tocitem" href="../../types/sdde_types/">SDDE Problems</a></li><li><a class="tocitem" href="../../types/dae_types/">DAE Problems</a></li></ul></li><li><span class="tocitem">Solver Algorithms</span><ul><li><a class="tocitem" href="../../solvers/discrete_solve/">Discrete Solvers</a></li><li><a class="tocitem" href="../../solvers/ode_solve/">ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/split_ode_solve/">Split ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/steady_state_solve/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/bvp_solve/">BVP Solvers</a></li><li><a class="tocitem" href="../../solvers/sde_solve/">SDE Solvers</a></li><li><a class="tocitem" href="../../solvers/sdae_solve/">SDAE Solvers</a></li><li><a class="tocitem" href="../../solvers/rode_solve/">RODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dde_solve/">DDE Solvers</a></li><li><a class="tocitem" href="../../solvers/sdde_solve/">SDDE Solvers</a></li><li><a class="tocitem" href="../../solvers/dae_solve/">Mass Matrix and Fully Implicit DAE Solvers</a></li><li><a class="tocitem" href="../../solvers/benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="tocitem">Additional Features</span><ul><li><a class="tocitem" href="../../features/performance_overloads/">Jacobians, Gradients, etc.</a></li><li><a class="tocitem" href="../../features/diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="tocitem" href="../../features/diffeq_operator/">Matrix-Free Linear Operators and Specializations on Linearity</a></li><li><a class="tocitem" href="../../features/noise_process/">Noise Processes</a></li><li><a class="tocitem" href="../../features/linear_nonlinear/">Specifying (Non)Linear Solvers and Preconditioners</a></li><li><a class="tocitem" href="../../features/callback_functions/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../features/callback_library/">Callback Library</a></li><li><a class="tocitem" href="../../features/ensemble/">Parallel Ensemble Simulations</a></li><li><a class="tocitem" href="../../features/io/">I/O: Saving and Loading Solution Data</a></li><li><a class="tocitem" href="../../features/low_dep/">Reduced Compile Time, Optimizing Runtime, and Low Dependency Usage</a></li><li><a class="tocitem" href="../../features/progress_bar/">Progress Bar Integration</a></li></ul></li><li><span class="tocitem">Detailed Solver APIs</span><ul><li><a class="tocitem" href="../../api/sundials/">Sundials.jl</a></li><li><a class="tocitem" href="../../api/daskr/">DASKR.jl</a></li></ul></li><li><span class="tocitem">Extra Details</span><ul><li><a class="tocitem" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Delay Differential Equations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Delay Differential Equations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/DiffEqDocs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/DiffEqDocs.jl/blob/master/docs/src/tutorials/dde_example.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Delay-Differential-Equations"><a class="docs-heading-anchor" href="#Delay-Differential-Equations">Delay Differential Equations</a><a id="Delay-Differential-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Delay-Differential-Equations" title="Permalink"></a></h1><p>This tutorial will introduce you to the functionality for solving delay differential equations.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This tutorial assumes you have read the <a href="../../getting_started/#ode_example">Ordinary Differential Equations tutorial</a>.</p></div></div><p>Delay differential equations are equations which have a delayed argument. To allow for specifying the delayed argument, the function definition for a delay differential equation is expanded to include a history function <code>h(p, t)</code> which uses interpolations throughout the solution&#39;s history to form a continuous extension of the solver&#39;s past and depends on parameters <code>p</code> and time <code>t</code>. The function signature for a delay differential equation is <code>f(u, h, p, t)</code> for not in-place computations, and <code>f(du, u, h, p, t)</code> for in-place computations.</p><p>In this example, we will solve <a href="https://idp.nature.com/authorize?response_type=cookie&amp;client_id=grover&amp;redirect_uri=https%3A%2F%2Fwww.nature.com%2Farticles%2Fsrep02473">a model of breast cancer growth kinetics</a>:</p><p class="math-container">\[\begin{aligned}
dx_{0} &amp;= \frac{v_{0}}{1+\beta_{0}\left(x_{2}(t-\tau)\right)^{2}}\left(p_{0}-q_{0}\right)x_{0}(t)-d_{0}x_{0}(t)\\
dx_{1} &amp;= \frac{v_{0}}{1+\beta_{0}\left(x_{2}(t-\tau)\right)^{2}}\left(1-p_{0}+q_{0}\right)x_{0}(t)\\
       &amp;+ \frac{v_{1}}{1+\beta_{1}\left(x_{2}(t-\tau)\right)^{2}}\left(p_{1}-q_{1}\right)x_{1}(t)-d_{1}x_{1}(t)\\
dx_{2} &amp;= \frac{v_{1}}{1+\beta_{1}\left(x_{2}(t-\tau)\right)^{2}}\left(1-p_{1}+q_{1}\right)x_{1}(t)-d_{2}x_{2}(t)
\end{aligned}\]</p><p>For this problem, we note that <span>$\tau$</span> is constant, and thus we can use a method which exploits this behavior. We first write out the equation using the appropriate function signature. Most of the equation writing is the same, though we use the history function by first interpolating and then choosing the components. Thus, the <code>i</code>th component at time <code>t-tau</code> is given by <code>h(p, t-tau)[i]</code>. Components with no delays are written as in the ODE.</p><p>Thus, the function for this model is given by:</p><pre><code class="language-julia hljs">using DifferentialEquations
function bc_model(du, u, h, p, t)
    p0, q0, v0, d0, p1, q1, v1, d1, d2, beta0, beta1, tau = p
    hist3 = h(p, t - tau)[3]
    du[1] = (v0 / (1 + beta0 * (hist3^2))) * (p0 - q0) * u[1] - d0 * u[1]
    du[2] = (v0 / (1 + beta0 * (hist3^2))) * (1 - p0 + q0) * u[1] +
            (v1 / (1 + beta1 * (hist3^2))) * (p1 - q1) * u[2] - d1 * u[2]
    du[3] = (v1 / (1 + beta1 * (hist3^2))) * (1 - p1 + q1) * u[2] - d2 * u[3]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">bc_model (generic function with 1 method)</code></pre><p>Now we build a <code>DDEProblem</code>. The signature</p><pre><code class="language-julia hljs">prob = DDEProblem(f, u0, h, tspan, p = SciMLBase.NullParameters();
    constant_lags = [], dependent_lags = [], kwargs...)</code></pre><p>is very similar to ODEs, where we now have to give the lags and a function <code>h</code>. <code>h</code> is the history function that declares what the values were before the time the model starts. Here we will assume that for all time before <code>t0</code> the values were 1 and define <code>h</code> as an out-of-place function:</p><pre><code class="language-julia hljs">h(p, t) = ones(3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">h (generic function with 1 method)</code></pre><p>To use the constant lag model, we have to declare the lags. Here we will use <code>tau=1</code>.</p><pre><code class="language-julia hljs">tau = 1
lags = [tau]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Int64}:
 1</code></pre><p>Next, we choose to solve on the timespan <code>(0.0,10.0)</code> and create the problem type:</p><pre><code class="language-julia hljs">p0 = 0.2;
q0 = 0.3;
v0 = 1;
d0 = 5;
p1 = 0.2;
q1 = 0.3;
v1 = 1;
d1 = 1;
d2 = 1;
beta0 = 1;
beta1 = 1;
p = (p0, q0, v0, d0, p1, q1, v1, d1, d2, beta0, beta1, tau)
tspan = (0.0, 10.0)
u0 = [1.0, 1.0, 1.0]

prob = DDEProblem(bc_model, u0, h, tspan, p; constant_lags = lags)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">DDEProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Float64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
Non-trivial mass matrix: <span class="sgr38_2" style="color:#56b6c2">false</span>
timespan: (0.0, 10.0)
u0: 3-element Vector{Float64}:
 1.0
 1.0
 1.0</code></pre><p>An efficient way to solve this problem (given the constant lags) is with the MethodOfSteps solver. Through the magic that is Julia, it translates an OrdinaryDiffEq.jl ODE solver method into a method for delay differential equations, which is highly efficient due to sweet compiler magic. A good choice is the order 5 method <code>Tsit5()</code>:</p><pre><code class="language-julia hljs">alg = MethodOfSteps(Tsit5())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DelayDiffEq.MethodOfSteps{Tsit5{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}, NLFunctional{Rational{Int64}, Rational{Int64}}, false}(Tsit5{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}(OrdinaryDiffEqCore.trivial_limiter!, OrdinaryDiffEqCore.trivial_limiter!, static(false)), NLFunctional{Rational{Int64}, Rational{Int64}}(1//100, 1//5, 10))</code></pre><p>For lower tolerance solving, one can use the <code>BS3()</code> algorithm to good effect (this combination is similar to the MATLAB <code>dde23</code>, but more efficient tableau), and for high tolerances the <code>Vern6()</code> algorithm will give a 6th order solution.</p><p>To solve the problem with this algorithm, we do the same thing we&#39;d do with other methods on the common interface:</p><pre><code class="language-julia hljs">sol = solve(prob, alg)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: specialized 4th order &quot;free&quot; interpolation
t: 40-element Vector{Float64}:
  0.0
  0.05836370738671701
  0.12916108716230104
  0.21568702511913448
  0.314760119628182
  0.4264787587173874
  0.5486009987808395
  0.6801498272932349
  0.8195261222856575
  0.9657507155327404
  ⋮
  5.6373403764097185
  6.0
  6.465321315305342
  6.980728827628572
  7.578753426986916
  8.241987346095213
  8.983832880237188
  9.794183212704345
 10.0
u: 40-element Vector{Vector{Float64}}:
 [1.0, 1.0, 1.0]
 [0.7447276972023368, 0.9674847415959038, 0.9739922644849844]
 [0.5208656862906424, 0.9216176731989374, 0.9429345991317408]
 [0.3364796171856176, 0.8607107651542081, 0.9053954304005898]
 [0.2040208069499486, 0.7893156323361196, 0.8627636957091346]
 [0.1160534936803686, 0.7109401281073281, 0.8151154589081274]
 [0.06263660901296746, 0.6308046447141534, 0.7637408776739649]
 [0.03223509871453403, 0.5524928145263729, 0.7096033390270903]
 [0.015946633867446297, 0.47891242587662397, 0.6540674055203148]
 [0.007620741981671972, 0.41158156825400705, 0.598282216755686]
 ⋮
 [1.9479586569871875e-12, 0.002576629861923476, 0.019737458800475192]
 [3.3296175026442913e-13, 0.0017291226374230072, 0.014435113877203256]
 [5.506440228284062e-14, 0.0010364503670893242, 0.009606889785462936]
 [1.183845658657568e-14, 0.0005879461412195119, 0.00607973236880551]
 [5.109129737946255e-15, 0.00030455202069189685, 0.0035496484392958704]
 [4.0750661735392095e-15, 0.0001468398509161308, 0.0019394742839871095]
 [6.62387474666883e-15, 6.49384785287269e-5, 0.0009786578716381644]
 [1.9122802657589606e-14, 2.6637037142589578e-5, 0.0004599557924653781]
 [6.699838471134649e-15, 2.124038225565019e-5, 0.00037925443872843627]</code></pre><p>Note that everything available to OrdinaryDiffEq.jl can be used here, including event handling and other callbacks. The solution object has the same interface as for ODEs. For example, we can use the same plot recipes to view the results:</p><pre><code class="language-julia hljs">using Plots
plot(sol)</code></pre><img src="348d8b1d.svg" alt="Example block output"/><h4 id="Speeding-Up-Interpolations-with-Idxs"><a class="docs-heading-anchor" href="#Speeding-Up-Interpolations-with-Idxs">Speeding Up Interpolations with Idxs</a><a id="Speeding-Up-Interpolations-with-Idxs-1"></a><a class="docs-heading-anchor-permalink" href="#Speeding-Up-Interpolations-with-Idxs" title="Permalink"></a></h4><p>We can speed up the previous problem in two different ways. First of all, if we need to interpolate multiple values from a previous time, we can use the in-place form for the history function <code>h(out, p, t)</code> which writes the output to <code>out</code>. In this case, we must supply the history initial conditions as in-place as well. For the previous example, that&#39;s simply</p><pre><code class="language-julia hljs">h(out, p, t) = (out .= 1.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">h (generic function with 2 methods)</code></pre><p>and then our DDE is:</p><pre><code class="language-julia hljs">const out = zeros(3) # Define a cache variable
function bc_model(du, u, h, p, t)
    h(out, p, t - tau) # updates out to be the correct history function
    du[1] = (v0 / (1 + beta0 * (out[3]^2))) * (p0 - q0) * u[1] - d0 * u[1]
    du[2] = (v0 / (1 + beta0 * (out[3]^2))) * (1 - p0 + q0) * u[1] +
            (v1 / (1 + beta1 * (out[3]^2))) * (p1 - q1) * u[2] - d1 * u[2]
    du[3] = (v1 / (1 + beta1 * (out[3]^2))) * (1 - p1 + q1) * u[2] - d2 * u[3]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">bc_model (generic function with 1 method)</code></pre><p>However, we can do something even slicker in most cases. We only ever needed to interpolate past values at index 3. Instead of generating a bunch of arrays, we can instead ask specifically for that value by passing the keyword <code>idxs = 3</code>. The DDE function <code>bc_model</code> is now:</p><pre><code class="language-julia hljs">function bc_model(du, u, h, p, t)
    u3_past_sq = h(p, t - tau; idxs = 3)^2
    du[1] = (v0 / (1 + beta0 * (u3_past_sq))) * (p0 - q0) * u[1] - d0 * u[1]
    du[2] = (v0 / (1 + beta0 * (u3_past_sq))) * (1 - p0 + q0) * u[1] +
            (v1 / (1 + beta1 * (u3_past_sq))) * (p1 - q1) * u[2] - d1 * u[2]
    du[3] = (v1 / (1 + beta1 * (u3_past_sq))) * (1 - p1 + q1) * u[2] - d2 * u[3]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">bc_model (generic function with 1 method)</code></pre><p>Note that this requires that we define the historical values</p><pre><code class="language-julia hljs">h(p, t; idxs = nothing) = typeof(idxs) &lt;: Number ? 1.0 : ones(3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">h (generic function with 2 methods)</code></pre><p>where <code>idxs</code> can be an integer for which variable in the history to compute, and here for any number <code>idxs</code> we give back <code>1.0</code>. Note that if we wanted to use past values of the <code>i</code>th derivative, then we would call the history function <code>h(p, t, Val{i})</code> in our DDE function and would have to define a dispatch like</p><pre><code class="language-julia hljs">h(p, t, ::Type{Val{1}}) = zeros(3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">h (generic function with 3 methods)</code></pre><p>to say that derivatives before <code>t0</code> are zero for any index. Again, we could use an in-place function instead or only compute specific indices by passing an <code>idxs</code> keyword.</p><p>The functional forms for the history function are also discussed <a href="../../types/dde_types/#dde_prob">on the DDEProblem page</a>.</p><h3 id="Undeclared-Delays-and-State-Dependent-Delays-via-Residual-Control"><a class="docs-heading-anchor" href="#Undeclared-Delays-and-State-Dependent-Delays-via-Residual-Control">Undeclared Delays and State-Dependent Delays via Residual Control</a><a id="Undeclared-Delays-and-State-Dependent-Delays-via-Residual-Control-1"></a><a class="docs-heading-anchor-permalink" href="#Undeclared-Delays-and-State-Dependent-Delays-via-Residual-Control" title="Permalink"></a></h3><p>You might have noticed DifferentialEquations.jl allows you to solve problems with undeclared delays, since you can interpolate <code>h</code> at any value. This is a feature, but use it with caution. Undeclared delays can increase the error in the solution. It&#39;s recommended that you use a method with a residual control, such as <code>MethodOfSteps(RK4())</code> whenever there are undeclared delays. With this, you can use interpolated derivatives, solve functional differential equations by using quadrature on the interpolant, etc. However, note that residual control solves with a low level of accuracy, so the tolerances should be made very small, and the solution should not be trusted for more than 2-3 decimal places.</p><p>Note: <code>MethodOfSteps(RK4())</code> with undeclared delays is similar to MATLAB&#39;s <code>ddesd</code>. Thus, for example, the following is similar to solving the example from above with residual control:</p><pre><code class="language-julia hljs">prob = DDEProblem(bc_model, u0, h, tspan)
alg = MethodOfSteps(RK4())
sol = solve(prob, alg)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: 3rd order Hermite
t: 56-element Vector{Float64}:
  0.0
  0.028686567733943524
  0.05496370739439499
  0.09262168098439919
  0.13288159974251465
  0.1804089094084776
  0.23156096482005833
  0.2874595005680063
  0.3464935321366882
  0.4086599803961283
  ⋮
  6.7093049308346755
  7.07777221058625
  7.457378543067793
  7.849229962235385
  8.25388572080611
  8.67150768172502
  9.102490449787183
  9.548110530044545
 10.0
u: 56-element Vector{Vector{Float64}}:
 [1.0, 1.0, 1.0]
 [0.8651377233256287, 0.9847919107281841, 0.9871577813957303]
 [0.7576257572305956, 0.9695375733475622, 0.9754952864116233]
 [0.6264188286596774, 0.9459514615222618, 0.9589125740571018]
 [0.5111740014217758, 0.9190777340902481, 0.9413127669956879]
 [0.40210178032806015, 0.8859139644625716, 0.920659867181337]
 [0.31056687497554564, 0.8492819034092214, 0.8985424939442697]
 [0.2341894878104844, 0.8089369062072906, 0.8744786640097065]
 [0.1738223646703943, 0.7666818850181075, 0.8491794681894558]
 [0.12699228857787634, 0.723164138429855, 0.8226801154036958]
 ⋮
 [7.633676185615979e-14, 0.0007930621605245319, 0.007743140697365638]
 [2.2906540915518255e-14, 0.0005288606326468088, 0.0055750585085787546]
 [7.192688047749808e-15, 0.0003483867033721152, 0.003962425871453464]
 [2.3938300099552267e-15, 0.0002264347987418421, 0.0027774599103777805]
 [8.537748583730977e-16, 0.00014511817954229568, 0.0019191515174950037]
 [3.2907384347373503e-16, 9.169019380580966e-5, 0.0013070711750696115]
 [1.3830960929511378e-16, 5.709014771932508e-5, 0.0008771562755794093]
 [6.43142312383534e-17, 3.4981004932784286e-5, 0.0005793513779037975]
 [3.1279295903750796e-17, 2.1287294067319118e-5, 0.00037958433237791136]</code></pre><p>Note that this method can solve problems with state-dependent delays.</p><h3 id="State-Dependent-Delay-Discontinuity-Tracking"><a class="docs-heading-anchor" href="#State-Dependent-Delay-Discontinuity-Tracking">State-Dependent Delay Discontinuity Tracking</a><a id="State-Dependent-Delay-Discontinuity-Tracking-1"></a><a class="docs-heading-anchor-permalink" href="#State-Dependent-Delay-Discontinuity-Tracking" title="Permalink"></a></h3><p>State-dependent delays are problems where the delay is allowed to be a function of the current state. They can be more efficiently solved with discontinuity tracking. To do this, in DifferentialEquations.jl, requires passing lag functions <code>g(u,p,t)</code> as keyword <code>dependent_lags</code> to the <code>DDEProblem</code> definition. Other than that, everything else is the same, and one solves that problem using the common interface.</p><p>We can solve the above problem with dependent delay tracking by declaring the dependent lags and solving with a <code>MethodOfSteps</code> algorithm:</p><pre><code class="language-julia hljs">prob = DDEProblem(bc_model, u0, h, tspan; dependent_lags = ((u, p, t) -&gt; tau,))
alg = MethodOfSteps(Tsit5())
sol = solve(prob, alg)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: specialized 4th order &quot;free&quot; interpolation
t: 31-element Vector{Float64}:
  0.0
  0.05836370738671701
  0.12916108716230104
  0.21568702511913448
  0.314760119628182
  0.4264787587173874
  0.5486009987808395
  0.6801498272932349
  0.8195261222856575
  0.9657507155327404
  ⋮
  4.701318960444954
  5.319727376056641
  5.975944408683879
  6.672902485279905
  7.412222694364806
  8.2038677046622
  9.055215419712582
  9.965347976947953
 10.0
u: 31-element Vector{Vector{Float64}}:
 [1.0, 1.0, 1.0]
 [0.7447276972023368, 0.9674847415959038, 0.9739922644849844]
 [0.5208656862906424, 0.9216176731989374, 0.9429345991317408]
 [0.3364796171856176, 0.8607107651542081, 0.9053954304005898]
 [0.2040208069499486, 0.7893156323361196, 0.8627636957091346]
 [0.1160534936803686, 0.7109401281073281, 0.8151154589081274]
 [0.06263660901296746, 0.6308046447141534, 0.7637408776739649]
 [0.03223509871453403, 0.5524928145263729, 0.7096033390270903]
 [0.015946633867446297, 0.47891242587662397, 0.6540674055203148]
 [0.007620741981671972, 0.41158156825400705, 0.598282216755686]
 ⋮
 [1.6377894852907156e-9, 0.007211518659676409, 0.043270645754943715]
 [8.555303649406559e-10, 0.0036540032856269434, 0.025862654013743092]
 [6.387919733961433e-10, 0.0017756655469628245, 0.01473943042282548]
 [6.957423749031111e-10, 0.0008250177605817439, 0.007996169936622296]
 [1.1062344304712908e-9, 0.00036587475328225507, 0.004126394959863599]
 [2.7421648834392112e-9, 0.0001531915354119481, 0.002008476279135364]
 [1.0932049359081306e-8, 6.007073611751278e-5, 0.0009160349029904492]
 [6.748484828512806e-8, 2.206931785093837e-5, 0.0003918565880625686]
 [5.655297397782597e-8, 2.1246239672805988e-5, 0.0003793217423970312]</code></pre><p>Here, we treated the single lag <code>t-tau</code> as a state-dependent delay. Of course, you can then replace that tuple of functions with whatever functions match your lags.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../rode_example/">« Random Ordinary Differential Equations</a><a class="docs-footer-nextpage" href="../dae_example/">Differential Algebraic Equations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.0 on <span class="colophon-date" title="Monday 31 March 2025 00:48">Monday 31 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
