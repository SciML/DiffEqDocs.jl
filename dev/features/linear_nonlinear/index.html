<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Specifying (Non)Linear Solvers · DifferentialEquations.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-90474609-3', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://docs.sciml.ai/stable/features/linear_nonlinear/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DifferentialEquations.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/ode_example/">Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/advanced_ode_example/">Solving Stiff Equations</a></li><li><a class="tocitem" href="../../tutorials/sde_example/">Stochastic Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/rode_example/">Random Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dde_example/">Delay Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dae_example/">Differential Algebraic Equations</a></li><li><a class="tocitem" href="../../tutorials/discrete_stochastic_example/">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="tocitem" href="../../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="tocitem" href="../../tutorials/bvp_example/">Boundary Value Problems</a></li><li><a class="tocitem" href="../../tutorials/additional/">Additional Tutorials</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../basics/common_solver_opts/">Common Solver Options</a></li><li><a class="tocitem" href="../../basics/solution/">Solution Handling</a></li><li><a class="tocitem" href="../../basics/plot/">Plot Functions</a></li><li><a class="tocitem" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="tocitem" href="../../basics/problem/">Problem Interface</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="tocitem">Problem Types</span><ul><li><a class="tocitem" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="tocitem" href="../../types/ode_types/">ODE Problems</a></li><li><a class="tocitem" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="tocitem" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="tocitem" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="tocitem" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="tocitem" href="../../types/sde_types/">SDE Problems</a></li><li><a class="tocitem" href="../../types/rode_types/">RODE Problems</a></li><li><a class="tocitem" href="../../types/dde_types/">DDE Problems</a></li><li><a class="tocitem" href="../../types/dae_types/">DAE Problems</a></li><li><a class="tocitem" href="../../types/jump_types/">Jump Problems</a></li></ul></li><li><span class="tocitem">Solver Algorithms</span><ul><li><a class="tocitem" href="../../solvers/discrete_solve/">Discrete Solvers</a></li><li><a class="tocitem" href="../../solvers/ode_solve/">ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/split_ode_solve/">Split ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/steady_state_solve/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/bvp_solve/">BVP Solvers</a></li><li><a class="tocitem" href="../../solvers/jump_solve/">Jump Problem and Jump Diffusion Solvers</a></li><li><a class="tocitem" href="../../solvers/sde_solve/">SDE Solvers</a></li><li><a class="tocitem" href="../../solvers/rode_solve/">RODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dde_solve/">DDE Solvers</a></li><li><a class="tocitem" href="../../solvers/dae_solve/">DAE Solvers</a></li><li><a class="tocitem" href="../../solvers/benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="tocitem">Additional Features</span><ul><li><a class="tocitem" href="../performance_overloads/">DiffEqFunctions (Jacobians, Gradients, etc.) and Jacobian Types</a></li><li><a class="tocitem" href="../diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="tocitem" href="../diffeq_operator/">DiffEqOperators</a></li><li><a class="tocitem" href="../noise_process/">Noise Processes</a></li><li class="is-active"><a class="tocitem" href>Specifying (Non)Linear Solvers</a><ul class="internal"><li><a class="tocitem" href="#Linear-Solvers:-linsolve-Specification-1"><span>Linear Solvers: <code>linsolve</code> Specification</span></a></li></ul></li><li><a class="tocitem" href="../callback_functions/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../callback_library/">Callback Library</a></li><li><a class="tocitem" href="../ensemble/">Parallel Ensemble Simulations</a></li><li><a class="tocitem" href="../io/">I/O: Saving and Loading Solution Data</a></li><li><a class="tocitem" href="../low_dep/">Low Dependency Usage</a></li><li><a class="tocitem" href="../progress_bar/">Progress Bar Integration</a></li></ul></li><li><span class="tocitem">Analysis Tools</span><ul><li><a class="tocitem" href="../../analysis/parameterized_functions/">ParameterizedFunctions</a></li><li><a class="tocitem" href="../../analysis/parameter_estimation/">Parameter Estimation and Bayesian Analysis</a></li><li><a class="tocitem" href="../../analysis/bifurcation/">Bifurcation Analysis</a></li><li><a class="tocitem" href="../../analysis/sensitivity/">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li><a class="tocitem" href="../../analysis/global_sensitivity/">Global Sensitivity Analysis</a></li><li><a class="tocitem" href="../../analysis/uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="tocitem" href="../../analysis/neural_networks/">Neural Networks</a></li><li><a class="tocitem" href="../../analysis/dev_and_test/">Algorithm Development and Testing</a></li></ul></li><li><span class="tocitem">Domain Modeling Tools</span><ul><li><a class="tocitem" href="../../models/multiscale/">Multi-Scale Models</a></li><li><a class="tocitem" href="../../models/physical/">Physical Models</a></li><li><a class="tocitem" href="../../models/financial/">Financial Models</a></li><li><a class="tocitem" href="../../models/biological/">Chemical Reaction Models</a></li><li><a class="tocitem" href="../../models/external_modeling/">External Modeling Packages</a></li></ul></li><li><span class="tocitem">APIs</span><ul><li><a class="tocitem" href="../../apis/diffeqbio/">DiffEqBiological.jl API</a></li></ul></li><li><span class="tocitem">Extra Details</span><ul><li><a class="tocitem" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li><li><a class="tocitem" href="../../extras/sensitivity_math/">Mathematics of Sensitivity Analysis</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Additional Features</a></li><li class="is-active"><a href>Specifying (Non)Linear Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Specifying (Non)Linear Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/DiffEqDocs.jl/blob/master/docs/src/features/linear_nonlinear.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="linear_nonlinear-1"><a class="docs-heading-anchor" href="#linear_nonlinear-1">Specifying (Non)Linear Solvers</a><a class="docs-heading-anchor-permalink" href="#linear_nonlinear-1" title="Permalink"></a></h1><p>One of the key features of DifferentialEquations.jl is its flexibility. Keeping with this trend, many of the native Julia solvers provided by DifferentialEquations.jl allow you to choose the method for linear and nonlinear solving. This section details how to make that choice.</p><h2 id="Linear-Solvers:-linsolve-Specification-1"><a class="docs-heading-anchor" href="#Linear-Solvers:-linsolve-Specification-1">Linear Solvers: <code>linsolve</code> Specification</a><a class="docs-heading-anchor-permalink" href="#Linear-Solvers:-linsolve-Specification-1" title="Permalink"></a></h2><p>For differential equation integrators which use linear solvers, an argument to the method <code>linsolve</code> determines the linear solver which is used. The signature is:</p><pre><code class="language-julia">linsolve! = linsolve(Val{:init},f,x;kwargs...)
linsolve!(x,A,b,matrix_updated=false;kwargs...)</code></pre><p>This is an in-place function which updates <code>x</code> by solving <code>Ax=b</code>. The user should specify the function <code>linsolve(Val{:init},f,x)</code> which returns a <code>linsolve!</code> function. The setting <code>matrix_updated</code> determines whether the matrix <code>A</code> has changed from the last call. This can be used to smartly cache factorizations.</p><p>Note that <code>linsolve!</code> needs to accept splatted keyword arguments. The possible arguments passed to the linear solver are as follows:</p><ul><li><code>Pl</code>, a pre-specified left preconditioner which utilizes the internal adaptive norm estimates</li><li><code>Pr</code>, a pre-specified right preconditioner which utilizes the internal adaptive norm estimates</li><li><code>tol</code>, a linear solver tolerance specified from the ODE solver&#39;s implicit handling</li></ul><h3 id="Pre-Built-Linear-Solver-Choices-1"><a class="docs-heading-anchor" href="#Pre-Built-Linear-Solver-Choices-1">Pre-Built Linear Solver Choices</a><a class="docs-heading-anchor-permalink" href="#Pre-Built-Linear-Solver-Choices-1" title="Permalink"></a></h3><p>The following choices of pre-built linear solvers exist:</p><ul><li>DefaultLinSolve</li><li>LinSolveFactorize</li><li>LinSolveGPUFactorize</li><li>LinSolveGMRES</li><li>LinSolveCG</li><li>LinSolveBiCGStabl</li><li>LinSolveChebyshev</li><li>LinSolveMINRES</li><li>LinSolveIterativeSolvers</li></ul><h3 id="DefaultLinSolve-1"><a class="docs-heading-anchor" href="#DefaultLinSolve-1">DefaultLinSolve</a><a class="docs-heading-anchor-permalink" href="#DefaultLinSolve-1" title="Permalink"></a></h3><p>The default linear solver is <code>DefaultLinSolve</code>. This method is adaptive, and automatically chooses an LU factorization choose for dense and sparse arrays, and is compatible with GPU-based arrays. When the Jacobian is an <code>AbstractDiffEqOperator</code>, i.e. is matrix-free, <code>DefaultLinSolve</code> defaults to using a <code>gmres</code> iterative solver.</p><h3 id="Basic-linsolve-method-choice:-Factorization-by-LinSolveFactorize-1"><a class="docs-heading-anchor" href="#Basic-linsolve-method-choice:-Factorization-by-LinSolveFactorize-1">Basic linsolve method choice: Factorization by LinSolveFactorize</a><a class="docs-heading-anchor-permalink" href="#Basic-linsolve-method-choice:-Factorization-by-LinSolveFactorize-1" title="Permalink"></a></h3><p>The easiest way to specify a <code>linsolve</code> is by a <code>factorization</code> function which generates a type on which <code>\</code> (or <code>A_ldiv_B!</code>) is called.  This is done through the helper function <code>LinSolveFactorize</code> which makes the appropriate function. For example, the  <code>Rosenbrock23</code> takes in a <code>linsolve</code> function, which we can choose to be a  QR-factorization by:</p><pre><code class="language-julia">Rosenbrock23(linsolve=LinSolveFactorize(qrfact!))</code></pre><p>LinSolveFactorize takes in a function which returns an object that can <code>\</code>. Direct methods like <code>qrfact!</code> will automatically cache the factorization, making it efficient for small dense problems.</p><p>However, for large sparse problems, you can let <code>\</code> be an iterative method. For example, using PETSc.jl, we can define our factorization function to be:</p><pre><code class="language-julia">linsolve = LinSolveFactorize((A) -&gt; KSP(A, ksp_type=&quot;gmres&quot;, ksp_rtol=1e-6))</code></pre><p>This function creates a <code>KSP</code> type which makes <code>\</code> perform the GMRES iterative method provided by PETSc.jl. Thus if we pass this function into the algorithm as the factorization method, all internal linear solves will happen by PETSc.jl.</p><h3 id="GPU-offloading-of-factorization-with-LinSolveGPUFactorize-1"><a class="docs-heading-anchor" href="#GPU-offloading-of-factorization-with-LinSolveGPUFactorize-1">GPU offloading of factorization with LinSolveGPUFactorize</a><a class="docs-heading-anchor-permalink" href="#GPU-offloading-of-factorization-with-LinSolveGPUFactorize-1" title="Permalink"></a></h3><p>If one has a problem with a sufficiently large Jacobian (~100x100) and a sufficiently powerful GPU, it can make sense to offload the factorization and backpropogation steps to the GPU. For this, the <code>LinSolveGPUFactorize</code> linear solver is provided. It works similarly to <code>LinSolveFactorize</code>, but the matrix is automatically sent to the GPU as a <code>CuArray</code> and the <code>ldiv!</code> is performed against a CUDA QR factorization of the matrix.</p><p>Note that this method requires that you have done <code>using CuArrays</code> in your script. A working installation of CuArrays.jl is required, which requires an installation of CUDA Toolkit.</p><h3 id="iterativesolvers-jl-1"><a class="docs-heading-anchor" href="#iterativesolvers-jl-1">IterativeSolvers.jl-Based Methods</a><a class="docs-heading-anchor-permalink" href="#iterativesolvers-jl-1" title="Permalink"></a></h3><p>The signature for <code>LinSolveIterativeSolvers</code> is:</p><pre><code class="language-julia">LinSolveIterativeSolvers(generate_iterator,args...;
                         Pl=IterativeSolvers.Identity(),
                         Pr=IterativeSolvers.Identity(),
                         kwargs...)</code></pre><p>where <code>Pl</code> is the left preconditioner, <code>Pr</code> is the right preconditioner, and the other <code>args...</code> and <code>kwargs...</code> are passed into the iterative solver chosen in <code>generate_iterator</code> which designates the construction of an iterator from IterativeSolvers.jl. For example, using <code>gmres_iterable!</code> would make a version that uses <code>IterativeSolvers.gmres</code>. The following are aliases to common choices:</p><ul><li>LinSolveGMRES – GMRES</li><li>LinSolveCG – CG (Conjugate Gradient)</li><li>LinSolveBiCGStabl – BiCGStabl Stabilized Bi-Conjugate Gradient</li><li>LinSolveChebyshev – Chebyshev</li><li>LinSolveMINRES – MINRES</li></ul><p>which all have the same arguments as <code>LinSolveIterativeSolvers</code> except with <code>generate_iterator</code> pre-specified.</p><h3 id="Implementing-Your-Own-LinSolve:-How-LinSolveFactorize-Was-Created-1"><a class="docs-heading-anchor" href="#Implementing-Your-Own-LinSolve:-How-LinSolveFactorize-Was-Created-1">Implementing Your Own LinSolve: How LinSolveFactorize Was Created</a><a class="docs-heading-anchor-permalink" href="#Implementing-Your-Own-LinSolve:-How-LinSolveFactorize-Was-Created-1" title="Permalink"></a></h3><p>In order to make your own <code>linsolve</code> functions, let&#39;s look at how the <code>LinSolveFactorize</code> function is created. For example, for an LU-Factorization, we would like to use <code>lufact!</code> to do our linear solving. We can directly write this as:</p><pre><code class="language-julia">function linsolve!(::Type{Val{:init}},f,u0,kwargs...)
  function _linsolve!(x,A,b,update_matrix=false,kwargs...)
    _A = lufact!(A)
    ldiv!(x,_A,b)
  end
end</code></pre><p>This initialization function returns a linear solving function that always computes the LU-factorization and then does the solving. This method works fine and you can pass it to the methods like</p><pre><code class="language-julia">Rosenbrock23(linsolve=linsolve!)</code></pre><p>and it will work, but this method does not cache <code>_A</code>, the factorization. This means that, even if <code>A</code> has not changed, it will re-factorize the matrix.</p><p>To change this, we can instead create a call-overloaded type. The generalized form of this is:</p><pre><code class="language-julia">mutable struct LinSolveFactorize{F}
  factorization::F
  A
end
LinSolveFactorize(factorization) = LinSolveFactorize(factorization,nothing)
function (p::LinSolveFactorize)(x,A,b,matrix_updated=false)
  if matrix_updated
    p.A = p.factorization(A)
  end
  A_ldiv_B!(x,p.A,b)
end
function (p::LinSolveFactorize)(::Type{Val{:init}},f,u0_prototype)
  LinSolveFactorize(p.factorization,nothing)
end
linsolve = LinSolveFactorize(lufact!)</code></pre><p><code>LinSolveFactorize</code> is a type which holds the factorization method and the pre-factorized matrix. When <code>linsolve</code> is passed to the ODE/SDE/etc. solver, it will use the function <code>linsolve(Val{:init},f,u0_prototype)</code> to create a <code>LinSolveFactorize</code> object which holds the factorization method and a cache for holding a factorized matrix. Then</p><pre><code class="language-julia">function (p::LinSolveFactorize)(x,A,b,matrix_updated=false)
  if matrix_updated
    p.A = p.factorization(A)
  end
  A_ldiv_B!(x,p.A,b)
end</code></pre><p>is what&#39;s used in the solver&#39;s internal loop. If <code>matrix_updated</code> is true, it will re-compute the factorization. Otherwise it just solves the linear system with the cached factorization. This general idea of using a call-overloaded type can be employed to do many other things.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../noise_process/">« Noise Processes</a><a class="docs-footer-nextpage" href="../callback_functions/">Event Handling and Callback Functions »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 19 July 2020 12:58">Sunday 19 July 2020</span>. Using Julia version 1.1.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
