<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Event Handling and Callback Functions · DifferentialEquations.jl</title><meta name="title" content="Event Handling and Callback Functions · DifferentialEquations.jl"/><meta property="og:title" content="Event Handling and Callback Functions · DifferentialEquations.jl"/><meta property="twitter:title" content="Event Handling and Callback Functions · DifferentialEquations.jl"/><meta name="description" content="Documentation for DifferentialEquations.jl."/><meta property="og:description" content="Documentation for DifferentialEquations.jl."/><meta property="twitter:description" content="Documentation for DifferentialEquations.jl."/><meta property="og:url" content="https://docs.sciml.ai/DiffEqDocs/stable/features/callback_functions/"/><meta property="twitter:url" content="https://docs.sciml.ai/DiffEqDocs/stable/features/callback_functions/"/><link rel="canonical" href="https://docs.sciml.ai/DiffEqDocs/stable/features/callback_functions/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DifferentialEquations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">DifferentialEquations.jl: Efficient Differential Equation Solving in Julia</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started with Differential Equations in Julia</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/faster_ode_example/">Code Optimization for Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/advanced_ode_example/">Solving Large Stiff Equations</a></li><li><a class="tocitem" href="../../tutorials/sde_example/">Stochastic Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/rode_example/">Random Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dde_example/">Delay Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dae_example/">Differential Algebraic Equations</a></li><li><a class="tocitem" href="../../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="tocitem" href="../../tutorials/bvp_example/">Boundary Value Problems</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Beginner</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/classical_physics/">Classical Physics Models</a></li><li><a class="tocitem" href="../../examples/conditional_dosing/">Conditional Dosing in Pharmacometrics</a></li><li><a class="tocitem" href="../../examples/kepler_problem/">The Kepler Problem</a></li><li><a class="tocitem" href="../../examples/outer_solar_system/">Simulating the Outer Solar System</a></li><li><a class="tocitem" href="../../examples/min_and_max/">Finding Maxima and Minima of ODEs Solutions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Advanced</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/spiking_neural_systems/">Spiking Neural Systems</a></li><li><a class="tocitem" href="../../examples/beeler_reuter/">An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model</a></li><li><a class="tocitem" href="../../examples/diffusion_implicit_heat_equation/">Solving the heat equation with diffusion-implicit time-stepping</a></li></ul></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../basics/common_solver_opts/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../basics/solution/">Solution Handling</a></li><li><a class="tocitem" href="../../basics/plot/">Plot Functions</a></li><li><a class="tocitem" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="tocitem" href="../../basics/problem/">Problem Interface</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="tocitem">Problem Types</span><ul><li><a class="tocitem" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="tocitem" href="../../types/ode_types/">ODE Problems</a></li><li><a class="tocitem" href="../../types/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group Problems</a></li><li><a class="tocitem" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="tocitem" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="tocitem" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="tocitem" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="tocitem" href="../../types/sde_types/">SDE Problems</a></li><li><a class="tocitem" href="../../types/sdae_types/">SDAE Problems</a></li><li><a class="tocitem" href="../../types/rode_types/">RODE Problems</a></li><li><a class="tocitem" href="../../types/dde_types/">DDE Problems</a></li><li><a class="tocitem" href="../../types/sdde_types/">SDDE Problems</a></li><li><a class="tocitem" href="../../types/dae_types/">DAE Problems</a></li></ul></li><li><span class="tocitem">Solver Algorithms</span><ul><li><a class="tocitem" href="../../solvers/discrete_solve/">Discrete Solvers</a></li><li><a class="tocitem" href="../../solvers/ode_solve/">ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/split_ode_solve/">Split ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/steady_state_solve/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/bvp_solve/">BVP Solvers</a></li><li><a class="tocitem" href="../../solvers/sde_solve/">SDE Solvers</a></li><li><a class="tocitem" href="../../solvers/sdae_solve/">SDAE Solvers</a></li><li><a class="tocitem" href="../../solvers/rode_solve/">RODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dde_solve/">DDE Solvers</a></li><li><a class="tocitem" href="../../solvers/sdde_solve/">SDDE Solvers</a></li><li><a class="tocitem" href="../../solvers/dae_solve/">Mass Matrix and Fully Implicit DAE Solvers</a></li><li><a class="tocitem" href="../../solvers/benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="tocitem">Additional Features</span><ul><li><a class="tocitem" href="../performance_overloads/">Jacobians, Gradients, etc.</a></li><li><a class="tocitem" href="../diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="tocitem" href="../diffeq_operator/">DiffEqOperators</a></li><li><a class="tocitem" href="../noise_process/">Noise Processes</a></li><li><a class="tocitem" href="../linear_nonlinear/">Specifying (Non)Linear Solvers and Preconditioners</a></li><li class="is-active"><a class="tocitem" href>Event Handling and Callback Functions</a><ul class="internal"><li><a class="tocitem" href="#The-Callback-Types"><span>The Callback Types</span></a></li><li><a class="tocitem" href="#Using-Callbacks"><span>Using Callbacks</span></a></li><li><a class="tocitem" href="#DiscreteCallback-Examples"><span>DiscreteCallback Examples</span></a></li><li><a class="tocitem" href="#ContinuousCallback-Examples"><span>ContinuousCallback Examples</span></a></li><li><a class="tocitem" href="#VectorContinuousCallback-Example"><span>VectorContinuousCallback Example</span></a></li></ul></li><li><a class="tocitem" href="../callback_library/">Callback Library</a></li><li><a class="tocitem" href="../ensemble/">Parallel Ensemble Simulations</a></li><li><a class="tocitem" href="../io/">I/O: Saving and Loading Solution Data</a></li><li><a class="tocitem" href="../low_dep/">Reduced Compile Time, Optimizing Runtime, and Low Dependency Usage</a></li><li><a class="tocitem" href="../progress_bar/">Progress Bar Integration</a></li></ul></li><li><span class="tocitem">Detailed Solver APIs</span><ul><li><a class="tocitem" href="../../api/sundials/">Sundials.jl</a></li><li><a class="tocitem" href="../../api/daskr/">DASKR.jl</a></li></ul></li><li><span class="tocitem">Extra Details</span><ul><li><a class="tocitem" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Additional Features</a></li><li class="is-active"><a href>Event Handling and Callback Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Event Handling and Callback Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/DiffEqDocs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/DiffEqDocs.jl/blob/master/docs/src/features/callback_functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="callbacks"><a class="docs-heading-anchor" href="#callbacks">Event Handling and Callback Functions</a><a id="callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#callbacks" title="Permalink"></a></h1><p>DifferentialEquations.jl allows for using callback functions to inject user code into the solver algorithms. It allows for safely and accurately applying events and discontinuities. Multiple callbacks can be chained together, and these callback types can be used to build libraries of extension behavior.</p><h2 id="The-Callback-Types"><a class="docs-heading-anchor" href="#The-Callback-Types">The Callback Types</a><a id="The-Callback-Types-1"></a><a class="docs-heading-anchor-permalink" href="#The-Callback-Types" title="Permalink"></a></h2><p>The callback types are defined as follows. There are three primitive callback types: the <code>ContinuousCallback</code>, <code>DiscreteCallback</code> and the <code>VectorContinuousCallback</code>:</p><ul><li>The <a href="#ContinuousCallback"><code>ContinuousCallback</code></a> is applied when a given continuous <em>condition function</em> hits zero. This hitting can happen even within an integration step, and the solver must be able to detect it and adjust the integration step accordingly. This type of callback implements what is known in other problem-solving environments as an <em>Event</em>.</li><li>The <a href="#SciMLBase.DiscreteCallback"><code>DiscreteCallback</code></a> is applied when its <em>condition function</em> is <code>true</code>, but the condition is only evaluated at the end of every integration step.</li><li>The <a href="#VectorContinuousCallback"><code>VectorContinuousCallback</code></a> works like a vector of <code>ContinuousCallbacks</code> and lets the user specify a vector of continuous callbacks, each with simultaneous rootfinding equations. The effect that is applied is the effect corresponding to the first (earliest) condition that is satisfied. A <code>VectorContinuousCallback</code> is more efficient than a <code>CallbackSet</code> of <code>ContinuousCallback</code>s as the number of callbacks grows. As such, it&#39;s a slightly more involved definition which gives better scaling.</li></ul><h3 id="ContinuousCallback"><a class="docs-heading-anchor" href="#ContinuousCallback">ContinuousCallback</a><a id="ContinuousCallback-1"></a><a class="docs-heading-anchor-permalink" href="#ContinuousCallback" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.ContinuousCallback" href="#SciMLBase.ContinuousCallback"><code>SciMLBase.ContinuousCallback</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ContinuousCallback(condition, affect!, affect_neg!;
    initialize = INITIALIZE_DEFAULT,
    finalize = FINALIZE_DEFAULT,
    idxs = nothing,
    rootfind = LeftRootFind,
    save_positions = (true, true),
    interp_points = 10,
    abstol = 10eps(), reltol = 0, repeat_nudge = 1 // 100)</code></pre><pre><code class="language-julia hljs">ContinuousCallback(condition, affect!;
    initialize = INITIALIZE_DEFAULT,
    finalize = FINALIZE_DEFAULT,
    idxs = nothing,
    rootfind = LeftRootFind,
    save_positions = (true, true),
    affect_neg! = affect!,
    interp_points = 10,
    abstol = 10eps(), reltol = 0, repeat_nudge = 1 // 100)</code></pre><p>Contains a single callback whose <code>condition</code> is a continuous function. The callback is triggered when this function evaluates to 0.</p><p><strong>Arguments</strong></p><ul><li><code>condition</code>: This is a function <code>condition(u,t,integrator)</code> for declaring when the callback should be used. A callback is initiated if the condition hits <code>0</code> within the time interval. See the <a href="../../basics/integrator/#integrator">Integrator Interface</a> documentation for information about <code>integrator</code>.</li><li><code>affect!</code>: This is the function <code>affect!(integrator)</code> where one is allowed to modify the current state of the integrator. If you do not pass an <code>affect_neg!</code> function, it is called when <code>condition</code> is found to be <code>0</code> (at a root) and the cross is either an upcrossing (from negative to positive) or a downcrossing (from positive to negative). You need to explicitly pass <code>nothing</code> as the <code>affect_neg!</code> argument if it should only be called at upcrossings, e.g. <code>ContinuousCallback(condition, affect!, nothing)</code>. For more information on what can be done, see the <a href="../../basics/integrator/#integrator">Integrator Interface</a> manual page. Modifications to <code>u</code> are safe in this function.</li><li><code>affect_neg!=affect!</code>: This is the function <code>affect_neg!(integrator)</code> where one is allowed to modify the current state of the integrator. This is called when <code>condition</code> is found to be <code>0</code> (at a root) and the cross is a downcrossing (from positive to negative). For more information on what can be done, see the <a href="../../basics/integrator/#integrator">Integrator Interface</a> manual page. Modifications to <code>u</code> are safe in this function.</li><li><code>rootfind=LeftRootFind</code>: This is a flag to specify the type of rootfinding to do for finding event location. If this is set to <code>LeftRootfind</code>, the solution will be backtracked to the point where <code>condition==0</code> and if the solution isn&#39;t exact, the left limit of root is used. If set to <code>RightRootFind</code>, the solution would be set to the right limit of the root. Otherwise, the systems and the <code>affect!</code> will occur at <code>t+dt</code>. Note that these enums are not exported, and thus one needs to reference them as <code>SciMLBase.LeftRootFind</code>, <code>SciMLBase.RightRootFind</code>, or <code>SciMLBase.NoRootFind</code>.</li><li><code>interp_points=10</code>: The number of interpolated points to check the condition. The condition is found by checking whether any interpolation point / endpoint has a different sign. If <code>interp_points=0</code>, then conditions will only be noticed if the sign of <code>condition</code> is different at <code>t</code> than at <code>t+dt</code>. This behavior is not robust when the solution is oscillatory, and thus it&#39;s recommended that one use some interpolation points (they&#39;re cheap to compute!). <code>0</code> within the time interval.</li><li><code>save_positions=(true,true)</code>: Boolean tuple for whether to save before and after the <code>affect!</code>. This saving will occur just before and after the event, only at event times, and does not depend on options like <code>saveat</code>, <code>save_everystep</code>, etc. (i.e. if <code>saveat=[1.0,2.0,3.0]</code>, this can still add a save point at <code>2.1</code> if true). For discontinuous changes like a modification to <code>u</code> to be handled correctly (without error), one should set <code>save_positions=(true,true)</code>.</li><li><code>idxs=nothing</code>: The components which will be interpolated into the condition. Defaults to <code>nothing</code> which means <code>u</code> will be all components.</li><li><code>initialize</code>: This is a function <code>(c,u,t,integrator)</code> which can be used to initialize the state of the callback <code>c</code>. It should modify the argument <code>c</code> and the return is ignored.</li><li><code>finalize</code>: This is a function <code>(c,u,t,integrator)</code> which can be used to finalize the state of the callback <code>c</code>. It can modify the argument <code>c</code> and the return is ignored.</li><li><code>abstol=1e-14</code> &amp; <code>reltol=0</code>: These are used to specify a tolerance from zero for the rootfinder: if the starting condition is less than the tolerance from zero, then no root will be detected. This is to stop repeat events happening immediately after a rootfinding event.</li><li><code>repeat_nudge = 1//100</code>: This is used to set the next testing point after a previously found zero. Defaults to 1//100, which means after a callback, the next sign check will take place at t + dt*1//100 instead of at t to avoid repeats.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.52.0/src/callbacks.jl#L16-L94">source</a></section></article><h3 id="discrete_callback"><a class="docs-heading-anchor" href="#discrete_callback">DiscreteCallback</a><a id="discrete_callback-1"></a><a class="docs-heading-anchor-permalink" href="#discrete_callback" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.DiscreteCallback" href="#SciMLBase.DiscreteCallback"><code>SciMLBase.DiscreteCallback</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DiscreteCallback(condition, affect!;
    initialize = INITIALIZE_DEFAULT,
    finalize = FINALIZE_DEFAULT,
    save_positions = (true, true))</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>condition</code>: This is a function <code>condition(u,t,integrator)</code> for declaring when the callback should be used. A callback is initiated if the condition evaluates to <code>true</code>. See the <a href="../../basics/integrator/#integrator">Integrator Interface</a> documentation for information about <code>integrator</code>.</p><ul><li><code>affect!</code>: This is the function <code>affect!(integrator)</code> where one is allowed to modify the current state of the integrator. For more information on what can be done, see the <a href="../../basics/integrator/#integrator">Integrator Interface</a> manual page.</li></ul></li><li><p><code>save_positions</code>: Boolean tuple for whether to save before and after the <code>affect!</code>. This saving will occur just before and after the event, only at event times, and does not depend on options like <code>saveat</code>, <code>save_everystep</code>, etc. (i.e. if <code>saveat=[1.0,2.0,3.0]</code>, this can still add a save point at <code>2.1</code> if true). For discontinuous changes like a modification to <code>u</code> to be handled correctly (without error), one should set <code>save_positions=(true,true)</code>.</p></li><li><p><code>initialize</code>: This is a function <code>(c,u,t,integrator)</code> which can be used to initialize the state of the callback <code>c</code>. It should modify the argument <code>c</code> and the return is ignored.</p></li><li><p><code>finalize</code>: This is a function <code>(c,u,t,integrator)</code> which can be used to finalize the state of the callback <code>c</code>. It should can the argument <code>c</code> and the return is ignored.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.52.0/src/callbacks.jl#L264-L294">source</a></section></article><h3 id="CallbackSet"><a class="docs-heading-anchor" href="#CallbackSet">CallbackSet</a><a id="CallbackSet-1"></a><a class="docs-heading-anchor-permalink" href="#CallbackSet" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.CallbackSet" href="#SciMLBase.CallbackSet"><code>SciMLBase.CallbackSet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct CallbackSet{T1&lt;:Tuple, T2&lt;:Tuple} &lt;: SciMLBase.DECallback</code></pre><p>Multiple callbacks can be chained together to form a <code>CallbackSet</code>. A <code>CallbackSet</code> is constructed by passing the constructor <code>ContinuousCallback</code>, <code>DiscreteCallback</code>, <code>VectorContinuousCallback</code> or other <code>CallbackSet</code> instances:</p><pre><code class="nohighlight hljs">CallbackSet(cb1,cb2,cb3)</code></pre><p>You can pass as many callbacks as you like. When the solvers encounter multiple callbacks, the following rules apply:</p><ul><li><code>ContinuousCallback</code>s and <code>VectorContinuousCallback</code>s are applied before <code>DiscreteCallback</code>s. (This is because they often implement event-finding that will backtrack the timestep to smaller than <code>dt</code>).</li><li>For <code>ContinuousCallback</code>s and <code>VectorContinuousCallback</code>s, the event times are found by rootfinding and only the first <code>ContinuousCallback</code> or <code>VectorContinuousCallback</code> affect is applied.</li><li>The <code>DiscreteCallback</code>s are then applied in order. Note that the ordering only matters for the conditions: if a previous callback modifies <code>u</code> in such a way that the next callback no longer evaluates condition to <code>true</code>, its <code>affect</code> will not be applied.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.52.0/src/callbacks.jl#L316">source</a></section></article><h3 id="VectorContinuousCallback"><a class="docs-heading-anchor" href="#VectorContinuousCallback">VectorContinuousCallback</a><a id="VectorContinuousCallback-1"></a><a class="docs-heading-anchor-permalink" href="#VectorContinuousCallback" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.VectorContinuousCallback" href="#SciMLBase.VectorContinuousCallback"><code>SciMLBase.VectorContinuousCallback</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VectorContinuousCallback(condition, affect!, affect_neg!, len;
    initialize = INITIALIZE_DEFAULT,
    finalize = FINALIZE_DEFAULT,
    idxs = nothing,
    rootfind = LeftRootFind,
    save_positions = (true, true),
    interp_points = 10,
    abstol = 10eps(), reltol = 0, repeat_nudge = 1 // 100)</code></pre><pre><code class="language-julia hljs">VectorContinuousCallback(condition, affect!, len;
    initialize = INITIALIZE_DEFAULT,
    finalize = FINALIZE_DEFAULT,
    idxs = nothing,
    rootfind = LeftRootFind,
    save_positions = (true, true),
    affect_neg! = affect!,
    interp_points = 10,
    abstol = 10eps(), reltol = 0, repeat_nudge = 1 // 100)</code></pre><p>This is also a subtype of <code>AbstractContinuousCallback</code>. <code>CallbackSet</code> is not feasible when you have many callbacks, as it doesn&#39;t scale well. For this reason, we have <code>VectorContinuousCallback</code> - it allows you to have a single callback for multiple events.</p><p><strong>Arguments</strong></p><ul><li><code>condition</code>: This is a function <code>condition(out, u, t, integrator)</code> which should save the condition value in the array <code>out</code> at the right index. Maximum index of <code>out</code> should be specified in the <code>len</code> property of callback. So, this way you can have a chain of <code>len</code> events, which would cause the <code>i</code>th event to trigger when <code>out[i] = 0</code>.</li><li><code>affect!</code>: This is a function <code>affect!(integrator, event_index)</code> which lets you modify <code>integrator</code> and it tells you about which event occurred using <code>event_idx</code> i.e. gives you index <code>i</code> for which <code>out[i]</code> came out to be zero.</li><li><code>len</code>: Number of callbacks chained. This is compulsory to be specified.</li></ul><p>Rest of the arguments have the same meaning as in <a href="#ContinuousCallback"><code>ContinuousCallback</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.52.0/src/callbacks.jl#L158-L196">source</a></section></article><h2 id="Using-Callbacks"><a class="docs-heading-anchor" href="#Using-Callbacks">Using Callbacks</a><a id="Using-Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Callbacks" title="Permalink"></a></h2><p>The callback type is then sent to the solver (or the integrator) via the <code>callback</code> keyword argument:</p><pre><code class="language-julia hljs">sol = solve(prob, alg, callback = cb)</code></pre><p>You can supply <code>nothing</code>, a single <code>DiscreteCallback</code> or <code>ContinuousCallback</code> or <code>VectorContinuousCallback</code>, or a <code>CallbackSet</code>.</p><h3 id="Note-About-Saving"><a class="docs-heading-anchor" href="#Note-About-Saving">Note About Saving</a><a id="Note-About-Saving-1"></a><a class="docs-heading-anchor-permalink" href="#Note-About-Saving" title="Permalink"></a></h3><p>When a callback is supplied, the default saving behavior is turned off. This is because otherwise, events would “double save” one of the values. To re-enable the standard saving behavior, one must have the first <code>save_positions</code> value be true for at least one callback.</p><h3 id="Modifying-the-Stepping-Within-A-Callback"><a class="docs-heading-anchor" href="#Modifying-the-Stepping-Within-A-Callback">Modifying the Stepping Within A Callback</a><a id="Modifying-the-Stepping-Within-A-Callback-1"></a><a class="docs-heading-anchor-permalink" href="#Modifying-the-Stepping-Within-A-Callback" title="Permalink"></a></h3><p>A common issue with callbacks is that they cause a large discontinuous change, and so it may be wise to pull down <code>dt</code> after such a change. To control the timestepping from a callback, please see <a href="../../basics/integrator/#stepping_controls">the timestepping controls in the integrator interface</a>. Specifically, <code>set_proposed_dt!</code> is used to set the next stepsize, and <code>terminate!</code> can be used to cause the simulation to stop.</p><h2 id="DiscreteCallback-Examples"><a class="docs-heading-anchor" href="#DiscreteCallback-Examples">DiscreteCallback Examples</a><a id="DiscreteCallback-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#DiscreteCallback-Examples" title="Permalink"></a></h2><h3 id="Example-1:-Interventions-at-Preset-Times"><a class="docs-heading-anchor" href="#Example-1:-Interventions-at-Preset-Times">Example 1: Interventions at Preset Times</a><a id="Example-1:-Interventions-at-Preset-Times-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Interventions-at-Preset-Times" title="Permalink"></a></h3><p>Assume we have a patient whose internal drug concentration follows exponential decay, i.e. the linear ODE with a negative coefficient:</p><pre><code class="language-julia hljs">using DifferentialEquations
function f(du, u, p, t)
    du[1] = -u[1]
end
u0 = [10.0]
const V = 1
prob = ODEProblem(f, u0, (0.0, 10.0))
sol = solve(prob, Tsit5())
using Plots;
plot(sol);</code></pre><img src="38c3d05d.svg" alt="Example block output"/><p>Now assume we wish to give the patient a dose of 10 at time <code>t==4</code>. For this, we can use a <code>DiscreteCallback</code> which will only be true at <code>t==4</code>:</p><pre><code class="language-julia hljs">condition(u, t, integrator) = t == 4
affect!(integrator) = integrator.u[1] += 10
cb = DiscreteCallback(condition, affect!)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DiscreteCallback{typeof(Main.condition), typeof(Main.affect!), typeof(SciMLBase.INITIALIZE_DEFAULT), typeof(SciMLBase.FINALIZE_DEFAULT)}(Main.condition, Main.affect!, SciMLBase.INITIALIZE_DEFAULT, SciMLBase.FINALIZE_DEFAULT, Bool[1, 1])</code></pre><p>If we then solve with this callback enabled, we see no change:</p><pre><code class="language-julia hljs">sol = solve(prob, Tsit5(), callback = cb)
plot(sol)</code></pre><img src="24a78ec1.svg" alt="Example block output"/><p>The reason there is no change is because the <code>DiscreteCallback</code> only applies at a specific time, and the integrator never hit that time. Thus we would like to force the ODE solver to step exactly at <code>t=4</code> so that the condition can be applied. We can do that with the <code>tstops</code> argument:</p><pre><code class="language-julia hljs">sol = solve(prob, Tsit5(), callback = cb, tstops = [4.0])
plot(sol)</code></pre><img src="b86002eb.svg" alt="Example block output"/><p>and thus we achieve the desired result.</p><p>Performing multiple doses then just requires that we have multiple points which are hit. For example, to dose at time <code>t=4</code> and <code>t=8</code>, we can do the following:</p><pre><code class="language-julia hljs">dosetimes = [4.0, 8.0]
condition(u, t, integrator) = t ∈ dosetimes
affect!(integrator) = integrator.u[1] += 10
cb = DiscreteCallback(condition, affect!)
sol = solve(prob, Tsit5(), callback = cb, tstops = dosetimes)
plot(sol)</code></pre><img src="c828c557.svg" alt="Example block output"/><p>We can then use this mechanism to make the model arbitrarily complex. For example, let&#39;s say there&#39;s now 3 dose times, but the dose only triggers if the current concentration is below 1.0. Additionally, the dose is now <code>10t</code> instead of just <code>10</code>. This model is implemented as simply:</p><pre><code class="language-julia hljs">dosetimes = [4.0, 6.0, 8.0]
condition(u, t, integrator) = t ∈ dosetimes &amp;&amp; (u[1] &lt; 1.0)
affect!(integrator) = integrator.u[1] += 10integrator.t
cb = DiscreteCallback(condition, affect!)
sol = solve(prob, Tsit5(), callback = cb, tstops = dosetimes)
plot(sol)</code></pre><img src="84e088c2.svg" alt="Example block output"/><h4 id="PresetTimeCallback"><a class="docs-heading-anchor" href="#PresetTimeCallback">PresetTimeCallback</a><a id="PresetTimeCallback-1"></a><a class="docs-heading-anchor-permalink" href="#PresetTimeCallback" title="Permalink"></a></h4><p>Because events at preset times is a very common occurrence, DifferentialEquations.jl provides a pre-built callback in the <a href="../callback_library/#callback_library">Callback Library</a>. The <code>PresetTimeCallback(tstops,affect!)</code> takes an array of times and an <code>affect!</code> function to apply. Thus to do the simple 2 dose example with this callback, we could do the following:</p><pre><code class="language-julia hljs">dosetimes = [4.0, 8.0]
affect!(integrator) = integrator.u[1] += 10
cb = PresetTimeCallback(dosetimes, affect!)
sol = solve(prob, Tsit5(), callback = cb)
plot(sol)</code></pre><img src="c4222e35.svg" alt="Example block output"/><p>Notice that this version will automatically set the <code>tstops</code> for you.</p><h3 id="Example-2:-A-Control-Problem"><a class="docs-heading-anchor" href="#Example-2:-A-Control-Problem">Example 2: A Control Problem</a><a id="Example-2:-A-Control-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-A-Control-Problem" title="Permalink"></a></h3><p>Another example of a <code>DiscreteCallback</code> is a control problem switching parameters. Our parameterized ODE system is as follows:</p><p>Our ODE function will use this field as follows:</p><pre><code class="language-julia hljs">function f(du, u, p, t)
    du[1] = -0.5 * u[1] + p
    du[2] = -0.5 * u[2]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">f (generic function with 1 method)</code></pre><p>Now we will setup our control mechanism. It will be a simple setup which uses set timepoints at which we will change <code>p</code>. At <code>t=5.0</code> we will want to increase the value of <code>p</code>, and at <code>t=8.0</code> we will want to decrease the value of <code>p</code>. Using the <a href="#discrete_callback"><code>DiscreteCallback</code> interface</a>, we code these conditions as follows:</p><pre><code class="language-julia hljs">const tstop1 = [5.0]
const tstop2 = [8.0]

function condition(u, t, integrator)
    t in tstop1
end

function condition2(u, t, integrator)
    t in tstop2
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">condition2 (generic function with 1 method)</code></pre><p>Now we have to apply an effect when these conditions are reached. When <code>condition</code> is hit (at <code>t=5.0</code>), we will increase <code>p</code> to 1.5. When <code>condition2</code> is reached, we will decrease <code>p</code> to <code>-1.5</code>. This is done via the functions:</p><pre><code class="language-julia hljs">function affect!(integrator)
    integrator.p = 1.5
end

function affect2!(integrator)
    integrator.p = -1.5
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">affect2! (generic function with 1 method)</code></pre><p>With these functions we can build our callbacks:</p><pre><code class="language-julia hljs">using DifferentialEquations
save_positions = (true, true)

cb = DiscreteCallback(condition, affect!, save_positions = save_positions)

save_positions = (false, true)

cb2 = DiscreteCallback(condition2, affect2!, save_positions = save_positions)

cbs = CallbackSet(cb, cb2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CallbackSet{Tuple{}, Tuple{DiscreteCallback{typeof(Main.condition), typeof(Main.affect!), typeof(SciMLBase.INITIALIZE_DEFAULT), typeof(SciMLBase.FINALIZE_DEFAULT)}, DiscreteCallback{typeof(Main.condition2), typeof(Main.affect2!), typeof(SciMLBase.INITIALIZE_DEFAULT), typeof(SciMLBase.FINALIZE_DEFAULT)}}}((), (DiscreteCallback{typeof(Main.condition), typeof(Main.affect!), typeof(SciMLBase.INITIALIZE_DEFAULT), typeof(SciMLBase.FINALIZE_DEFAULT)}(Main.condition, Main.affect!, SciMLBase.INITIALIZE_DEFAULT, SciMLBase.FINALIZE_DEFAULT, Bool[1, 1]), DiscreteCallback{typeof(Main.condition2), typeof(Main.affect2!), typeof(SciMLBase.INITIALIZE_DEFAULT), typeof(SciMLBase.FINALIZE_DEFAULT)}(Main.condition2, Main.affect2!, SciMLBase.INITIALIZE_DEFAULT, SciMLBase.FINALIZE_DEFAULT, Bool[0, 1])))</code></pre><p>Now we define our initial condition. We will start at <code>[10.0;10.0]</code> with <code>p=0.0</code>.</p><pre><code class="language-julia hljs">u0 = [10.0; 10.0]
p = 0.0
prob = ODEProblem(f, u0, (0.0, 10.0), p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">ODEProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Float64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
timespan: (0.0, 10.0)
u0: 2-element Vector{Float64}:
 10.0
 10.0</code></pre><p>Lastly we solve the problem. Note that we must pass <code>tstop</code> values of <code>5.0</code> and <code>8.0</code> to ensure the solver hits those timepoints exactly:</p><pre><code class="language-julia hljs">const tstop = [5.0; 8.0]
sol = solve(prob, Tsit5(), callback = cbs, tstops = tstop)
using Plots;
plot(sol);</code></pre><img src="eef162a9.svg" alt="Example block output"/><p>It&#39;s clear from the plot how the controls affected the outcome.</p><h3 id="Example-3:-AutoAbstol"><a class="docs-heading-anchor" href="#Example-3:-AutoAbstol">Example 3: AutoAbstol</a><a id="Example-3:-AutoAbstol-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-AutoAbstol" title="Permalink"></a></h3><p>MATLAB&#39;s Simulink has the option for <a href="https://www.mathworks.com/help/simulink/gui/absolutetolerance.html">an automatic absolute tolerance</a>. In this example we will implement a callback which will add this behavior to any JuliaDiffEq solver which implements the <code>integrator</code> and callback interface.</p><p>The algorithm is as follows. The default value is set to start at <code>1e-6</code>, though we will give the user an option for this choice. Then as the simulation progresses, at each step the absolute tolerance is set to the maximum value that has been reached so far times the relative tolerance. This is the behavior that we will implement in <code>affect!</code>.</p><p>Since the effect is supposed to occur every timestep, we use the trivial condition:</p><pre><code class="language-julia hljs">condition = function (u, t, integrator)
    true
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">#1 (generic function with 1 method)</code></pre><p>which always returns true. For our effect we will overload the call on a type. This type will have a value for the current maximum. By doing it this way, we can store the current state for the running maximum. The code is as follows:</p><pre><code class="language-julia hljs">mutable struct AutoAbstolAffect{T}
    curmax::T
end
# Now make `affect!` for this:
function (p::AutoAbstolAffect)(integrator)
    p.curmax = max(p.curmax, integrator.u)
    integrator.opts.abstol = p.curmax * integrator.opts.reltol
    u_modified!(integrator, false)
end</code></pre><p>This makes <code>affect!(integrator)</code> use an internal mutating value <code>curmax</code> to update the absolute tolerance of the integrator as the algorithm states.</p><p>Lastly, we can wrap it in a nice little constructor:</p><pre><code class="language-julia hljs">function AutoAbstol(save = true; init_curmax = 1e-6)
    affect! = AutoAbstolAffect(init_curmax)
    condition = (u, t, integrator) -&gt; true
    save_positions = (save, false)
    DiscreteCallback(condition, affect!, save_positions = save_positions)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AutoAbstol (generic function with 2 methods)</code></pre><p>This creates the <code>DiscreteCallback</code> from the <code>affect!</code> and <code>condition</code> functions that we implemented. Now</p><pre><code class="language-julia hljs">using DifferentialEquations
cb = AutoAbstol(true; init_curmax = 1e-6)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DiscreteCallback{Main.var&quot;#4#5&quot;, Main.AutoAbstolAffect{Float64}, typeof(SciMLBase.INITIALIZE_DEFAULT), typeof(SciMLBase.FINALIZE_DEFAULT)}(Main.var&quot;#4#5&quot;(), Main.AutoAbstolAffect{Float64}(1.0e-6), SciMLBase.INITIALIZE_DEFAULT, SciMLBase.FINALIZE_DEFAULT, Bool[1, 0])</code></pre><p>returns the callback that we created. We can then solve an equation using this by simply passing it with the <code>callback</code> keyword argument. Using the integrator interface rather than the solve interface, we can step through one by one to watch the absolute tolerance increase:</p><pre><code class="language-julia hljs">function g(u, p, t)
    -u[1]
end
u0 = 10.0
const V = 1
prob = ODEProblem(g, u0, (0.0, 10.0))
integrator = init(prob, BS3(), callback = cb)
at1 = integrator.opts.abstol
step!(integrator)
at2 = integrator.opts.abstol
at1 &lt;= at2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><pre><code class="language-julia hljs">step!(integrator)
at3 = integrator.opts.abstol
at2 &lt;= at3</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Note that this example is contained in the <a href="../callback_library/#callback_library">Callback Library</a>, a library of useful callbacks for JuliaDiffEq solvers.</p><h2 id="ContinuousCallback-Examples"><a class="docs-heading-anchor" href="#ContinuousCallback-Examples">ContinuousCallback Examples</a><a id="ContinuousCallback-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#ContinuousCallback-Examples" title="Permalink"></a></h2><h3 id="Example-1:-Bouncing-Ball"><a class="docs-heading-anchor" href="#Example-1:-Bouncing-Ball">Example 1: Bouncing Ball</a><a id="Example-1:-Bouncing-Ball-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Bouncing-Ball" title="Permalink"></a></h3><p>Let&#39;s look at the bouncing ball. Let the first variable <code>y</code> is the height which changes by <code>v</code> the velocity, where the velocity is always changing at <code>-g</code> which is the gravitational constant. This is the equation:</p><pre><code class="language-julia hljs">function f(du, u, p, t)
    du[1] = u[2]
    du[2] = -p
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">f (generic function with 1 method)</code></pre><p>All we have to do in order to specify the event is to have a function which should always be positive, with an event occurring at 0. We thus want to check if the ball&#39;s height ever hits zero:</p><pre><code class="language-julia hljs">function condition(u, t, integrator) # Event when condition(u,t,integrator) == 0
    u[1]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">condition (generic function with 1 method)</code></pre><p>Notice that here we used the values <code>u</code> instead of the value from the <code>integrator</code>. This is because the values <code>u,t</code> will be appropriately modified at the interpolation points, allowing for the rootfinding behavior to occur.</p><p>Now we have to say what to do when the event occurs. In this case, we just flip the velocity (the second variable)</p><pre><code class="language-julia hljs">function affect!(integrator)
    integrator.u[2] = -integrator.u[2]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">affect! (generic function with 1 method)</code></pre><p>The callback is thus specified by:</p><pre><code class="language-julia hljs">using DifferentialEquations
cb = ContinuousCallback(condition, affect!)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ContinuousCallback{typeof(Main.condition), typeof(Main.affect!), typeof(Main.affect!), typeof(SciMLBase.INITIALIZE_DEFAULT), typeof(SciMLBase.FINALIZE_DEFAULT), Float64, Int64, Rational{Int64}, Nothing, Int64}(Main.condition, Main.affect!, Main.affect!, SciMLBase.INITIALIZE_DEFAULT, SciMLBase.FINALIZE_DEFAULT, nothing, SciMLBase.LeftRootFind, 10, Bool[1, 1], 1, 2.220446049250313e-15, 0, 1//100)</code></pre><p>Then you can solve and plot:</p><pre><code class="language-julia hljs">u0 = [50.0, 0.0]
tspan = (0.0, 15.0)
p = 9.8
prob = ODEProblem(f, u0, tspan, p)
sol = solve(prob, Tsit5(), callback = cb)
using Plots;
plot(sol);</code></pre><img src="52611373.svg" alt="Example block output"/><p>As you can see from the resulting image, DifferentialEquations.jl is smart enough to use the interpolation to hone in on the time of the event and apply the event back at the correct time. Thus, one does not have to worry about the adaptive timestepping “overshooting” the event, as this is handled for you. Notice that the event macro will save the value(s) at the discontinuity.</p><p>The callback is robust to having multiple discontinuities occur. For example, we can integrate for long time periods and get the desired behavior:</p><pre><code class="language-julia hljs">u0 = [50.0, 0.0]
tspan = (0.0, 100.0)
prob = ODEProblem(f, u0, tspan, p)
sol = solve(prob, Tsit5(), callback = cb)
plot(sol)</code></pre><img src="18472d90.svg" alt="Example block output"/><h4 id="Handling-Changing-Dynamics-and-Exactness"><a class="docs-heading-anchor" href="#Handling-Changing-Dynamics-and-Exactness">Handling Changing Dynamics and Exactness</a><a id="Handling-Changing-Dynamics-and-Exactness-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-Changing-Dynamics-and-Exactness" title="Permalink"></a></h4><p>Let&#39;s make a version of the bouncing ball where the ball sticks to the ground. We can do this by introducing a parameter <code>p</code> to send the velocity to zero on the bounce. This looks as follows:</p><pre><code class="language-julia hljs">function dynamics!(du, u, p, t)
    du[1] = u[2]
    du[2] = p[1] * -9.8
end
function floor_aff!(int)
    int.p[1] = 0
    int.u[2] = 0
    @show int.u[1], int.t
end
floor_event = ContinuousCallback(condition, floor_aff!)
u0 = [1.0, 0.0]
p = [1.0]
prob = ODEProblem{true}(dynamics!, u0, (0.0, 1.75), p)
sol = solve(prob, Tsit5(), callback = floor_event)
plot(sol)</code></pre><img src="d4228309.svg" alt="Example block output"/><p>Notice that at the end, the ball is not at <code>0.0</code> like the condition would let you believe, but instead it&#39;s at <code>4.329177480185359e-16</code>. From the printing inside the affect function, we can see that this is the value it had at the event time <code>t=0.4517539514526232</code>. Why did the event handling not make it exactly zero? If you instead had run the simulation to <code>nextfloat(0.4517539514526232) = 0.45175395145262326</code>, we would see that the value of <code>u[1] = -1.2647055847076505e-15</code>. You can see this by changing the <code>rootfind</code> argument of the callback:</p><pre><code class="language-julia hljs">floor_event = ContinuousCallback(condition, floor_aff!, rootfind = SciMLBase.RightRootFind)
u0 = [1.0, 0.0]
p = [1.0]
prob = ODEProblem{true}(dynamics!, u0, (0.0, 1.75), p)
sol = solve(prob, Tsit5(), callback = floor_event)
sol[end] # [-1.2647055847076505e-15, 0.0]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 -1.2647055847076505e-15
  0.0</code></pre><p>What this means is that there is no 64-bit floating-point number <code>t</code> such that the condition is zero! By default, if there is no <code>t</code> such that <code>condition=0</code>, then the rootfinder defaults to choosing the floating-point number exactly before the event (<code>LeftRootFind</code>). This way manifold constraints are preserved by default (i.e. the ball never goes below the floor). However, if you require that the condition is exactly satisfied after the event, you will want to add such a change to the <code>affect!</code> function. For example, the error correction in this case is to add <code>int.u[1] = 0</code> to the <code>affect!</code>, i.e.:</p><pre><code class="language-julia hljs">function floor_aff!(int)
    int.p[1] = 0
    int.u[1] = 0
    int.u[2] = 0
    @show int.u[1], int.t
end
floor_event = ContinuousCallback(condition, floor_aff!)
u0 = [1.0, 0.0]
p = [1.0]
prob = ODEProblem{true}(dynamics!, u0, (0.0, 1.75), p)
sol = solve(prob, Tsit5(), callback = floor_event)
sol[end] # [0.0,0.0]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 0.0
 0.0</code></pre><p>and now the sticky behavior is perfect to the floating-point.</p><h4 id="Handling-Accumulation-Points"><a class="docs-heading-anchor" href="#Handling-Accumulation-Points">Handling Accumulation Points</a><a id="Handling-Accumulation-Points-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-Accumulation-Points" title="Permalink"></a></h4><p>Now let&#39;s take a look at the bouncing ball with friction. After the bounce, we will send the velocity to <code>-v/2</code>. Since the velocity is halving each time, we should have Zeno-like behavior and see an accumulation point of bounces. We will use some extra parameters to count the number of bounces (to infinity) and find the accumulation point. Let&#39;s watch!</p><pre><code class="language-julia hljs">function dynamics!(du, u, p, t)
    du[1] = u[2]
    du[2] = -9.8
end
function floor_aff!(int)
    int.u[2] *= -0.5
    int.p[1] += 1
    int.p[2] = int.t
end
floor_event = ContinuousCallback(condition, floor_aff!)
u0 = [1.0, 0.0]
p = [0.0, 0.0]
prob = ODEProblem{true}(dynamics!, u0, (0.0, 2.0), p)
sol = solve(prob, Tsit5(), callback = floor_event)
plot(sol)</code></pre><img src="4c3fea72.svg" alt="Example block output"/><p>From the readout, we can see the ball only bounced 8 times before it went below the floor, what happened? What happened is floating-point error. Because one cannot guarantee that floating-point numbers exist to make the <code>condition=0</code>, a heuristic is used to ensure that a zero is not accidentally detected at <code>nextfloat(t)</code> after the simulation restarts (otherwise it would repeatedly find the same event!). However, sooner or later, the ability to detect minute floating point differences will crash, and what should be infinitely many bounces finally misses a bounce.</p><p>This leads to two questions:</p><ol><li>How can you improve the accuracy of an accumulation calculation?</li><li>How can you make it gracefully continue?</li></ol><p>For (1), note that floating-point accuracy is dependent on the current <code>dt</code>. If you know that an accumulation point is coming, one can use <code>set_proposed_dt!</code> to shrink the <code>dt</code> value and help find the next bounce point. You can use <code>t - tprev</code> to know the length of the previous interval for this calculation. For this example, we can set the proposed <code>dt</code> to <code>(t - tprev)/10</code> to ensure an ever-increasing accuracy of the check.</p><p>However, at some point we will hit machine epsilon, the value where <code>t + eps(t) == t</code>, so we cannot measure infinitely many bounces and instead will be limited by the floating-point accuracy of our number representation. Using alternative number types like <a href="https://github.com/JuliaArbTypes/ArbFloats.jl">ArbFloats.jl</a> can allow for this to be done at very high accuracy, but still not infinite. Thus, what we need to do is determine a tolerance after which we assume the accumulation has been reached and define the exit behavior. In this case, we will say when the <code>dt&lt;1e-12</code>, we are almost at the edge of Float64 accuracy (<code>eps(1.0) = 2.220446049250313e-16</code>), so we will change the position and velocity to exactly zero.</p><p>With these floating-point corrections in mind, the accumulation calculation looks as follows:</p><pre><code class="language-julia hljs">function dynamics!(du, u, p, t)
    du[1] = u[2]
    du[2] = p[1] * -9.8
end
function floor_aff!(int)
    int.u[2] *= -0.5
    if int.dt &gt; 1e-12
        set_proposed_dt!(int, (int.t - int.tprev) / 100)
    else
        int.u[1] = 0
        int.u[2] = 0
        int.p[1] = 0
    end
    int.p[2] += 1
    int.p[3] = int.t
end
floor_event = ContinuousCallback(condition, floor_aff!)
u0 = [1.0, 0.0]
p = [1.0, 0.0, 0.0]
prob = ODEProblem{true}(dynamics!, u0, (0.0, 2.0), p)
sol = solve(prob, Tsit5(), callback = floor_event)
plot(sol)</code></pre><img src="ededc8dd.svg" alt="Example block output"/><p>With this corrected version, we see that after 41 bounces, the accumulation point is reached at <code>t = 1.355261854357056</code>. To really see the accumulation, let&#39;s zoom in:</p><pre><code class="language-julia hljs">p1 = plot(sol, idxs = 1, tspan = (1.25, 1.40))
p2 = plot(sol, idxs = 1, tspan = (1.35, 1.36))
p3 = plot(sol, idxs = 1, tspan = (1.354, 1.35526))
p4 = plot(sol, idxs = 1, tspan = (1.35526, 1.35526185))
plot(p1, p2, p3, p4)</code></pre><img src="459a9005.svg" alt="Example block output"/><p>I think Zeno would be proud of our solution.</p><h3 id="Example-2:-Terminating-an-Integration"><a class="docs-heading-anchor" href="#Example-2:-Terminating-an-Integration">Example 2: Terminating an Integration</a><a id="Example-2:-Terminating-an-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-Terminating-an-Integration" title="Permalink"></a></h3><p>Often, you might want to terminate an integration when some condition is satisfied. To terminate an integration, use <code>terminate!(integrator)</code> as the <code>affect!</code> in a callback.</p><p>In this example, we will solve the differential equation:</p><pre><code class="language-julia hljs">using DifferentialEquations
u0 = [1.0, 0.0]
function fun2(du, u, p, t)
    du[2] = -u[1]
    du[1] = u[2]
end
tspan = (0.0, 10.0)
prob = ODEProblem(fun2, u0, tspan)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">ODEProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Float64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
timespan: (0.0, 10.0)
u0: 2-element Vector{Float64}:
 1.0
 0.0</code></pre><p>which has cosine and -sine as the solutions respectively. We wish to solve until the sine part, <code>u[2]</code> becomes positive. There are two things we may be looking for.</p><p>A <code>DiscreteCallback</code> will cause this to halt at the first step such that the condition is satisfied. For example, we could use:</p><pre><code class="language-julia hljs">condition(u, t, integrator) = u[2] &gt; 0
affect!(integrator) = terminate!(integrator)
cb = DiscreteCallback(condition, affect!)
sol = solve(prob, Tsit5(), callback = cb)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Terminated
Interpolation: specialized 4th order &quot;free&quot; interpolation
t: 13-element Vector{Float64}:
 0.0
 0.0009990009990009992
 0.010989010989010992
 0.07985922249873038
 0.2403882280626971
 0.48125583199780264
 0.7872724750204353
 1.1770558023021032
 1.630266513673432
 2.1040018658103854
 2.6513321708517577
 3.2715754793582668
 3.2715754793582668
u: 13-element Vector{Vector{Float64}}:
 [1.0, 0.0]
 [0.9999995009985435, -0.000999000832833342]
 [0.9999396214263468, -0.010988789821184267]
 [0.9968129466114029, -0.07977436592568171]
 [0.9712456180254766, -0.23807970964822986]
 [0.8864142948207253, -0.46289273497103683]
 [0.7057801319307302, -0.7084309070362929]
 [0.3836450082688141, -0.9234805642321082]
 [-0.059436395221810434, -0.9982319800633577]
 [-0.5082985573738593, -0.8611807771069901]
 [-0.8822130995277959, -0.4708508238707312]
 [-0.9915642392403545, 0.1296303121647144]
 [-0.9915642392403545, 0.1296303121647144]</code></pre><p>However, we often wish to halt exactly at the point of time that the condition is satisfied. To achieve that, we use a continuous callback. The condition must thus be a function which is zero at the point we want to halt. Thus, we use the following:</p><pre><code class="language-julia hljs">condition(u, t, integrator) = u[2]
affect!(integrator) = terminate!(integrator)
cb = ContinuousCallback(condition, affect!)
sol = solve(prob, Tsit5(), callback = cb)
using Plots;
plot(sol);</code></pre><img src="64ecb9cb.svg" alt="Example block output"/><p>Note that this uses rootfinding to approximate the “exact” moment of the crossing. Analytically we know the value is <code>pi</code>, and here the integration terminates at</p><pre><code class="language-julia hljs">sol.t[end] # 3.1415902502224307</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3.141590249767092</code></pre><p>Using a more accurate integration increases the accuracy of this prediction:</p><pre><code class="language-julia hljs">sol = solve(prob, Vern8(), callback = cb, reltol = 1e-12, abstol = 1e-12)
#π = 3.141592653589703...
sol.t[end] # 3.1415926535896035</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3.1415926535897567</code></pre><p>Now say we wish to find when the first period is over, i.e. we want to ignore the upcrossing and only stop on the downcrossing. We do this by ignoring the <code>affect!</code> and only passing an <code>affect!</code> for the second:</p><pre><code class="language-julia hljs">condition(u, t, integrator) = u[2]
affect!(integrator) = terminate!(integrator)
cb = ContinuousCallback(condition, nothing, affect!)
sol = solve(prob, Tsit5(), callback = cb)
plot(sol)</code></pre><img src="32546de5.svg" alt="Example block output"/><p>Notice that passing only one <code>affect!</code> is the same as <code>ContinuousCallback(condition,affect!,affect!)</code>, i.e. both upcrossings and downcrossings will activate the event. Using <code>ContinuousCallback(condition,affect!,nothing)</code>will thus be the same as above because the first event is an upcrossing.</p><h3 id="Example-3:-Growing-Cell-Population"><a class="docs-heading-anchor" href="#Example-3:-Growing-Cell-Population">Example 3: Growing Cell Population</a><a id="Example-3:-Growing-Cell-Population-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-Growing-Cell-Population" title="Permalink"></a></h3><p>Another interesting issue is with models of changing sizes. The ability to handle such events is a unique feature of DifferentialEquations.jl! The problem we would like to tackle here is a cell population. We start with 1 cell with a protein <code>X</code> which increases linearly with time with rate parameter <code>α</code>. Since we will be changing the size of the population, we write the model in the general form:</p><pre><code class="language-julia hljs">const α = 0.3
function f(du, u, p, t)
    for i in 1:length(u)
        du[i] = α * u[i]
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">f (generic function with 1 method)</code></pre><p>Our model is that, whenever the protein <code>X</code> gets to a concentration of 1, it triggers a cell division. So we check to see if any concentrations hit 1:</p><pre><code class="language-julia hljs">function condition(u, t, integrator) # Event when condition(u,t,integrator) == 0
    1 - maximum(u)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">condition (generic function with 1 method)</code></pre><p>Again, recall that this function finds events as when <code>condition==0</code>, so <code>1-maximum(u)</code> is positive until a cell has a concentration of <code>X</code> which is 1, which then triggers the event. At the event, we have that the cell splits into two cells, giving a random amount of protein to each one. We can do this by resizing the cache (adding 1 to the length of all of the caches) and setting the values of these two cells at the time of the event:</p><pre><code class="language-julia hljs">function affect!(integrator)
    u = integrator.u
    maxidx = findmax(u)[2]
    resize!(integrator, length(u) + 1)
    Θ = rand()
    u[maxidx] = Θ
    u[end] = 1 - Θ
    nothing
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">affect! (generic function with 1 method)</code></pre><p>As noted in the <a href="../../basics/integrator/#integrator">Integrator Interface</a>, <code>resize!(integrator,length(integrator.u)+1)</code> is used to change the length of all of the internal caches (which includes <code>u</code>) to be their current length + 1, growing the ODE system. Then the following code sets the new protein concentrations. Now we can solve:</p><pre><code class="language-julia hljs">using DifferentialEquations
callback = ContinuousCallback(condition, affect!)
u0 = [0.2]
tspan = (0.0, 10.0)
prob = ODEProblem(f, u0, tspan)
sol = solve(prob, callback = callback)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: 3rd order Hermite
t: 23-element Vector{Float64}:
  0.0
  0.12735293592636002
  0.7397598129840375
  1.7483495595956313
  2.9466710993053042
  4.439321082686529
  5.3648066324638375
  5.3648066324638375
  6.5798997533405155
  6.5798997533405155
  ⋮
  9.267737730757446
  9.267737730757446
  9.317827955516002
  9.317827955516002
  9.642459784365471
  9.642459784365471
  9.752988501274109
  9.752988501274109
 10.0
u: 23-element Vector{Vector{Float64}}:
 [0.2]
 [0.20778902193773555]
 [0.2496962828311938]
 [0.337924407428979]
 [0.48411313940258804]
 [0.7575680527709512]
 [0.9999999999999999]
 [0.30547220511568607, 0.6945277948843139]
 [0.4398271852699113, 0.9999999999999999]
 [0.4398271852699113, 0.38599859059359154, 0.6140014094064085]
 ⋮
 [0.9850852676045324, 0.8645248353089292, 0.3388364747776236, 0.9999999999999994, 0.03634851367072756]
 [0.9850852676045324, 0.8645248353089292, 0.3388364747776236, 0.6026700210286711, 0.03634851367072756, 0.39732997897132893]
 [0.9999999999999998, 0.877614216494401, 0.3439666452444106, 0.6117947763996161, 0.03689885014636099, 0.4033457732420774]
 [0.9072025325991653, 0.877614216494401, 0.3439666452444106, 0.6117947763996161, 0.03689885014636099, 0.4033457732420774, 0.09279746740083472]
 [0.9999999999999998, 0.9673851041619196, 0.3791508873536042, 0.6743750754826529, 0.04067322215321044, 0.4446038880496489, 0.1022896917350604]
 [0.2715532098611211, 0.9673851041619196, 0.3791508873536042, 0.6743750754826529, 0.04067322215321044, 0.4446038880496489, 0.1022896917350604, 0.7284467901388789]
 [0.2807084879566936, 0.9999999999999997, 0.39193376631747506, 0.6971112875124204, 0.04204449911232311, 0.4595934815792156, 0.10573833656832828, 0.7530060024750518]
 [0.2807084879566936, 0.22850557533290905, 0.39193376631747506, 0.6971112875124204, 0.04204449911232311, 0.4595934815792156, 0.10573833656832828, 0.7530060024750518, 0.771494424667091]
 [0.30230008140399217, 0.24608181436630225, 0.42208060869546893, 0.7507318374895665, 0.04527848657788431, 0.49494458790848994, 0.11387153977709333, 0.810925873680817, 0.8308363921491686]</code></pre><p>The plot recipes do not have a way of handling the changing size, but we can plot from the solution object directly. For example, let&#39;s make a plot of how many cells there are at each time. Since these are discrete values, we calculate and plot them directly:</p><pre><code class="language-julia hljs">using Plots
plot(sol.t, map((x) -&gt; length(x), sol[:]), lw = 3,
    ylabel = &quot;Number of Cells&quot;, xlabel = &quot;Time&quot;)</code></pre><img src="d9929c1e.svg" alt="Example block output"/><p>Now let&#39;s check in on a cell. We can still use the interpolation to get a nice plot of the concentration of cell 1 over time. This is done with the command:</p><pre><code class="language-julia hljs">ts = range(0, stop = 10, length = 100)
plot(ts, map((x) -&gt; x[1], sol.(ts)), lw = 3,
    ylabel = &quot;Amount of X in Cell 1&quot;, xlabel = &quot;Time&quot;)</code></pre><img src="e5456c58.svg" alt="Example block output"/><p>Notice that every time it hits 1 the cell divides, giving cell 1 a random amount of <code>X</code> which then grows until the next division.</p><p>Note that one macro which was not shown in this example is <code>deleteat!</code> on the caches. For example, to delete the second cell, we could use:</p><pre><code class="language-julia hljs">deleteat!(integrator, 2)</code></pre><p>This allows you to build sophisticated models of populations with births and deaths.</p><h2 id="VectorContinuousCallback-Example"><a class="docs-heading-anchor" href="#VectorContinuousCallback-Example">VectorContinuousCallback Example</a><a id="VectorContinuousCallback-Example-1"></a><a class="docs-heading-anchor-permalink" href="#VectorContinuousCallback-Example" title="Permalink"></a></h2><h3 id="Example-1:-Bouncing-Ball-with-multiple-walls"><a class="docs-heading-anchor" href="#Example-1:-Bouncing-Ball-with-multiple-walls">Example 1: Bouncing Ball with multiple walls</a><a id="Example-1:-Bouncing-Ball-with-multiple-walls-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Bouncing-Ball-with-multiple-walls" title="Permalink"></a></h3><p>This is similar to the above Bouncing Ball example, but now we have two more vertical walls, at <code>x = 0</code> and <code>x = 10.0</code>. We have our ODEFunction as -</p><pre><code class="language-julia hljs">function f(du, u, p, t)
    du[1] = u[2]
    du[2] = -p
    du[3] = u[4]
    du[4] = 0.0
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">f (generic function with 1 method)</code></pre><p>where <code>u[1]</code> denotes <code>y</code>-coordinate, <code>u[2]</code> denotes velocity in <code>y</code>-direction, <code>u[3]</code> denotes <code>x</code>-coordinate and <code>u[4]</code> denotes velocity in <code>x</code>-direction. We will make a <code>VectorContinuousCallback</code> of length 2 - one for <code>x</code> axis collision, one for walls parallel to <code>y</code> axis.</p><pre><code class="language-julia hljs">function condition(out, u, t, integrator) # Event when condition(out,u,t,integrator) == 0
    out[1] = u[1]
    out[2] = (u[3] - 10.0)u[3]
end

function affect!(integrator, idx)
    if idx == 1
        integrator.u[2] = -0.9integrator.u[2]
    elseif idx == 2
        integrator.u[4] = -0.9integrator.u[4]
    end
end
using DifferentialEquations
cb = VectorContinuousCallback(condition, affect!, 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VectorContinuousCallback{typeof(Main.condition), typeof(Main.affect!), typeof(Main.affect!), typeof(SciMLBase.INITIALIZE_DEFAULT), typeof(SciMLBase.FINALIZE_DEFAULT), Float64, Int64, Rational{Int64}, Nothing, Int64}(Main.condition, Main.affect!, Main.affect!, 2, SciMLBase.INITIALIZE_DEFAULT, SciMLBase.FINALIZE_DEFAULT, nothing, SciMLBase.LeftRootFind, 10, Bool[1, 1], 1, 2.220446049250313e-15, 0, 1//100)</code></pre><p>It is evident that <code>out[2]</code> will be zero when <code>u[3]</code> (x-coordinate) is either <code>0.0</code> or <code>10.0</code>. And when that happens, we flip the velocity with some coefficient of restitution (<code>0.9</code>).</p><p>Completing the rest of the code</p><pre><code class="language-julia hljs">u0 = [50.0, 0.0, 0.0, 2.0]
tspan = (0.0, 15.0)
p = 9.8
prob = ODEProblem(f, u0, tspan, p)
sol = solve(prob, Tsit5(), callback = cb, dt = 1e-3, adaptive = false)
using Plots;
plot(sol, idxs = (1, 3));</code></pre><img src="5c4b689c.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../linear_nonlinear/">« Specifying (Non)Linear Solvers and Preconditioners</a><a class="docs-footer-nextpage" href="../callback_library/">Callback Library »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 4 September 2024 15:19">Wednesday 4 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
