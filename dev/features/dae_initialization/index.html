<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DAE Initialization · DifferentialEquations.jl</title><meta name="title" content="DAE Initialization · DifferentialEquations.jl"/><meta property="og:title" content="DAE Initialization · DifferentialEquations.jl"/><meta property="twitter:title" content="DAE Initialization · DifferentialEquations.jl"/><meta name="description" content="Documentation for DifferentialEquations.jl."/><meta property="og:description" content="Documentation for DifferentialEquations.jl."/><meta property="twitter:description" content="Documentation for DifferentialEquations.jl."/><meta property="og:url" content="https://docs.sciml.ai/DiffEqDocs/stable/features/dae_initialization/"/><meta property="twitter:url" content="https://docs.sciml.ai/DiffEqDocs/stable/features/dae_initialization/"/><link rel="canonical" href="https://docs.sciml.ai/DiffEqDocs/stable/features/dae_initialization/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DifferentialEquations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">DifferentialEquations.jl: Efficient Differential Equation Solving in Julia</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started with Differential Equations in Julia</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/faster_ode_example/">Code Optimization for Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/advanced_ode_example/">Solving Large Stiff Equations</a></li><li><a class="tocitem" href="../../tutorials/sde_example/">Stochastic Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/rode_example/">Random Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dde_example/">Delay Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dae_example/">Differential Algebraic Equations</a></li><li><a class="tocitem" href="../../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="tocitem" href="../../tutorials/bvp_example/">Boundary Value Problems</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Beginner</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/classical_physics/">Classical Physics Models</a></li><li><a class="tocitem" href="../../examples/conditional_dosing/">Conditional Dosing in Pharmacometrics</a></li><li><a class="tocitem" href="../../examples/kepler_problem/">The Kepler Problem</a></li><li><a class="tocitem" href="../../examples/outer_solar_system/">Simulating the Outer Solar System</a></li><li><a class="tocitem" href="../../examples/min_and_max/">Finding Maxima and Minima of ODEs Solutions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Advanced</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/spiking_neural_systems/">Spiking Neural Systems</a></li><li><a class="tocitem" href="../../examples/beeler_reuter/">An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model</a></li><li><a class="tocitem" href="../../examples/diffusion_implicit_heat_equation/">Solving the heat equation with diffusion-implicit time-stepping</a></li></ul></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../basics/common_solver_opts/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../basics/solution/">Solution Handling</a></li><li><a class="tocitem" href="../../basics/plot/">Plot Functions</a></li><li><a class="tocitem" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="tocitem" href="../../basics/problem/">Problem Interface</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="tocitem">Problem Types</span><ul><li><a class="tocitem" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="tocitem" href="../../types/ode_types/">ODE Problems</a></li><li><a class="tocitem" href="../../types/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group Problems</a></li><li><a class="tocitem" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="tocitem" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="tocitem" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="tocitem" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="tocitem" href="../../types/sde_types/">SDE Problems</a></li><li><a class="tocitem" href="../../types/sdae_types/">SDAE Problems</a></li><li><a class="tocitem" href="../../types/rode_types/">RODE Problems</a></li><li><a class="tocitem" href="../../types/dde_types/">DDE Problems</a></li><li><a class="tocitem" href="../../types/sdde_types/">SDDE Problems</a></li><li><a class="tocitem" href="../../types/dae_types/">DAE Problems</a></li></ul></li><li><span class="tocitem">Solver Algorithms</span><ul><li><a class="tocitem" href="../../solvers/discrete_solve/">Discrete Solvers</a></li><li><a class="tocitem" href="../../solvers/ode_solve/">ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/split_ode_solve/">Split ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/steady_state_solve/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/bvp_solve/">BVP Solvers</a></li><li><a class="tocitem" href="../../solvers/sde_solve/">SDE Solvers</a></li><li><a class="tocitem" href="../../solvers/sdae_solve/">SDAE Solvers</a></li><li><a class="tocitem" href="../../solvers/rode_solve/">RODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dde_solve/">DDE Solvers</a></li><li><a class="tocitem" href="../../solvers/sdde_solve/">SDDE Solvers</a></li><li><a class="tocitem" href="../../solvers/dae_solve/">Mass Matrix and Fully Implicit DAE Solvers</a></li><li><a class="tocitem" href="../../solvers/benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="tocitem">Additional Features</span><ul><li><a class="tocitem" href="../performance_overloads/">Jacobians, Gradients, etc.</a></li><li><a class="tocitem" href="../diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="tocitem" href="../diffeq_operator/">Matrix-Free Linear Operators with SciMLOperators.jl</a></li><li><a class="tocitem" href="../noise_process/">Noise Processes</a></li><li><a class="tocitem" href="../linear_nonlinear/">Specifying (Non)Linear Solvers and Preconditioners</a></li><li class="is-active"><a class="tocitem" href>DAE Initialization</a><ul class="internal"><li><a class="tocitem" href="#The-Initialization-Problem"><span>The Initialization Problem</span></a></li><li><a class="tocitem" href="#Available-Initialization-Algorithms"><span>Available Initialization Algorithms</span></a></li><li><a class="tocitem" href="#WARNING:-NoInit-Usage"><span>⚠️ WARNING: NoInit Usage</span></a></li><li><a class="tocitem" href="#Algorithm-Selection-Guide"><span>Algorithm Selection Guide</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#Algorithm-Specific-Options"><span>Algorithm-Specific Options</span></a></li><li><a class="tocitem" href="#Troubleshooting"><span>Troubleshooting</span></a></li><li><a class="tocitem" href="#Performance-Tips"><span>Performance Tips</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../callback_functions/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../callback_library/">Callback Library</a></li><li><a class="tocitem" href="../ensemble/">Parallel Ensemble Simulations</a></li><li><a class="tocitem" href="../io/">I/O: Saving and Loading Solution Data</a></li><li><a class="tocitem" href="../low_dep/">Reduced Compile Time, Optimizing Runtime, and Low Dependency Usage</a></li><li><a class="tocitem" href="../progress_bar/">Progress Bar Integration</a></li></ul></li><li><span class="tocitem">External Solver APIs</span><ul><li><a class="tocitem" href="../../api/sundials/">Sundials.jl</a></li><li><a class="tocitem" href="../../api/daskr/">DASKR.jl</a></li></ul></li><li><span class="tocitem">OrdinaryDiffEq.jl API</span><ul><li><a class="tocitem" href="../../api/ordinarydiffeq/">OrdinaryDiffEq.jl: ODE solvers and utilities</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/usage/">Usage</a></li><li><input class="collapse-toggle" id="menuitem-10-3" type="checkbox"/><label class="tocitem" for="menuitem-10-3"><span class="docs-label">Explicit Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/ordinarydiffeq/explicit/Tsit5/">OrdinaryDiffEqTsit5</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/explicit/Verner/">OrdinaryDiffEqVerner</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/explicit/AdamsBashforthMoulton/">OrdinaryDiffEqAdamsBashforthMoulton</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/explicit/LowStorageRK/">OrdinaryDiffEqLowStorageRK</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/explicit/SSPRK/">OrdinaryDiffEqSSPRK</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/explicit/LowOrderRK/">OrdinaryDiffEqLowOrderRK</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/explicit/HighOrderRK/">OrdinaryDiffEqHighOrderRK</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/explicit/Feagin/">OrdinaryDiffEqFeagin</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/explicit/PRK/">OrdinaryDiffEqPRK</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/explicit/QPRK/">OrdinaryDiffEqQPRK</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/explicit/TaylorSeries/">OrdinaryDiffEqTaylorSeries</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/explicit/Extrapolation/">OrdinaryDiffEqExtrapolation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-4" type="checkbox"/><label class="tocitem" for="menuitem-10-4"><span class="docs-label">Semi-Implicit Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/ordinarydiffeq/semiimplicit/Rosenbrock/">OrdinaryDiffEqRosenbrock</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/semiimplicit/StabilizedRK/">OrdinaryDiffEqStabilizedRK</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/semiimplicit/ExponentialRK/">OrdinaryDiffEqExponentialRK</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-5" type="checkbox"/><label class="tocitem" for="menuitem-10-5"><span class="docs-label">Implicit Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/ordinarydiffeq/implicit/SDIRK/">OrdinaryDiffEqSDIRK</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/implicit/FIRK/">OrdinaryDiffEqFIRK</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/implicit/BDF/">OrdinaryDiffEqBDF</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/implicit/Extrapolation/">OrdinaryDiffEqExtrapolation</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/implicit/PDIRK/">OrdinaryDiffEqPDIRK</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/implicit/Nordsieck/">OrdinaryDiffEqNordsieck</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-6" type="checkbox"/><label class="tocitem" for="menuitem-10-6"><span class="docs-label">IMEX Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/ordinarydiffeq/imex/IMEXMultistep/">OrdinaryDiffEqIMEXMultistep</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/imex/StabilizedIRK/">OrdinaryDiffEqStabilizedIRK</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/imex/IMEXBDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-7" type="checkbox"/><label class="tocitem" for="menuitem-10-7"><span class="docs-label">Dynamical ODE Explicit Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/ordinarydiffeq/dynamicalodeexplicit/RKN/">OrdinaryDiffEqRKN</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/dynamicalodeexplicit/SymplecticRK/">OrdinaryDiffEqSymplecticRK</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-8" type="checkbox"/><label class="tocitem" for="menuitem-10-8"><span class="docs-label">Semilinear ODE Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/ordinarydiffeq/semilinear/ExponentialRK/">OrdinaryDiffEqExponentialRK</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/semilinear/Linear/">OrdinaryDiffEqLinear</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-9" type="checkbox"/><label class="tocitem" for="menuitem-10-9"><span class="docs-label">Mass Matrix DAE Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/ordinarydiffeq/massmatrixdae/Rosenbrock/">OrdinaryDiffEqRosenbrock</a></li><li><a class="tocitem" href="../../api/ordinarydiffeq/massmatrixdae/BDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-10" type="checkbox"/><label class="tocitem" for="menuitem-10-10"><span class="docs-label">Fully Implicit DAE Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/ordinarydiffeq/fullyimplicitdae/BDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10-11" type="checkbox"/><label class="tocitem" for="menuitem-10-11"><span class="docs-label">Misc Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/ordinarydiffeq/misc/">Miscellaneous Solvers</a></li></ul></li></ul></li><li><span class="tocitem">StochasticDiffEq.jl API</span><ul><li><a class="tocitem" href="../../api/stochasticdiffeq/">StochasticDiffEq.jl: SDE solvers and utilities</a></li><li><a class="tocitem" href="../../api/stochasticdiffeq/usage/">Usage</a></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Nonstiff Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/stochasticdiffeq/nonstiff/basic_methods/">Basic Nonstiff Methods</a></li><li><a class="tocitem" href="../../api/stochasticdiffeq/nonstiff/sra_sri_methods/">SRA/SRI Methods - Stochastic Runge-Kutta</a></li><li><a class="tocitem" href="../../api/stochasticdiffeq/nonstiff/high_weak_order/">High Weak Order Methods</a></li><li><a class="tocitem" href="../../api/stochasticdiffeq/nonstiff/commutative_noise/">Commutative Noise Methods</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Stiff Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/stochasticdiffeq/stiff/implicit_methods/">Implicit Methods for Stiff SDEs</a></li><li><a class="tocitem" href="../../api/stochasticdiffeq/stiff/split_step_methods/">Split-Step Methods for Fully Stiff Problems</a></li><li><a class="tocitem" href="../../api/stochasticdiffeq/stiff/stabilized_methods/">Stabilized Methods (SROCK Family)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Jump Diffusion</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/stochasticdiffeq/jumpdiffusion/tau_leaping/">Tau-Leaping Methods for Jump-Diffusion</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Misc Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/stochasticdiffeq/misc/">Miscellaneous Methods</a></li></ul></li></ul></li><li><span class="tocitem">Extra Details</span><ul><li><a class="tocitem" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Additional Features</a></li><li class="is-active"><a href>DAE Initialization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DAE Initialization</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="dae_initialization"><a class="docs-heading-anchor" href="#dae_initialization">DAE Initialization</a><a id="dae_initialization-1"></a><a class="docs-heading-anchor-permalink" href="#dae_initialization" title="Permalink"></a></h1><p>DAE (Differential-Algebraic Equation) problems often require special initialization procedures to ensure that the initial conditions are consistent with the algebraic constraints. The DifferentialEquations.jl ecosystem provides several initialization algorithms to handle this automatically or to verify that your provided initial conditions are already consistent.</p><h2 id="The-Initialization-Problem"><a class="docs-heading-anchor" href="#The-Initialization-Problem">The Initialization Problem</a><a id="The-Initialization-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-Initialization-Problem" title="Permalink"></a></h2><p>DAEs have the general form:</p><p class="math-container">\[M \frac{du}{dt} = f(u, p, t)\]</p><p>where <code>M</code> is a (possibly singular) mass matrix. For the initial conditions <code>u₀</code> and <code>du₀</code> to be consistent, they must satisfy:</p><p class="math-container">\[f(du₀, u₀, p, t₀) = 0\]</p><p>for fully implicit DAEs, or the equivalent constraint for semi-explicit DAEs. Finding consistent initial conditions is a nonlinear problem that must be solved before time integration can begin.</p><h2 id="Available-Initialization-Algorithms"><a class="docs-heading-anchor" href="#Available-Initialization-Algorithms">Available Initialization Algorithms</a><a id="Available-Initialization-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Available-Initialization-Algorithms" title="Permalink"></a></h2><p>The <code>initializealg</code> keyword argument to <code>solve</code> controls how initialization is performed. All algorithms are documented with their docstrings:</p><article><details class="docstring" open="true"><summary id="DiffEqBase.DefaultInit"><a class="docstring-binding" href="#DiffEqBase.DefaultInit"><code>DiffEqBase.DefaultInit</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct DefaultInit &lt;: DAEInitializationAlgorithm</code></pre><p>The default initialization algorithm for DAEs. This will use heuristics to determine the most appropriate initialization based on the problem type.</p><p>For Sundials, this will use:</p><ul><li><code>OverrideInit</code> if the problem has <code>initialization_data</code> (typically from ModelingToolkit)</li><li><code>CheckInit</code> otherwise</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.CheckInit"><a class="docstring-binding" href="#SciMLBase.CheckInit"><code>SciMLBase.CheckInit</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct CheckInit &lt;: DAEInitializationAlgorithm</code></pre><p>An initialization algorithm that only checks if the initial conditions are consistent with the DAE constraints, without attempting to modify them. If the conditions are not consistent within the solver&#39;s tolerance, an error will be thrown.</p><p>This is useful when:</p><ul><li>You have already computed consistent initial conditions</li><li>You want to verify the consistency of your initial guess</li><li>You want to ensure no automatic modifications are made to your initial conditions</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">prob = DAEProblem(f, du0, u0, tspan)
sol = solve(prob, IDA(), initializealg = CheckInit())</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.NoInit"><a class="docstring-binding" href="#SciMLBase.NoInit"><code>SciMLBase.NoInit</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct NoInit &lt;: DAEInitializationAlgorithm</code></pre><p>An initialization algorithm that completely skips the initialization phase. The solver will use the provided initial conditions directly without any consistency checks or modifications.</p><div class="admonition is-warning" id="Warning-618d34bd439125a8"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-618d34bd439125a8" title="Permalink"></a></header><div class="admonition-body"><p>Using <code>NoInit()</code> with inconsistent initial conditions will likely cause solver failures or incorrect results. Only use this when you are absolutely certain your initial conditions satisfy all DAE constraints.</p></div></div><p>This is useful when:</p><ul><li>You know your initial conditions are already perfectly consistent</li><li>You want to avoid the computational cost of initialization</li><li>You are debugging solver issues and want to isolate initialization from integration</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">prob = DAEProblem(f, du0_consistent, u0_consistent, tspan)
sol = solve(prob, IDA(), initializealg = NoInit())</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.OverrideInit"><a class="docstring-binding" href="#SciMLBase.OverrideInit"><code>SciMLBase.OverrideInit</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct OverrideInit &lt;: DAEInitializationAlgorithm</code></pre><p>An initialization algorithm that uses a separate initialization problem to find consistent initial conditions. This is typically used with ModelingToolkit.jl which can generate specialized initialization problems based on the model structure.</p><p>When using <code>OverrideInit</code>, the problem must have <code>initialization_data</code> that contains an <code>initializeprob</code> field with the initialization problem to solve.</p><p>This algorithm is particularly useful for:</p><ul><li>High-index DAEs that have been index-reduced</li><li>Systems with complex initialization requirements</li><li>ModelingToolkit models with custom initialization equations</li></ul><p><strong>Fields</strong></p><ul><li><code>abstol</code>: Absolute tolerance for the initialization solver</li><li><code>reltol</code>: Relative tolerance for the initialization solver</li><li><code>nlsolve</code>: Nonlinear solver to use for initialization</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Typically used automatically with ModelingToolkit
@named sys = ODESystem(eqs, t, vars, params)
sys = structural_simplify(sys)
prob = DAEProblem(sys, [], (0.0, 1.0), [])
# Will automatically use OverrideInit if initialization_data exists
sol = solve(prob, IDA())</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqBase.BrownFullBasicInit"><a class="docstring-binding" href="#DiffEqBase.BrownFullBasicInit"><code>DiffEqBase.BrownFullBasicInit</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct BrownFullBasicInit{T, F} &lt;: DAEInitializationAlgorithm</code></pre><p>The Brown full basic initialization algorithm for DAEs. This implementation is based on the algorithm described in:</p><p>Peter N. Brown, Alan C. Hindmarsh, and Linda R. Petzold, &quot;Consistent Initial Condition Calculation for Differential-Algebraic Systems&quot;, SIAM Journal on Scientific Computing, Vol. 19, No. 5, pp. 1495-1512, 1998. DOI: https://doi.org/10.1137/S1064827595289996</p><p>This method modifies the algebraic variables and their derivatives to be consistent with the DAE constraints, while keeping the differential variables fixed. It uses Newton&#39;s method to solve for consistent initial values.</p><p>This is the default initialization for many DAE solvers when <code>differential_vars</code> is provided, allowing the solver to distinguish between differential and algebraic variables.</p><p><strong>Parameters</strong></p><ul><li><code>abstol</code>: Absolute tolerance for the nonlinear solver (default: 1e-10)</li><li><code>nlsolve</code>: Custom nonlinear solver to use (optional)</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqBase.ShampineCollocationInit"><a class="docstring-binding" href="#DiffEqBase.ShampineCollocationInit"><code>DiffEqBase.ShampineCollocationInit</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ShampineCollocationInit{T, F} &lt;: DAEInitializationAlgorithm</code></pre><p>The Shampine collocation initialization algorithm for DAEs. This implementation is based on the algorithm described in:</p><p>Lawrence F. Shampine, &quot;Consistent Initial Condition for Differential-Algebraic Systems&quot;, SIAM Journal on Scientific Computing, Vol. 22, No. 6, pp. 2007-2026, 2001. DOI: https://doi.org/10.1137/S1064827599355049</p><p>This method uses collocation on the first two steps to find consistent initial conditions. It modifies both the differential and algebraic variables to satisfy the DAE constraints. This is more general than BrownBasicInit but may be more expensive computationally.</p><p>This method is useful when you need to modify all variables (both differential and algebraic) to achieve consistency, rather than just the algebraic ones.</p><p><strong>Parameters</strong></p><ul><li><code>initdt</code>: Initial time step to use in the collocation method (optional)</li><li><code>nlsolve</code>: Custom nonlinear solver to use (optional)</li></ul></div></section></details></article><h2 id="WARNING:-NoInit-Usage"><a class="docs-heading-anchor" href="#WARNING:-NoInit-Usage">⚠️ WARNING: NoInit Usage</a><a id="WARNING:-NoInit-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#WARNING:-NoInit-Usage" title="Permalink"></a></h2><div class="admonition is-warning" id="Use-NoInit-at-your-own-risk-ab069e8340e5d8f3"><header class="admonition-header">Use NoInit at your own risk<a class="admonition-anchor" href="#Use-NoInit-at-your-own-risk-ab069e8340e5d8f3" title="Permalink"></a></header><div class="admonition-body"><p><strong><code>NoInit()</code> should almost never be used.</strong> No algorithm has any guarantee of correctness if <code>NoInit()</code> is used with inconsistent initial conditions. Users should almost always use <code>CheckInit()</code> instead for safety.</p><p><strong>Important:</strong></p><ul><li>Any issues opened that are using <code>NoInit()</code> will be immediately closed</li><li>Allowing incorrect initializations is not a supported part of the system</li><li>Using <code>NoInit()</code> with inconsistent conditions can lead to:<ul><li>Solver instability and crashes</li><li>Incorrect results that may appear plausible</li><li>Undefined behavior in the numerical algorithms</li><li>Silent corruption of the solution</li></ul></li></ul><p><strong>When to use <code>CheckInit()</code> instead:</strong></p><ul><li>When you believe your initial conditions are consistent</li><li>When you want to skip automatic modification of initial conditions</li><li>When you need to verify your manual initialization</li></ul><p>The only valid use case for <code>NoInit()</code> is when you are 100% certain your conditions are consistent AND you need to skip the computational cost of verification for performance reasons in production code that has been thoroughly tested.</p></div></div><h2 id="Algorithm-Selection-Guide"><a class="docs-heading-anchor" href="#Algorithm-Selection-Guide">Algorithm Selection Guide</a><a id="Algorithm-Selection-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-Selection-Guide" title="Permalink"></a></h2><table><tr><th style="text-align: right">Algorithm</th><th style="text-align: right">When to Use</th><th style="text-align: right">Modifies Variables</th></tr><tr><td style="text-align: right"><code>DefaultInit()</code></td><td style="text-align: right">Default choice - automatically selects appropriate method</td><td style="text-align: right">Depends on selection</td></tr><tr><td style="text-align: right"><code>CheckInit()</code></td><td style="text-align: right">When you&#39;ve computed consistent conditions yourself</td><td style="text-align: right">No (verification only)</td></tr><tr><td style="text-align: right"><code>NoInit()</code></td><td style="text-align: right">⚠️ <strong>AVOID</strong> - Only for verified consistent conditions</td><td style="text-align: right">No</td></tr><tr><td style="text-align: right"><code>OverrideInit()</code></td><td style="text-align: right">With ModelingToolkit problems</td><td style="text-align: right">Yes (uses custom problem)</td></tr><tr><td style="text-align: right"><code>BrownFullBasicInit()</code></td><td style="text-align: right">For index-1 DAEs with <code>differential_vars</code></td><td style="text-align: right">Algebraic variables only</td></tr><tr><td style="text-align: right"><code>ShampineCollocationInit()</code></td><td style="text-align: right">For general DAEs without structure information</td><td style="text-align: right">All variables</td></tr></table><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><h3 id="Example-1:-Simple-Pendulum-DAE"><a class="docs-heading-anchor" href="#Example-1:-Simple-Pendulum-DAE">Example 1: Simple Pendulum DAE</a><a id="Example-1:-Simple-Pendulum-DAE-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Simple-Pendulum-DAE" title="Permalink"></a></h3><pre><code class="language-julia hljs">using DifferentialEquations

function pendulum!(res, du, u, p, t)
    x, y, T = u
    dx, dy, dT = du
    g, L = p

    res[1] = dx - du[1]
    res[2] = dy - du[2]
    res[3] = x^2 + y^2 - L^2  # Algebraic constraint
end

u0 = [1.0, 0.0, 0.0]  # Initial position
du0 = [0.0, 0.0, 0.0]  # Initial velocity (inconsistent!)
p = [9.81, 1.0]  # g, L
tspan = (0.0, 10.0)

prob = DAEProblem(pendulum!, du0, u0, tspan, p,
                  differential_vars = [true, true, false])

# BrownFullBasicInit will fix the inconsistent du0
sol = solve(prob, DFBDF(), initializealg = BrownFullBasicInit())</code></pre><h3 id="Example-2:-Checking-Consistency-(Recommended-over-NoInit)"><a class="docs-heading-anchor" href="#Example-2:-Checking-Consistency-(Recommended-over-NoInit)">Example 2: Checking Consistency (Recommended over NoInit)</a><a id="Example-2:-Checking-Consistency-(Recommended-over-NoInit)-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-Checking-Consistency-(Recommended-over-NoInit)" title="Permalink"></a></h3><pre><code class="language-julia hljs"># If you&#39;ve computed consistent conditions yourself
u0_consistent = [1.0, 0.0, 0.0]
du0_consistent = [0.0, -1.0, compute_tension(u0_consistent, p)]

prob2 = DAEProblem(pendulum!, du0_consistent, u0_consistent, tspan, p,
                   differential_vars = [true, true, false])

# RECOMMENDED: Verify they&#39;re consistent with CheckInit
sol = solve(prob2, DFBDF(), initializealg = CheckInit())

# NOT RECOMMENDED: NoInit skips all checks - use at your own risk!
# sol = solve(prob2, DFBDF(), initializealg = NoInit())  # ⚠️ DANGEROUS</code></pre><h3 id="Example-3:-ModelingToolkit-Integration"><a class="docs-heading-anchor" href="#Example-3:-ModelingToolkit-Integration">Example 3: ModelingToolkit Integration</a><a id="Example-3:-ModelingToolkit-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-ModelingToolkit-Integration" title="Permalink"></a></h3><p>When using ModelingToolkit, initialization information is often included automatically:</p><pre><code class="language-julia hljs">using ModelingToolkit, DifferentialEquations

@variables t x(t) y(t) T(t)
@parameters g L
D = Differential(t)

eqs = [
    D(x) ~ -T * x/L,
    D(y) ~ -T * y/L - g,
    x^2 + y^2 ~ L^2
]

@named pendulum = ODESystem(eqs, t, [x, y, T], [g, L])
sys = structural_simplify(pendulum)

# ModelingToolkit provides initialization_data
prob = DAEProblem(sys, [x =&gt; 1.0, y =&gt; 0.0], (0.0, 10.0), [g =&gt; 9.81, L =&gt; 1.0])

# DefaultInit will use OverrideInit with ModelingToolkit&#39;s initialization_data
sol = solve(prob, DFBDF())  # Automatic initialization!</code></pre><h2 id="Algorithm-Specific-Options"><a class="docs-heading-anchor" href="#Algorithm-Specific-Options">Algorithm-Specific Options</a><a id="Algorithm-Specific-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-Specific-Options" title="Permalink"></a></h2><p>Both OrdinaryDiffEq and Sundials support the same initialization algorithms through the <code>initializealg</code> parameter:</p><h3 id="OrdinaryDiffEq-and-Sundials"><a class="docs-heading-anchor" href="#OrdinaryDiffEq-and-Sundials">OrdinaryDiffEq and Sundials</a><a id="OrdinaryDiffEq-and-Sundials-1"></a><a class="docs-heading-anchor-permalink" href="#OrdinaryDiffEq-and-Sundials" title="Permalink"></a></h3><pre><code class="language-julia hljs">using OrdinaryDiffEq
# or
using Sundials

# Use Brown&#39;s algorithm to fix inconsistent conditions
sol = solve(prob, DFBDF(), initializealg = BrownFullBasicInit())  # OrdinaryDiffEq
sol = solve(prob, IDA(), initializealg = BrownFullBasicInit())    # Sundials

# Use Shampine&#39;s collocation method for general DAEs
sol = solve(prob, DFBDF(), initializealg = ShampineCollocationInit())  # OrdinaryDiffEq
sol = solve(prob, IDA(), initializealg = ShampineCollocationInit())    # Sundials

# RECOMMENDED: Verify conditions are consistent
sol = solve(prob, DFBDF(), initializealg = CheckInit())  # OrdinaryDiffEq
sol = solve(prob, IDA(), initializealg = CheckInit())    # Sundials

# NOT RECOMMENDED: Skip all initialization checks (dangerous!)
# sol = solve(prob, DFBDF(), initializealg = NoInit())  # ⚠️ USE AT YOUR OWN RISK
# sol = solve(prob, IDA(), initializealg = NoInit())    # ⚠️ USE AT YOUR OWN RISK</code></pre><h2 id="Troubleshooting"><a class="docs-heading-anchor" href="#Troubleshooting">Troubleshooting</a><a id="Troubleshooting-1"></a><a class="docs-heading-anchor-permalink" href="#Troubleshooting" title="Permalink"></a></h2><h3 id="Common-Issues-and-Solutions"><a class="docs-heading-anchor" href="#Common-Issues-and-Solutions">Common Issues and Solutions</a><a id="Common-Issues-and-Solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Issues-and-Solutions" title="Permalink"></a></h3><ol><li><p><strong>&quot;Initial conditions are not consistent&quot; error</strong></p><ul><li>Ensure your <code>du0</code> satisfies the DAE constraints at <code>t0</code></li><li>Try using <code>BrownFullBasicInit()</code> or <code>ShampineCollocationInit()</code> instead of <code>CheckInit()</code></li><li>Check that <code>differential_vars</code> correctly identifies differential vs algebraic variables</li></ul></li><li><p><strong>Initialization fails to converge</strong></p><ul><li>Relax tolerances if using extended versions</li><li>Try a different initialization algorithm</li><li>Provide a better initial guess for algebraic variables</li><li><strong>Check if your DAE is index-1</strong>: The system may be higher-index (see below)</li></ul></li><li><p><strong>Solver fails immediately after initialization</strong></p><ul><li>The initialization might have found a consistent but numerically unstable point</li><li>Try tightening initialization tolerances</li><li>Check problem scaling and consider non-dimensionalization</li></ul></li><li><p><strong>DAE is not index-1 (higher-index DAE)</strong></p><ul><li>Many initialization algorithms only work reliably for index-1 DAEs</li><li><strong>To check if your DAE is index-1</strong>: The Jacobian of the algebraic equations with respect to the algebraic variables must be non-singular</li><li><strong>Solution</strong>: Use ModelingToolkit.jl to analyze and potentially reduce the index:</li></ul><pre><code class="language-julia hljs">using ModelingToolkit

# Define your system with ModelingToolkit
@named sys = ODESystem(eqs, t, vars, params)

# Analyze and reduce the index (structural_simplify handles this in v10+)
sys_reduced = structural_simplify(sys)

# The reduced system will be index-1 and easier to initialize
prob = DAEProblem(sys_reduced, [], (0.0, 10.0), params)</code></pre><ul><li>ModelingToolkit can automatically detect the index and apply appropriate transformations</li><li>After index reduction, standard initialization algorithms will work more reliably</li></ul></li></ol><h2 id="Performance-Tips"><a class="docs-heading-anchor" href="#Performance-Tips">Performance Tips</a><a id="Performance-Tips-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Tips" title="Permalink"></a></h2><ol><li><strong>Use <code>differential_vars</code> when possible</strong>: This helps initialization algorithms understand problem structure</li><li><strong>Provide good initial guesses</strong>: Even when using automatic initialization, starting closer to the solution helps</li><li><strong>Consider problem-specific initialization</strong>: For complex systems, custom initialization procedures may be more efficient</li><li><strong>Use <code>CheckInit()</code> when appropriate</strong>: If you know conditions are consistent, skip unnecessary computation</li></ol><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ul><li>Brown, P. N., Hindmarsh, A. C., &amp; Petzold, L. R. (1998). Consistent initial condition calculation for differential-algebraic systems. SIAM Journal on Scientific Computing, 19(5), 1495-1512.</li><li>Shampine, L. F. (2002). Consistent initial condition for differential-algebraic systems. SIAM Journal on Scientific Computing, 22(6), 2007-2026.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../linear_nonlinear/">« Specifying (Non)Linear Solvers and Preconditioners</a><a class="docs-footer-nextpage" href="../callback_functions/">Event Handling and Callback Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 2 January 2026 04:23">Friday 2 January 2026</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
